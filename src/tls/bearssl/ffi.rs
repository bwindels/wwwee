/* automatically generated by rust-bindgen */

pub const _STDINT_H : :: std :: os :: raw :: c_uint = 1 ; pub const _FEATURES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _DEFAULT_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC11 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC99 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ISOC95 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX_IMPLICITLY : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_C_SOURCE : :: std :: os :: raw :: c_uint = 200809 ; pub const __USE_POSIX : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX2 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX199309 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_POSIX199506 : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_XOPEN2K : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_XOPEN2K8 : :: std :: os :: raw :: c_uint = 1 ; pub const _ATFILE_SOURCE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_MISC : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_ATFILE : :: std :: os :: raw :: c_uint = 1 ; pub const __USE_FORTIFY_LEVEL : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_DEPRECATED_GETS : :: std :: os :: raw :: c_uint = 0 ; pub const _STDC_PREDEF_H : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_IEC_559__ : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_IEC_559_COMPLEX__ : :: std :: os :: raw :: c_uint = 1 ; pub const __STDC_ISO_10646__ : :: std :: os :: raw :: c_uint = 201706 ; pub const __STDC_NO_THREADS__ : :: std :: os :: raw :: c_uint = 1 ; pub const __GNU_LIBRARY__ : :: std :: os :: raw :: c_uint = 6 ; pub const __GLIBC__ : :: std :: os :: raw :: c_uint = 2 ; pub const __GLIBC_MINOR__ : :: std :: os :: raw :: c_uint = 26 ; pub const _SYS_CDEFS_H : :: std :: os :: raw :: c_uint = 1 ; pub const __glibc_c99_flexarr_available : :: std :: os :: raw :: c_uint = 1 ; pub const __WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : :: std :: os :: raw :: c_uint = 1 ; pub const __SYSCALL_WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const __HAVE_GENERIC_SELECTION : :: std :: os :: raw :: c_uint = 1 ; pub const __GLIBC_USE_LIB_EXT2 : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const __GLIBC_USE_IEC_60559_TYPES_EXT : :: std :: os :: raw :: c_uint = 0 ; pub const _BITS_TYPES_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_TYPESIZES_H : :: std :: os :: raw :: c_uint = 1 ; pub const __OFF_T_MATCHES_OFF64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __INO_T_MATCHES_INO64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __RLIM_T_MATCHES_RLIM64_T : :: std :: os :: raw :: c_uint = 1 ; pub const __FD_SETSIZE : :: std :: os :: raw :: c_uint = 1024 ; pub const _BITS_WCHAR_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_STDINT_INTN_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_STDINT_UINTN_H : :: std :: os :: raw :: c_uint = 1 ; pub const INT8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const UINT8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const INT_LEAST8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT_LEAST16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT_LEAST32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT_LEAST8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT_LEAST16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT_LEAST32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const UINT_LEAST8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT_LEAST16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT_LEAST32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const INT_FAST8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT_FAST16_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INT_FAST32_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INT_FAST8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT_FAST16_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const INT_FAST32_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINT_FAST8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT_FAST16_MAX : :: std :: os :: raw :: c_int = -1 ; pub const UINT_FAST32_MAX : :: std :: os :: raw :: c_int = -1 ; pub const INTPTR_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INTPTR_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINTPTR_MAX : :: std :: os :: raw :: c_int = -1 ; pub const PTRDIFF_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const PTRDIFF_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const SIG_ATOMIC_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const SIZE_MAX : :: std :: os :: raw :: c_int = -1 ; pub const WINT_MIN : :: std :: os :: raw :: c_uint = 0 ; pub const WINT_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const _STRING_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_TYPES_LOCALE_T_H : :: std :: os :: raw :: c_uint = 1 ; pub const _BITS_TYPES___LOCALE_T_H : :: std :: os :: raw :: c_uint = 1 ; pub const _STRINGS_H : :: std :: os :: raw :: c_uint = 1 ; pub const BR_HASHDESC_ID_OFF : :: std :: os :: raw :: c_uint = 0 ; pub const BR_HASHDESC_ID_MASK : :: std :: os :: raw :: c_uint = 255 ; pub const BR_HASHDESC_OUT_OFF : :: std :: os :: raw :: c_uint = 8 ; pub const BR_HASHDESC_OUT_MASK : :: std :: os :: raw :: c_uint = 127 ; pub const BR_HASHDESC_STATE_OFF : :: std :: os :: raw :: c_uint = 15 ; pub const BR_HASHDESC_STATE_MASK : :: std :: os :: raw :: c_uint = 255 ; pub const BR_HASHDESC_LBLEN_OFF : :: std :: os :: raw :: c_uint = 23 ; pub const BR_HASHDESC_LBLEN_MASK : :: std :: os :: raw :: c_uint = 15 ; pub const br_md5_ID : :: std :: os :: raw :: c_uint = 1 ; pub const br_md5_SIZE : :: std :: os :: raw :: c_uint = 16 ; pub const br_sha1_ID : :: std :: os :: raw :: c_uint = 2 ; pub const br_sha1_SIZE : :: std :: os :: raw :: c_uint = 20 ; pub const br_sha224_ID : :: std :: os :: raw :: c_uint = 3 ; pub const br_sha224_SIZE : :: std :: os :: raw :: c_uint = 28 ; pub const br_sha256_ID : :: std :: os :: raw :: c_uint = 4 ; pub const br_sha256_SIZE : :: std :: os :: raw :: c_uint = 32 ; pub const br_sha384_ID : :: std :: os :: raw :: c_uint = 5 ; pub const br_sha384_SIZE : :: std :: os :: raw :: c_uint = 48 ; pub const br_sha512_ID : :: std :: os :: raw :: c_uint = 6 ; pub const br_sha512_SIZE : :: std :: os :: raw :: c_uint = 64 ; pub const br_md5sha1_ID : :: std :: os :: raw :: c_uint = 0 ; pub const br_md5sha1_SIZE : :: std :: os :: raw :: c_uint = 36 ; pub const br_aes_big_BLOCK_SIZE : :: std :: os :: raw :: c_uint = 16 ; pub const br_aes_small_BLOCK_SIZE : :: std :: os :: raw :: c_uint = 16 ; pub const br_aes_ct_BLOCK_SIZE : :: std :: os :: raw :: c_uint = 16 ; pub const br_aes_ct64_BLOCK_SIZE : :: std :: os :: raw :: c_uint = 16 ; pub const br_aes_x86ni_BLOCK_SIZE : :: std :: os :: raw :: c_uint = 16 ; pub const br_aes_pwr8_BLOCK_SIZE : :: std :: os :: raw :: c_uint = 16 ; pub const br_des_tab_BLOCK_SIZE : :: std :: os :: raw :: c_uint = 8 ; pub const br_des_ct_BLOCK_SIZE : :: std :: os :: raw :: c_uint = 8 ; pub const BR_EC_sect163k1 : :: std :: os :: raw :: c_uint = 1 ; pub const BR_EC_sect163r1 : :: std :: os :: raw :: c_uint = 2 ; pub const BR_EC_sect163r2 : :: std :: os :: raw :: c_uint = 3 ; pub const BR_EC_sect193r1 : :: std :: os :: raw :: c_uint = 4 ; pub const BR_EC_sect193r2 : :: std :: os :: raw :: c_uint = 5 ; pub const BR_EC_sect233k1 : :: std :: os :: raw :: c_uint = 6 ; pub const BR_EC_sect233r1 : :: std :: os :: raw :: c_uint = 7 ; pub const BR_EC_sect239k1 : :: std :: os :: raw :: c_uint = 8 ; pub const BR_EC_sect283k1 : :: std :: os :: raw :: c_uint = 9 ; pub const BR_EC_sect283r1 : :: std :: os :: raw :: c_uint = 10 ; pub const BR_EC_sect409k1 : :: std :: os :: raw :: c_uint = 11 ; pub const BR_EC_sect409r1 : :: std :: os :: raw :: c_uint = 12 ; pub const BR_EC_sect571k1 : :: std :: os :: raw :: c_uint = 13 ; pub const BR_EC_sect571r1 : :: std :: os :: raw :: c_uint = 14 ; pub const BR_EC_secp160k1 : :: std :: os :: raw :: c_uint = 15 ; pub const BR_EC_secp160r1 : :: std :: os :: raw :: c_uint = 16 ; pub const BR_EC_secp160r2 : :: std :: os :: raw :: c_uint = 17 ; pub const BR_EC_secp192k1 : :: std :: os :: raw :: c_uint = 18 ; pub const BR_EC_secp192r1 : :: std :: os :: raw :: c_uint = 19 ; pub const BR_EC_secp224k1 : :: std :: os :: raw :: c_uint = 20 ; pub const BR_EC_secp224r1 : :: std :: os :: raw :: c_uint = 21 ; pub const BR_EC_secp256k1 : :: std :: os :: raw :: c_uint = 22 ; pub const BR_EC_secp256r1 : :: std :: os :: raw :: c_uint = 23 ; pub const BR_EC_secp384r1 : :: std :: os :: raw :: c_uint = 24 ; pub const BR_EC_secp521r1 : :: std :: os :: raw :: c_uint = 25 ; pub const BR_EC_brainpoolP256r1 : :: std :: os :: raw :: c_uint = 26 ; pub const BR_EC_brainpoolP384r1 : :: std :: os :: raw :: c_uint = 27 ; pub const BR_EC_brainpoolP512r1 : :: std :: os :: raw :: c_uint = 28 ; pub const BR_EC_curve25519 : :: std :: os :: raw :: c_uint = 29 ; pub const BR_EC_curve448 : :: std :: os :: raw :: c_uint = 30 ; pub const BR_ERR_X509_OK : :: std :: os :: raw :: c_uint = 32 ; pub const BR_ERR_X509_INVALID_VALUE : :: std :: os :: raw :: c_uint = 33 ; pub const BR_ERR_X509_TRUNCATED : :: std :: os :: raw :: c_uint = 34 ; pub const BR_ERR_X509_EMPTY_CHAIN : :: std :: os :: raw :: c_uint = 35 ; pub const BR_ERR_X509_INNER_TRUNC : :: std :: os :: raw :: c_uint = 36 ; pub const BR_ERR_X509_BAD_TAG_CLASS : :: std :: os :: raw :: c_uint = 37 ; pub const BR_ERR_X509_BAD_TAG_VALUE : :: std :: os :: raw :: c_uint = 38 ; pub const BR_ERR_X509_INDEFINITE_LENGTH : :: std :: os :: raw :: c_uint = 39 ; pub const BR_ERR_X509_EXTRA_ELEMENT : :: std :: os :: raw :: c_uint = 40 ; pub const BR_ERR_X509_UNEXPECTED : :: std :: os :: raw :: c_uint = 41 ; pub const BR_ERR_X509_NOT_CONSTRUCTED : :: std :: os :: raw :: c_uint = 42 ; pub const BR_ERR_X509_NOT_PRIMITIVE : :: std :: os :: raw :: c_uint = 43 ; pub const BR_ERR_X509_PARTIAL_BYTE : :: std :: os :: raw :: c_uint = 44 ; pub const BR_ERR_X509_BAD_BOOLEAN : :: std :: os :: raw :: c_uint = 45 ; pub const BR_ERR_X509_OVERFLOW : :: std :: os :: raw :: c_uint = 46 ; pub const BR_ERR_X509_BAD_DN : :: std :: os :: raw :: c_uint = 47 ; pub const BR_ERR_X509_BAD_TIME : :: std :: os :: raw :: c_uint = 48 ; pub const BR_ERR_X509_UNSUPPORTED : :: std :: os :: raw :: c_uint = 49 ; pub const BR_ERR_X509_LIMIT_EXCEEDED : :: std :: os :: raw :: c_uint = 50 ; pub const BR_ERR_X509_WRONG_KEY_TYPE : :: std :: os :: raw :: c_uint = 51 ; pub const BR_ERR_X509_BAD_SIGNATURE : :: std :: os :: raw :: c_uint = 52 ; pub const BR_ERR_X509_TIME_UNKNOWN : :: std :: os :: raw :: c_uint = 53 ; pub const BR_ERR_X509_EXPIRED : :: std :: os :: raw :: c_uint = 54 ; pub const BR_ERR_X509_DN_MISMATCH : :: std :: os :: raw :: c_uint = 55 ; pub const BR_ERR_X509_BAD_SERVER_NAME : :: std :: os :: raw :: c_uint = 56 ; pub const BR_ERR_X509_CRITICAL_EXTENSION : :: std :: os :: raw :: c_uint = 57 ; pub const BR_ERR_X509_NOT_CA : :: std :: os :: raw :: c_uint = 58 ; pub const BR_ERR_X509_FORBIDDEN_KEY_USAGE : :: std :: os :: raw :: c_uint = 59 ; pub const BR_ERR_X509_WEAK_PUBLIC_KEY : :: std :: os :: raw :: c_uint = 60 ; pub const BR_ERR_X509_NOT_TRUSTED : :: std :: os :: raw :: c_uint = 62 ; pub const BR_X509_TA_CA : :: std :: os :: raw :: c_uint = 1 ; pub const BR_KEYTYPE_RSA : :: std :: os :: raw :: c_uint = 1 ; pub const BR_KEYTYPE_EC : :: std :: os :: raw :: c_uint = 2 ; pub const BR_KEYTYPE_KEYX : :: std :: os :: raw :: c_uint = 16 ; pub const BR_KEYTYPE_SIGN : :: std :: os :: raw :: c_uint = 32 ; pub const BR_X509_BUFSIZE_KEY : :: std :: os :: raw :: c_uint = 520 ; pub const BR_X509_BUFSIZE_SIG : :: std :: os :: raw :: c_uint = 512 ; pub const BR_SSL_BUFSIZE_INPUT : :: std :: os :: raw :: c_uint = 16709 ; pub const BR_SSL_BUFSIZE_OUTPUT : :: std :: os :: raw :: c_uint = 16469 ; pub const BR_SSL_BUFSIZE_MONO : :: std :: os :: raw :: c_uint = 16709 ; pub const BR_SSL_BUFSIZE_BIDI : :: std :: os :: raw :: c_uint = 33178 ; pub const BR_SSL30 : :: std :: os :: raw :: c_uint = 768 ; pub const BR_TLS10 : :: std :: os :: raw :: c_uint = 769 ; pub const BR_TLS11 : :: std :: os :: raw :: c_uint = 770 ; pub const BR_TLS12 : :: std :: os :: raw :: c_uint = 771 ; pub const BR_ERR_OK : :: std :: os :: raw :: c_uint = 0 ; pub const BR_ERR_BAD_PARAM : :: std :: os :: raw :: c_uint = 1 ; pub const BR_ERR_BAD_STATE : :: std :: os :: raw :: c_uint = 2 ; pub const BR_ERR_UNSUPPORTED_VERSION : :: std :: os :: raw :: c_uint = 3 ; pub const BR_ERR_BAD_VERSION : :: std :: os :: raw :: c_uint = 4 ; pub const BR_ERR_BAD_LENGTH : :: std :: os :: raw :: c_uint = 5 ; pub const BR_ERR_TOO_LARGE : :: std :: os :: raw :: c_uint = 6 ; pub const BR_ERR_BAD_MAC : :: std :: os :: raw :: c_uint = 7 ; pub const BR_ERR_NO_RANDOM : :: std :: os :: raw :: c_uint = 8 ; pub const BR_ERR_UNKNOWN_TYPE : :: std :: os :: raw :: c_uint = 9 ; pub const BR_ERR_UNEXPECTED : :: std :: os :: raw :: c_uint = 10 ; pub const BR_ERR_BAD_CCS : :: std :: os :: raw :: c_uint = 12 ; pub const BR_ERR_BAD_ALERT : :: std :: os :: raw :: c_uint = 13 ; pub const BR_ERR_BAD_HANDSHAKE : :: std :: os :: raw :: c_uint = 14 ; pub const BR_ERR_OVERSIZED_ID : :: std :: os :: raw :: c_uint = 15 ; pub const BR_ERR_BAD_CIPHER_SUITE : :: std :: os :: raw :: c_uint = 16 ; pub const BR_ERR_BAD_COMPRESSION : :: std :: os :: raw :: c_uint = 17 ; pub const BR_ERR_BAD_FRAGLEN : :: std :: os :: raw :: c_uint = 18 ; pub const BR_ERR_BAD_SECRENEG : :: std :: os :: raw :: c_uint = 19 ; pub const BR_ERR_EXTRA_EXTENSION : :: std :: os :: raw :: c_uint = 20 ; pub const BR_ERR_BAD_SNI : :: std :: os :: raw :: c_uint = 21 ; pub const BR_ERR_BAD_HELLO_DONE : :: std :: os :: raw :: c_uint = 22 ; pub const BR_ERR_LIMIT_EXCEEDED : :: std :: os :: raw :: c_uint = 23 ; pub const BR_ERR_BAD_FINISHED : :: std :: os :: raw :: c_uint = 24 ; pub const BR_ERR_RESUME_MISMATCH : :: std :: os :: raw :: c_uint = 25 ; pub const BR_ERR_INVALID_ALGORITHM : :: std :: os :: raw :: c_uint = 26 ; pub const BR_ERR_BAD_SIGNATURE : :: std :: os :: raw :: c_uint = 27 ; pub const BR_ERR_WRONG_KEY_USAGE : :: std :: os :: raw :: c_uint = 28 ; pub const BR_ERR_NO_CLIENT_AUTH : :: std :: os :: raw :: c_uint = 29 ; pub const BR_ERR_IO : :: std :: os :: raw :: c_uint = 31 ; pub const BR_ERR_RECV_FATAL_ALERT : :: std :: os :: raw :: c_uint = 256 ; pub const BR_ERR_SEND_FATAL_ALERT : :: std :: os :: raw :: c_uint = 512 ; pub const BR_MAX_CIPHER_SUITES : :: std :: os :: raw :: c_uint = 40 ; pub const BR_SSL_CLOSED : :: std :: os :: raw :: c_uint = 1 ; pub const BR_SSL_SENDREC : :: std :: os :: raw :: c_uint = 2 ; pub const BR_SSL_RECVREC : :: std :: os :: raw :: c_uint = 4 ; pub const BR_SSL_SENDAPP : :: std :: os :: raw :: c_uint = 8 ; pub const BR_SSL_RECVAPP : :: std :: os :: raw :: c_uint = 16 ; pub const BR_AUTH_ECDH : :: std :: os :: raw :: c_uint = 0 ; pub const BR_AUTH_RSA : :: std :: os :: raw :: c_uint = 1 ; pub const BR_AUTH_ECDSA : :: std :: os :: raw :: c_uint = 3 ; pub const BR_SSLKEYX_RSA : :: std :: os :: raw :: c_uint = 0 ; pub const BR_SSLKEYX_ECDHE_RSA : :: std :: os :: raw :: c_uint = 1 ; pub const BR_SSLKEYX_ECDHE_ECDSA : :: std :: os :: raw :: c_uint = 2 ; pub const BR_SSLKEYX_ECDH_RSA : :: std :: os :: raw :: c_uint = 3 ; pub const BR_SSLKEYX_ECDH_ECDSA : :: std :: os :: raw :: c_uint = 4 ; pub const BR_SSLENC_3DES_CBC : :: std :: os :: raw :: c_uint = 0 ; pub const BR_SSLENC_AES128_CBC : :: std :: os :: raw :: c_uint = 1 ; pub const BR_SSLENC_AES256_CBC : :: std :: os :: raw :: c_uint = 2 ; pub const BR_SSLENC_AES128_GCM : :: std :: os :: raw :: c_uint = 3 ; pub const BR_SSLENC_AES256_GCM : :: std :: os :: raw :: c_uint = 4 ; pub const BR_SSLENC_CHACHA20 : :: std :: os :: raw :: c_uint = 5 ; pub const BR_SSLMAC_AEAD : :: std :: os :: raw :: c_uint = 0 ; pub const BR_SSLMAC_SHA1 : :: std :: os :: raw :: c_uint = 2 ; pub const BR_SSLMAC_SHA256 : :: std :: os :: raw :: c_uint = 4 ; pub const BR_SSLMAC_SHA384 : :: std :: os :: raw :: c_uint = 5 ; pub const BR_SSLPRF_SHA256 : :: std :: os :: raw :: c_uint = 4 ; pub const BR_SSLPRF_SHA384 : :: std :: os :: raw :: c_uint = 5 ; pub const BR_TLS_NULL_WITH_NULL_NULL : :: std :: os :: raw :: c_uint = 0 ; pub const BR_TLS_RSA_WITH_NULL_MD5 : :: std :: os :: raw :: c_uint = 1 ; pub const BR_TLS_RSA_WITH_NULL_SHA : :: std :: os :: raw :: c_uint = 2 ; pub const BR_TLS_RSA_WITH_NULL_SHA256 : :: std :: os :: raw :: c_uint = 59 ; pub const BR_TLS_RSA_WITH_RC4_128_MD5 : :: std :: os :: raw :: c_uint = 4 ; pub const BR_TLS_RSA_WITH_RC4_128_SHA : :: std :: os :: raw :: c_uint = 5 ; pub const BR_TLS_RSA_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 10 ; pub const BR_TLS_RSA_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 47 ; pub const BR_TLS_RSA_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 53 ; pub const BR_TLS_RSA_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 60 ; pub const BR_TLS_RSA_WITH_AES_256_CBC_SHA256 : :: std :: os :: raw :: c_uint = 61 ; pub const BR_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 13 ; pub const BR_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 16 ; pub const BR_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 19 ; pub const BR_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 22 ; pub const BR_TLS_DH_DSS_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 48 ; pub const BR_TLS_DH_RSA_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 49 ; pub const BR_TLS_DHE_DSS_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 50 ; pub const BR_TLS_DHE_RSA_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 51 ; pub const BR_TLS_DH_DSS_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 54 ; pub const BR_TLS_DH_RSA_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 55 ; pub const BR_TLS_DHE_DSS_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 56 ; pub const BR_TLS_DHE_RSA_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 57 ; pub const BR_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 62 ; pub const BR_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 63 ; pub const BR_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 64 ; pub const BR_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 103 ; pub const BR_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 : :: std :: os :: raw :: c_uint = 104 ; pub const BR_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 : :: std :: os :: raw :: c_uint = 105 ; pub const BR_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 : :: std :: os :: raw :: c_uint = 106 ; pub const BR_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 : :: std :: os :: raw :: c_uint = 107 ; pub const BR_TLS_DH_anon_WITH_RC4_128_MD5 : :: std :: os :: raw :: c_uint = 24 ; pub const BR_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 27 ; pub const BR_TLS_DH_anon_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 52 ; pub const BR_TLS_DH_anon_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 58 ; pub const BR_TLS_DH_anon_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 108 ; pub const BR_TLS_DH_anon_WITH_AES_256_CBC_SHA256 : :: std :: os :: raw :: c_uint = 109 ; pub const BR_TLS_ECDH_ECDSA_WITH_NULL_SHA : :: std :: os :: raw :: c_uint = 49153 ; pub const BR_TLS_ECDH_ECDSA_WITH_RC4_128_SHA : :: std :: os :: raw :: c_uint = 49154 ; pub const BR_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 49155 ; pub const BR_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 49156 ; pub const BR_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 49157 ; pub const BR_TLS_ECDHE_ECDSA_WITH_NULL_SHA : :: std :: os :: raw :: c_uint = 49158 ; pub const BR_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA : :: std :: os :: raw :: c_uint = 49159 ; pub const BR_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 49160 ; pub const BR_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 49161 ; pub const BR_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 49162 ; pub const BR_TLS_ECDH_RSA_WITH_NULL_SHA : :: std :: os :: raw :: c_uint = 49163 ; pub const BR_TLS_ECDH_RSA_WITH_RC4_128_SHA : :: std :: os :: raw :: c_uint = 49164 ; pub const BR_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 49165 ; pub const BR_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 49166 ; pub const BR_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 49167 ; pub const BR_TLS_ECDHE_RSA_WITH_NULL_SHA : :: std :: os :: raw :: c_uint = 49168 ; pub const BR_TLS_ECDHE_RSA_WITH_RC4_128_SHA : :: std :: os :: raw :: c_uint = 49169 ; pub const BR_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 49170 ; pub const BR_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 49171 ; pub const BR_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 49172 ; pub const BR_TLS_ECDH_anon_WITH_NULL_SHA : :: std :: os :: raw :: c_uint = 49173 ; pub const BR_TLS_ECDH_anon_WITH_RC4_128_SHA : :: std :: os :: raw :: c_uint = 49174 ; pub const BR_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA : :: std :: os :: raw :: c_uint = 49175 ; pub const BR_TLS_ECDH_anon_WITH_AES_128_CBC_SHA : :: std :: os :: raw :: c_uint = 49176 ; pub const BR_TLS_ECDH_anon_WITH_AES_256_CBC_SHA : :: std :: os :: raw :: c_uint = 49177 ; pub const BR_TLS_RSA_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 156 ; pub const BR_TLS_RSA_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 157 ; pub const BR_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 158 ; pub const BR_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 159 ; pub const BR_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 160 ; pub const BR_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 161 ; pub const BR_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 162 ; pub const BR_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 163 ; pub const BR_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 164 ; pub const BR_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 165 ; pub const BR_TLS_DH_anon_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 166 ; pub const BR_TLS_DH_anon_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 167 ; pub const BR_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 49187 ; pub const BR_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 : :: std :: os :: raw :: c_uint = 49188 ; pub const BR_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 49189 ; pub const BR_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 : :: std :: os :: raw :: c_uint = 49190 ; pub const BR_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 49191 ; pub const BR_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 : :: std :: os :: raw :: c_uint = 49192 ; pub const BR_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 : :: std :: os :: raw :: c_uint = 49193 ; pub const BR_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 : :: std :: os :: raw :: c_uint = 49194 ; pub const BR_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 49195 ; pub const BR_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 49196 ; pub const BR_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 49197 ; pub const BR_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 49198 ; pub const BR_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 49199 ; pub const BR_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 49200 ; pub const BR_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 : :: std :: os :: raw :: c_uint = 49201 ; pub const BR_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 : :: std :: os :: raw :: c_uint = 49202 ; pub const BR_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 : :: std :: os :: raw :: c_uint = 52392 ; pub const BR_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 : :: std :: os :: raw :: c_uint = 52393 ; pub const BR_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 : :: std :: os :: raw :: c_uint = 52394 ; pub const BR_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 : :: std :: os :: raw :: c_uint = 52395 ; pub const BR_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 : :: std :: os :: raw :: c_uint = 52396 ; pub const BR_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 : :: std :: os :: raw :: c_uint = 52397 ; pub const BR_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 : :: std :: os :: raw :: c_uint = 52398 ; pub const BR_TLS_FALLBACK_SCSV : :: std :: os :: raw :: c_uint = 22016 ; pub const BR_ALERT_CLOSE_NOTIFY : :: std :: os :: raw :: c_uint = 0 ; pub const BR_ALERT_UNEXPECTED_MESSAGE : :: std :: os :: raw :: c_uint = 10 ; pub const BR_ALERT_BAD_RECORD_MAC : :: std :: os :: raw :: c_uint = 20 ; pub const BR_ALERT_RECORD_OVERFLOW : :: std :: os :: raw :: c_uint = 22 ; pub const BR_ALERT_DECOMPRESSION_FAILURE : :: std :: os :: raw :: c_uint = 30 ; pub const BR_ALERT_HANDSHAKE_FAILURE : :: std :: os :: raw :: c_uint = 40 ; pub const BR_ALERT_BAD_CERTIFICATE : :: std :: os :: raw :: c_uint = 42 ; pub const BR_ALERT_UNSUPPORTED_CERTIFICATE : :: std :: os :: raw :: c_uint = 43 ; pub const BR_ALERT_CERTIFICATE_REVOKED : :: std :: os :: raw :: c_uint = 44 ; pub const BR_ALERT_CERTIFICATE_EXPIRED : :: std :: os :: raw :: c_uint = 45 ; pub const BR_ALERT_CERTIFICATE_UNKNOWN : :: std :: os :: raw :: c_uint = 46 ; pub const BR_ALERT_ILLEGAL_PARAMETER : :: std :: os :: raw :: c_uint = 47 ; pub const BR_ALERT_UNKNOWN_CA : :: std :: os :: raw :: c_uint = 48 ; pub const BR_ALERT_ACCESS_DENIED : :: std :: os :: raw :: c_uint = 49 ; pub const BR_ALERT_DECODE_ERROR : :: std :: os :: raw :: c_uint = 50 ; pub const BR_ALERT_DECRYPT_ERROR : :: std :: os :: raw :: c_uint = 51 ; pub const BR_ALERT_PROTOCOL_VERSION : :: std :: os :: raw :: c_uint = 70 ; pub const BR_ALERT_INSUFFICIENT_SECURITY : :: std :: os :: raw :: c_uint = 71 ; pub const BR_ALERT_INTERNAL_ERROR : :: std :: os :: raw :: c_uint = 80 ; pub const BR_ALERT_USER_CANCELED : :: std :: os :: raw :: c_uint = 90 ; pub const BR_ALERT_NO_RENEGOTIATION : :: std :: os :: raw :: c_uint = 100 ; pub const BR_ALERT_UNSUPPORTED_EXTENSION : :: std :: os :: raw :: c_uint = 110 ; pub const BR_ALERT_NO_APPLICATION_PROTOCOL : :: std :: os :: raw :: c_uint = 120 ; pub const BR_PEM_BEGIN_OBJ : :: std :: os :: raw :: c_uint = 1 ; pub const BR_PEM_END_OBJ : :: std :: os :: raw :: c_uint = 2 ; pub const BR_PEM_ERROR : :: std :: os :: raw :: c_uint = 3 ; pub type wchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 , } # [ test ] fn bindgen_test_layout_max_align_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < max_align_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( max_align_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < max_align_t > ( ) ) ) . __clang_max_align_nonce1 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < max_align_t > ( ) ) ) . __clang_max_align_nonce2 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce2 ) ) ) ; } pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __intmax_t = :: std :: os :: raw :: c_long ; pub type __uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __fsid_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __qaddr_t = * mut __quad_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; extern "C" {
 pub fn memcpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize , ) -> * mut :: std :: os :: raw :: c_void ; 
} extern "C" {
 pub fn memmove ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize , ) -> * mut :: std :: os :: raw :: c_void ; 
} extern "C" {
 pub fn memccpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize , ) -> * mut :: std :: os :: raw :: c_void ; 
} extern "C" {
 pub fn memset ( __s : * mut :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize , ) -> * mut :: std :: os :: raw :: c_void ; 
} extern "C" {
 pub fn memcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn memchr ( __s : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize , ) -> * mut :: std :: os :: raw :: c_void ; 
} extern "C" {
 pub fn strcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strcat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strncat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strcmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strncmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strcoll ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strxfrm ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , ) -> :: std :: os :: raw :: c_ulong ; 
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [ * const :: std :: os :: raw :: c_char ; 13usize ] , } # [ test ] fn bindgen_test_layout___locale_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __locale_struct > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __locale_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __locales as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __locales ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_b as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_b ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_tolower as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_tolower ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_toupper as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_toupper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __names as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __names ) ) ) ; } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" {
 pub fn strcoll_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __l : locale_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strxfrm_l ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , __l : locale_t , ) -> usize ; 
} extern "C" {
 pub fn strdup ( __s : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strndup ( __string : * const :: std :: os :: raw :: c_char , __n : usize , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strrchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strcspn ( __s : * const :: std :: os :: raw :: c_char , __reject : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_ulong ; 
} extern "C" {
 pub fn strspn ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_ulong ; 
} extern "C" {
 pub fn strpbrk ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strstr ( __haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strtok ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn __strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strlen ( __s : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_ulong ; 
} extern "C" {
 pub fn strnlen ( __string : * const :: std :: os :: raw :: c_char , __maxlen : usize , ) -> usize ; 
} extern "C" {
 pub fn strerror ( __errnum : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 # [ link_name = "\u{1}__xpg_strerror_r" ] 
 pub fn strerror_r ( __errnum : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strerror_l ( __errnum : :: std :: os :: raw :: c_int , __l : locale_t , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn bcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn bcopy ( __src : * const :: std :: os :: raw :: c_void , __dest : * mut :: std :: os :: raw :: c_void , __n : usize , ) ; 
} extern "C" {
 pub fn bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize , ) ; 
} extern "C" {
 pub fn index ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn rindex ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn ffs ( __i : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strcasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strncasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strcasecmp_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __loc : locale_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn strncasecmp_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize , __loc : locale_t , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 pub fn explicit_bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize , ) ; 
} extern "C" {
 pub fn strsep ( __stringp : * mut * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn strsignal ( __sig : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn __stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn __stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , ) -> * mut :: std :: os :: raw :: c_char ; 
} extern "C" {
 pub fn stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , ) -> * mut :: std :: os :: raw :: c_char ; 
} 
 /// \brief Class type for hash function implementations.
///
/// A `br_hash_class` instance references the methods implementing a hash
/// function. Constant instances of this structure are defined for each
/// implemented hash function. Such instances are also called "vtables".
///
/// Vtables are used to support object-oriented programming, as
/// described on [the BearSSL Web site](https://www.bearssl.org/oop.html). 
 pub type br_hash_class = br_hash_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_hash_class_ { 
 /// \brief Size (in bytes) of the context structure appropriate for
    /// computing this hash function. 
 pub context_size : usize , 
 /// \brief Descriptor word that contains information about the hash
    /// function.
    ///
    /// For each word `xxx` described below, use `BR_HASHDESC_xxx_OFF`
    /// and `BR_HASHDESC_xxx_MASK` to access the specific value, as
    /// follows:
    ///
    /// (hf->desc >> BR_HASHDESC_xxx_OFF) & BR_HASHDESC_xxx_MASK
    ///
    /// The defined elements are:
    ///
    /// - `ID`: the symbolic identifier for the function, as defined
    /// in [TLS](https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1)
    /// (MD5 = 1, SHA-1 = 2,...).
    ///
    /// - `OUT`: hash output size, in bytes.
    ///
    /// - `STATE`: internal running state size, in bytes.
    ///
    /// - `LBLEN`: base-2 logarithm for the internal block size, as
    /// defined for HMAC processing (this is 6 for MD5, SHA-1, SHA-224
    /// and SHA-256, since these functions use 64-byte blocks; for
    /// SHA-384 and SHA-512, this is 7, corresponding to their
    /// 128-byte blocks).
    ///
    /// The descriptor may contain a few other flags. 
 pub desc : u32 , 
 /// \brief Initialisation method.
    ///
    /// This method takes as parameter a pointer to a context area,
    /// that it initialises. The first field of the context is set
    /// to this vtable; other elements are initialised for a new hash
    /// computation.
    ///
    /// \param ctx   pointer to (the first field of) the context. 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_hash_class ) > , 
 /// \brief Data injection method.
    ///
    /// The `len` bytes starting at address `data` are injected into
    /// the running hash computation incarnated by the specified
    /// context. The context is updated accordingly. It is allowed
    /// to have `len == 0`, in which case `data` is ignored (and could
    /// be `NULL`), and nothing happens.
    /// on the input data.
    ///
    /// \param ctx    pointer to (the first field of) the context.
    /// \param data   pointer to the first data byte to inject.
    /// \param len    number of bytes to inject. 
 pub update : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_hash_class , data : * const :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Produce hash output.
    ///
    /// The hash output corresponding to all data bytes injected in the
    /// context since the last `init()` call is computed, and written
    /// in the buffer pointed to by `dst`. The hash output size depends
    /// on the implemented hash function (e.g. 16 bytes for MD5).
    /// The context is _not_ modified by this call, so further bytes
    /// may be afterwards injected to continue the current computation.
    ///
    /// \param ctx   pointer to (the first field of) the context.
    /// \param dst   destination buffer for the hash output. 
 pub out : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_hash_class , dst : * mut :: std :: os :: raw :: c_void ) > , 
 /// \brief Get running state.
    ///
    /// This method saves the current running state into the `dst`
    /// buffer. What constitutes the "running state" depends on the
    /// hash function; for Merkle-Damg√•rd hash functions (like
    /// MD5 or SHA-1), this is the output obtained after processing
    /// each block. The number of bytes injected so far is returned.
    /// The context is not modified by this call.
    ///
    /// \param ctx   pointer to (the first field of) the context.
    /// \param dst   destination buffer for the state.
    /// \return  the injected total byte length. 
 pub state : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_hash_class , dst : * mut :: std :: os :: raw :: c_void ) -> u64 > , 
 /// \brief Set running state.
    ///
    /// This methods replaces the running state for the function.
    ///
    /// \param ctx     pointer to (the first field of) the context.
    /// \param stb     source buffer for the state.
    /// \param count   injected total byte length. 
 pub set_state : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_hash_class , stb : * const :: std :: os :: raw :: c_void , count : u64 ) > , } # [ test ] fn bindgen_test_layout_br_hash_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_hash_class_ > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( br_hash_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_hash_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_hash_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_class_ > ( ) ) ) . desc as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_class_ ) , "::" , stringify ! ( desc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_class_ > ( ) ) ) . init as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_class_ ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_class_ > ( ) ) ) . update as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_class_ ) , "::" , stringify ! ( update ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_class_ > ( ) ) ) . out as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_class_ ) , "::" , stringify ! ( out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_class_ > ( ) ) ) . state as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_class_ ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_class_ > ( ) ) ) . set_state as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_class_ ) , "::" , stringify ! ( set_state ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_md5_vtable" ] 
 pub static mut  br_md5_vtable  :  br_hash_class ;
} 
 /// \brief MD5 context.
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_md5_context { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_hash_class , pub buf : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub count : u64 , pub val : [ u32 ; 4usize ] , } # [ test ] fn bindgen_test_layout_br_md5_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_md5_context > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( br_md5_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_md5_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_md5_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_md5_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5_context > ( ) ) ) . buf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_md5_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5_context > ( ) ) ) . count as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_md5_context ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5_context > ( ) ) ) . val as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_md5_context ) , "::" , stringify ! ( val ) ) ) ; } extern "C" {
 
 /// \brief MD5 context initialisation.
///
/// This function initialises or resets a context for a new MD5
/// computation. It also sets the vtable pointer.
///
/// \param ctx   pointer to the context structure. 
 
 pub fn br_md5_init ( ctx : * mut br_md5_context , ) ; 
} extern "C" {
 
 /// \brief Inject some data bytes in a running MD5 computation.
///
/// The provided context is updated with some data bytes. If the number
/// of bytes (`len`) is zero, then the data pointer (`data`) is ignored
/// and may be `NULL`, and this function does nothing.
///
/// \param ctx    pointer to the context structure.
/// \param data   pointer to the injected data.
/// \param len    injected data length (in bytes). 
 
 pub fn br_md5_update ( ctx : * mut br_md5_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute MD5 output.
///
/// The MD5 output for the concatenation of all bytes injected in the
/// provided context since the last initialisation or reset call, is
/// computed and written in the buffer pointed to by `out`. The context
/// itself is not modified, so extra bytes may be injected afterwards
/// to continue that computation.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the hash output. 
 
 pub fn br_md5_out ( ctx : * const br_md5_context , out : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Save MD5 running state.
///
/// The running state for MD5 (output of the last internal block
/// processing) is written in the buffer pointed to by `out`. The
/// number of bytes injected since the last initialisation or reset
/// call is returned. The context is not modified.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the running state.
/// \return  the injected total byte length. 
 
 pub fn br_md5_state ( ctx : * const br_md5_context , out : * mut :: std :: os :: raw :: c_void , ) -> u64 ; 
} extern "C" {
 
 /// \brief Restore MD5 running state.
///
/// The running state for MD5 is set to the provided values.
///
/// \param ctx     pointer to the context structure.
/// \param stb     source buffer for the running state.
/// \param count   the injected total byte length. 
 
 pub fn br_md5_set_state ( ctx : * mut br_md5_context , stb : * const :: std :: os :: raw :: c_void , count : u64 , ) ; 
} extern "C" {
 # [ link_name = "\u{1}br_sha1_vtable" ] 
 pub static mut  br_sha1_vtable  :  br_hash_class ;
} 
 /// \brief SHA-1 context.
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_sha1_context { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_hash_class , pub buf : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub count : u64 , pub val : [ u32 ; 5usize ] , } # [ test ] fn bindgen_test_layout_br_sha1_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sha1_context > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( br_sha1_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sha1_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sha1_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha1_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sha1_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha1_context > ( ) ) ) . buf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sha1_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha1_context > ( ) ) ) . count as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_sha1_context ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha1_context > ( ) ) ) . val as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_sha1_context ) , "::" , stringify ! ( val ) ) ) ; } extern "C" {
 
 /// \brief SHA-1 context initialisation.
///
/// This function initialises or resets a context for a new SHA-1
/// computation. It also sets the vtable pointer.
///
/// \param ctx   pointer to the context structure. 
 
 pub fn br_sha1_init ( ctx : * mut br_sha1_context , ) ; 
} extern "C" {
 
 /// \brief Inject some data bytes in a running SHA-1 computation.
///
/// The provided context is updated with some data bytes. If the number
/// of bytes (`len`) is zero, then the data pointer (`data`) is ignored
/// and may be `NULL`, and this function does nothing.
///
/// \param ctx    pointer to the context structure.
/// \param data   pointer to the injected data.
/// \param len    injected data length (in bytes). 
 
 pub fn br_sha1_update ( ctx : * mut br_sha1_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute SHA-1 output.
///
/// The SHA-1 output for the concatenation of all bytes injected in the
/// provided context since the last initialisation or reset call, is
/// computed and written in the buffer pointed to by `out`. The context
/// itself is not modified, so extra bytes may be injected afterwards
/// to continue that computation.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the hash output. 
 
 pub fn br_sha1_out ( ctx : * const br_sha1_context , out : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Save SHA-1 running state.
///
/// The running state for SHA-1 (output of the last internal block
/// processing) is written in the buffer pointed to by `out`. The
/// number of bytes injected since the last initialisation or reset
/// call is returned. The context is not modified.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the running state.
/// \return  the injected total byte length. 
 
 pub fn br_sha1_state ( ctx : * const br_sha1_context , out : * mut :: std :: os :: raw :: c_void , ) -> u64 ; 
} extern "C" {
 
 /// \brief Restore SHA-1 running state.
///
/// The running state for SHA-1 is set to the provided values.
///
/// \param ctx     pointer to the context structure.
/// \param stb     source buffer for the running state.
/// \param count   the injected total byte length. 
 
 pub fn br_sha1_set_state ( ctx : * mut br_sha1_context , stb : * const :: std :: os :: raw :: c_void , count : u64 , ) ; 
} extern "C" {
 # [ link_name = "\u{1}br_sha224_vtable" ] 
 pub static mut  br_sha224_vtable  :  br_hash_class ;
} 
 /// \brief SHA-224 context.
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_sha224_context { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_hash_class , pub buf : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub count : u64 , pub val : [ u32 ; 8usize ] , } # [ test ] fn bindgen_test_layout_br_sha224_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sha224_context > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( br_sha224_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sha224_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sha224_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha224_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sha224_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha224_context > ( ) ) ) . buf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sha224_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha224_context > ( ) ) ) . count as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_sha224_context ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha224_context > ( ) ) ) . val as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_sha224_context ) , "::" , stringify ! ( val ) ) ) ; } extern "C" {
 
 /// \brief SHA-224 context initialisation.
///
/// This function initialises or resets a context for a new SHA-224
/// computation. It also sets the vtable pointer.
///
/// \param ctx   pointer to the context structure. 
 
 pub fn br_sha224_init ( ctx : * mut br_sha224_context , ) ; 
} extern "C" {
 
 /// \brief Inject some data bytes in a running SHA-224 computation.
///
/// The provided context is updated with some data bytes. If the number
/// of bytes (`len`) is zero, then the data pointer (`data`) is ignored
/// and may be `NULL`, and this function does nothing.
///
/// \param ctx    pointer to the context structure.
/// \param data   pointer to the injected data.
/// \param len    injected data length (in bytes). 
 
 pub fn br_sha224_update ( ctx : * mut br_sha224_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute SHA-224 output.
///
/// The SHA-224 output for the concatenation of all bytes injected in the
/// provided context since the last initialisation or reset call, is
/// computed and written in the buffer pointed to by `out`. The context
/// itself is not modified, so extra bytes may be injected afterwards
/// to continue that computation.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the hash output. 
 
 pub fn br_sha224_out ( ctx : * const br_sha224_context , out : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Save SHA-224 running state.
///
/// The running state for SHA-224 (output of the last internal block
/// processing) is written in the buffer pointed to by `out`. The
/// number of bytes injected since the last initialisation or reset
/// call is returned. The context is not modified.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the running state.
/// \return  the injected total byte length. 
 
 pub fn br_sha224_state ( ctx : * const br_sha224_context , out : * mut :: std :: os :: raw :: c_void , ) -> u64 ; 
} extern "C" {
 
 /// \brief Restore SHA-224 running state.
///
/// The running state for SHA-224 is set to the provided values.
///
/// \param ctx     pointer to the context structure.
/// \param stb     source buffer for the running state.
/// \param count   the injected total byte length. 
 
 pub fn br_sha224_set_state ( ctx : * mut br_sha224_context , stb : * const :: std :: os :: raw :: c_void , count : u64 , ) ; 
} extern "C" {
 # [ link_name = "\u{1}br_sha256_vtable" ] 
 pub static mut  br_sha256_vtable  :  br_hash_class ;
} pub type br_sha256_context = br_sha224_context ; extern "C" {
 
 /// \brief SHA-256 context initialisation.
///
/// This function initialises or resets a context for a new SHA-256
/// computation. It also sets the vtable pointer.
///
/// \param ctx   pointer to the context structure. 
 
 pub fn br_sha256_init ( ctx : * mut br_sha256_context , ) ; 
} extern "C" {
 
 /// \brief Compute SHA-256 output.
///
/// The SHA-256 output for the concatenation of all bytes injected in the
/// provided context since the last initialisation or reset call, is
/// computed and written in the buffer pointed to by `out`. The context
/// itself is not modified, so extra bytes may be injected afterwards
/// to continue that computation.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the hash output. 
 
 pub fn br_sha256_out ( ctx : * const br_sha256_context , out : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 # [ link_name = "\u{1}br_sha384_vtable" ] 
 pub static mut  br_sha384_vtable  :  br_hash_class ;
} 
 /// \brief SHA-384 context.
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_sha384_context { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_hash_class , pub buf : [ :: std :: os :: raw :: c_uchar ; 128usize ] , pub count : u64 , pub val : [ u64 ; 8usize ] , } # [ test ] fn bindgen_test_layout_br_sha384_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sha384_context > ( ) , 208usize , concat ! ( "Size of: " , stringify ! ( br_sha384_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sha384_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sha384_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha384_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sha384_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha384_context > ( ) ) ) . buf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sha384_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha384_context > ( ) ) ) . count as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( br_sha384_context ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sha384_context > ( ) ) ) . val as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( br_sha384_context ) , "::" , stringify ! ( val ) ) ) ; } extern "C" {
 
 /// \brief SHA-384 context initialisation.
///
/// This function initialises or resets a context for a new SHA-384
/// computation. It also sets the vtable pointer.
///
/// \param ctx   pointer to the context structure. 
 
 pub fn br_sha384_init ( ctx : * mut br_sha384_context , ) ; 
} extern "C" {
 
 /// \brief Inject some data bytes in a running SHA-384 computation.
///
/// The provided context is updated with some data bytes. If the number
/// of bytes (`len`) is zero, then the data pointer (`data`) is ignored
/// and may be `NULL`, and this function does nothing.
///
/// \param ctx    pointer to the context structure.
/// \param data   pointer to the injected data.
/// \param len    injected data length (in bytes). 
 
 pub fn br_sha384_update ( ctx : * mut br_sha384_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute SHA-384 output.
///
/// The SHA-384 output for the concatenation of all bytes injected in the
/// provided context since the last initialisation or reset call, is
/// computed and written in the buffer pointed to by `out`. The context
/// itself is not modified, so extra bytes may be injected afterwards
/// to continue that computation.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the hash output. 
 
 pub fn br_sha384_out ( ctx : * const br_sha384_context , out : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Save SHA-384 running state.
///
/// The running state for SHA-384 (output of the last internal block
/// processing) is written in the buffer pointed to by `out`. The
/// number of bytes injected since the last initialisation or reset
/// call is returned. The context is not modified.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the running state.
/// \return  the injected total byte length. 
 
 pub fn br_sha384_state ( ctx : * const br_sha384_context , out : * mut :: std :: os :: raw :: c_void , ) -> u64 ; 
} extern "C" {
 
 /// \brief Restore SHA-384 running state.
///
/// The running state for SHA-384 is set to the provided values.
///
/// \param ctx     pointer to the context structure.
/// \param stb     source buffer for the running state.
/// \param count   the injected total byte length. 
 
 pub fn br_sha384_set_state ( ctx : * mut br_sha384_context , stb : * const :: std :: os :: raw :: c_void , count : u64 , ) ; 
} extern "C" {
 # [ link_name = "\u{1}br_sha512_vtable" ] 
 pub static mut  br_sha512_vtable  :  br_hash_class ;
} pub type br_sha512_context = br_sha384_context ; extern "C" {
 
 /// \brief SHA-512 context initialisation.
///
/// This function initialises or resets a context for a new SHA-512
/// computation. It also sets the vtable pointer.
///
/// \param ctx   pointer to the context structure. 
 
 pub fn br_sha512_init ( ctx : * mut br_sha512_context , ) ; 
} extern "C" {
 
 /// \brief Compute SHA-512 output.
///
/// The SHA-512 output for the concatenation of all bytes injected in the
/// provided context since the last initialisation or reset call, is
/// computed and written in the buffer pointed to by `out`. The context
/// itself is not modified, so extra bytes may be injected afterwards
/// to continue that computation.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the hash output. 
 
 pub fn br_sha512_out ( ctx : * const br_sha512_context , out : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 # [ link_name = "\u{1}br_md5sha1_vtable" ] 
 pub static mut  br_md5sha1_vtable  :  br_hash_class ;
} 
 /// \brief MD5+SHA-1 context.
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_md5sha1_context { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_hash_class , pub buf : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub count : u64 , pub val_md5 : [ u32 ; 4usize ] , pub val_sha1 : [ u32 ; 5usize ] , } # [ test ] fn bindgen_test_layout_br_md5sha1_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_md5sha1_context > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( br_md5sha1_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_md5sha1_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_md5sha1_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5sha1_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_md5sha1_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5sha1_context > ( ) ) ) . buf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_md5sha1_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5sha1_context > ( ) ) ) . count as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_md5sha1_context ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5sha1_context > ( ) ) ) . val_md5 as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_md5sha1_context ) , "::" , stringify ! ( val_md5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_md5sha1_context > ( ) ) ) . val_sha1 as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( br_md5sha1_context ) , "::" , stringify ! ( val_sha1 ) ) ) ; } extern "C" {
 
 /// \brief MD5+SHA-1 context initialisation.
///
/// This function initialises or resets a context for a new SHA-512
/// computation. It also sets the vtable pointer.
///
/// \param ctx   pointer to the context structure. 
 
 pub fn br_md5sha1_init ( ctx : * mut br_md5sha1_context , ) ; 
} extern "C" {
 
 /// \brief Inject some data bytes in a running MD5+SHA-1 computation.
///
/// The provided context is updated with some data bytes. If the number
/// of bytes (`len`) is zero, then the data pointer (`data`) is ignored
/// and may be `NULL`, and this function does nothing.
///
/// \param ctx    pointer to the context structure.
/// \param data   pointer to the injected data.
/// \param len    injected data length (in bytes). 
 
 pub fn br_md5sha1_update ( ctx : * mut br_md5sha1_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute MD5+SHA-1 output.
///
/// The MD5+SHA-1 output for the concatenation of all bytes injected in the
/// provided context since the last initialisation or reset call, is
/// computed and written in the buffer pointed to by `out`. The context
/// itself is not modified, so extra bytes may be injected afterwards
/// to continue that computation.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the hash output. 
 
 pub fn br_md5sha1_out ( ctx : * const br_md5sha1_context , out : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Save MD5+SHA-1 running state.
///
/// The running state for MD5+SHA-1 (output of the last internal block
/// processing) is written in the buffer pointed to by `out`. The
/// number of bytes injected since the last initialisation or reset
/// call is returned. The context is not modified.
///
/// \param ctx   pointer to the context structure.
/// \param out   destination buffer for the running state.
/// \return  the injected total byte length. 
 
 pub fn br_md5sha1_state ( ctx : * const br_md5sha1_context , out : * mut :: std :: os :: raw :: c_void , ) -> u64 ; 
} extern "C" {
 
 /// \brief Restore MD5+SHA-1 running state.
///
/// The running state for MD5+SHA-1 is set to the provided values.
///
/// \param ctx     pointer to the context structure.
/// \param stb     source buffer for the running state.
/// \param count   the injected total byte length. 
 
 pub fn br_md5sha1_set_state ( ctx : * mut br_md5sha1_context , stb : * const :: std :: os :: raw :: c_void , count : u64 , ) ; 
} 
 /// \brief Aggregate context for configurable hash function support.
///
/// The `br_hash_compat_context` type is a type which is large enough to
/// serve as context for all standard hash functions defined above. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_hash_compat_context { pub vtable : * const br_hash_class , pub md5 : br_md5_context , pub sha1 : br_sha1_context , pub sha224 : br_sha224_context , pub sha256 : br_sha256_context , pub sha384 : br_sha384_context , pub sha512 : br_sha512_context , pub md5sha1 : br_md5sha1_context , _bindgen_union_align : [ u64 ; 26usize ] , } # [ test ] fn bindgen_test_layout_br_hash_compat_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_hash_compat_context > ( ) , 208usize , concat ! ( "Size of: " , stringify ! ( br_hash_compat_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_hash_compat_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_hash_compat_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_compat_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_compat_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_compat_context > ( ) ) ) . md5 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_compat_context ) , "::" , stringify ! ( md5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_compat_context > ( ) ) ) . sha1 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_compat_context ) , "::" , stringify ! ( sha1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_compat_context > ( ) ) ) . sha224 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_compat_context ) , "::" , stringify ! ( sha224 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_compat_context > ( ) ) ) . sha256 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_compat_context ) , "::" , stringify ! ( sha256 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_compat_context > ( ) ) ) . sha384 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_compat_context ) , "::" , stringify ! ( sha384 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_compat_context > ( ) ) ) . sha512 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_compat_context ) , "::" , stringify ! ( sha512 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hash_compat_context > ( ) ) ) . md5sha1 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hash_compat_context ) , "::" , stringify ! ( md5sha1 ) ) ) ; } 
 /// \brief Multi-hasher context structure.
///
/// The multi-hasher runs up to six hash functions in the standard TLS list
/// (MD5, SHA-1, SHA-224, SHA-256, SHA-384 and SHA-512) in parallel, over
/// the same input.
///
/// The multi-hasher does _not_ follow the OOP structure with a vtable.
/// Instead, it is configured with the vtables of the hash functions it
/// should run. Structure fields are not supposed to be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_multihash_context { pub buf : [ :: std :: os :: raw :: c_uchar ; 128usize ] , pub count : u64 , pub val_32 : [ u32 ; 25usize ] , pub val_64 : [ u64 ; 16usize ] , pub impl_ : [ * const br_hash_class ; 6usize ] , } # [ test ] fn bindgen_test_layout_br_multihash_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_multihash_context > ( ) , 416usize , concat ! ( "Size of: " , stringify ! ( br_multihash_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_multihash_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_multihash_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_multihash_context > ( ) ) ) . buf as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_multihash_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_multihash_context > ( ) ) ) . count as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( br_multihash_context ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_multihash_context > ( ) ) ) . val_32 as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( br_multihash_context ) , "::" , stringify ! ( val_32 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_multihash_context > ( ) ) ) . val_64 as * const _ as usize } , 240usize , concat ! ( "Offset of field: " , stringify ! ( br_multihash_context ) , "::" , stringify ! ( val_64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_multihash_context > ( ) ) ) . impl_ as * const _ as usize } , 368usize , concat ! ( "Offset of field: " , stringify ! ( br_multihash_context ) , "::" , stringify ! ( impl_ ) ) ) ; } extern "C" {
 
 /// \brief Clear a multi-hasher context.
///
/// This should always be called once on a given context, _before_ setting
/// the implementation pointers.
///
/// \param ctx   the multi-hasher context. 
 
 pub fn br_multihash_zero ( ctx : * mut br_multihash_context , ) ; 
} extern "C" {
 
 /// \brief Reset a multi-hasher context.
///
/// This function prepares the context for a new hashing computation,
/// for all implementations configured at that point.
///
/// \param ctx    the multi-hasher context. 
 
 pub fn br_multihash_init ( ctx : * mut br_multihash_context , ) ; 
} extern "C" {
 
 /// \brief Inject some data bytes in a running multi-hashing computation.
///
/// The provided context is updated with some data bytes. If the number
/// of bytes (`len`) is zero, then the data pointer (`data`) is ignored
/// and may be `NULL`, and this function does nothing.
///
/// \param ctx    pointer to the context structure.
/// \param data   pointer to the injected data.
/// \param len    injected data length (in bytes). 
 
 pub fn br_multihash_update ( ctx : * mut br_multihash_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute a hash output from a multi-hasher.
///
/// The hash output for the concatenation of all bytes injected in the
/// provided context since the last initialisation or reset call, is
/// computed and written in the buffer pointed to by `dst`. The hash
/// function to use is identified by `id` and must be one of the standard
/// hash functions. If that hash function was indeed configured in the
/// multi-hasher context, the corresponding hash value is written in
/// `dst` and its length (in bytes) is returned. If the hash function
/// was _not_ configured, then nothing is written in `dst` and 0 is
/// returned.
///
/// The context itself is not modified, so extra bytes may be injected
/// afterwards to continue the hash computations.
///
/// \param ctx   pointer to the context structure.
/// \param id    the hash function symbolic identifier.
/// \param dst   destination buffer for the hash output.
/// \return  the hash output length (in bytes), or 0. 
 
 pub fn br_multihash_out ( ctx : * const br_multihash_context , id : :: std :: os :: raw :: c_int , dst : * mut :: std :: os :: raw :: c_void , ) -> usize ; 
} 
 /// \brief Type for a GHASH implementation.
///
/// GHASH is a sort of keyed hash meant to be used to implement GCM in
/// combination with a block cipher (with 16-byte blocks).
///
/// The `y` array has length 16 bytes and is used for input and output; in
/// a complete GHASH run, it starts with an all-zero value. `h` is a 16-byte
/// value that serves as key (it is derived from the encryption key in GCM,
/// using the block cipher). The data length (`len`) is expressed in bytes.
/// The `y` array is updated.
///
/// If the data length is not a multiple of 16, then the data is implicitly
/// padded with zeros up to the next multiple of 16. Thus, when using GHASH
/// in GCM, this method may be called twice, for the associated data and
/// for the ciphertext, respectively; the zero-padding implements exactly
/// the GCM rules.
///
/// \param y      the array to update.
/// \param h      the GHASH key.
/// \param data   the input data (may be `NULL` if `len` is zero).
/// \param len    the input data length (in bytes). 
 pub type br_ghash = :: std :: option :: Option < unsafe extern "C" fn ( y : * mut :: std :: os :: raw :: c_void , h : * const :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize ) > ; extern "C" {
 
 /// \brief GHASH implementation using multiplications (mixed 32-bit).
///
/// This implementation uses multiplications of 32-bit values, with a
/// 64-bit result. It is constant-time (if multiplications are
/// constant-time).
///
/// \param y      the array to update.
/// \param h      the GHASH key.
/// \param data   the input data (may be `NULL` if `len` is zero).
/// \param len    the input data length (in bytes). 
 
 pub fn br_ghash_ctmul ( y : * mut :: std :: os :: raw :: c_void , h : * const :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief GHASH implementation using multiplications (strict 32-bit).
///
/// This implementation uses multiplications of 32-bit values, with a
/// 32-bit result. It is usually somewhat slower than `br_ghash_ctmul()`,
/// but it is expected to be faster on architectures for which the
/// 32-bit multiplication opcode does not yield the upper 32 bits of the
/// product. It is constant-time (if multiplications are constant-time).
///
/// \param y      the array to update.
/// \param h      the GHASH key.
/// \param data   the input data (may be `NULL` if `len` is zero).
/// \param len    the input data length (in bytes). 
 
 pub fn br_ghash_ctmul32 ( y : * mut :: std :: os :: raw :: c_void , h : * const :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief GHASH implementation using multiplications (64-bit).
///
/// This implementation uses multiplications of 64-bit values, with a
/// 64-bit result. It is constant-time (if multiplications are
/// constant-time). It is substantially faster than `br_ghash_ctmul()`
/// and `br_ghash_ctmul32()` on most 64-bit architectures.
///
/// \param y      the array to update.
/// \param h      the GHASH key.
/// \param data   the input data (may be `NULL` if `len` is zero).
/// \param len    the input data length (in bytes). 
 
 pub fn br_ghash_ctmul64 ( y : * mut :: std :: os :: raw :: c_void , h : * const :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief GHASH implementation using the `pclmulqdq` opcode (part of the
/// AES-NI instructions).
///
/// This implementation is available only on x86 platforms where the
/// compiler supports the relevant intrinsic functions. Even if the
/// compiler supports these functions, the local CPU might not support
/// the `pclmulqdq` opcode, meaning that a call will fail with an
/// illegal instruction exception. To safely obtain a pointer to this
/// function when supported (or 0 otherwise), use `br_ghash_pclmul_get()`.
///
/// \param y      the array to update.
/// \param h      the GHASH key.
/// \param data   the input data (may be `NULL` if `len` is zero).
/// \param len    the input data length (in bytes). 
 
 pub fn br_ghash_pclmul ( y : * mut :: std :: os :: raw :: c_void , h : * const :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Obtain the `pclmul` GHASH implementation, if available.
///
/// If the `pclmul` implementation was compiled in the library (depending
/// on the compiler abilities) _and_ the local CPU appears to support the
/// opcode, then this function will return a pointer to the
/// `br_ghash_pclmul()` function. Otherwise, it will return `0`.
///
/// \return  the `pclmul` GHASH implementation, or `0`. 
 
 pub fn br_ghash_pclmul_get ( ) -> br_ghash ; 
} extern "C" {
 
 /// \brief GHASH implementation using the POWER8 opcodes.
///
/// This implementation is available only on POWER8 platforms (and later).
/// To safely obtain a pointer to this function when supported (or 0
/// otherwise), use `br_ghash_pwr8_get()`.
///
/// \param y      the array to update.
/// \param h      the GHASH key.
/// \param data   the input data (may be `NULL` if `len` is zero).
/// \param len    the input data length (in bytes). 
 
 pub fn br_ghash_pwr8 ( y : * mut :: std :: os :: raw :: c_void , h : * const :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Obtain the `pwr8` GHASH implementation, if available.
///
/// If the `pwr8` implementation was compiled in the library (depending
/// on the compiler abilities) _and_ the local CPU appears to support the
/// opcode, then this function will return a pointer to the
/// `br_ghash_pwr8()` function. Otherwise, it will return `0`.
///
/// \return  the `pwr8` GHASH implementation, or `0`. 
 
 pub fn br_ghash_pwr8_get ( ) -> br_ghash ; 
} 
 /// \brief HMAC key context.
///
/// The HMAC key context is initialised with a hash function implementation
/// and a secret key. Contents are opaque (callers should not access them
/// directly). The caller is responsible for allocating the context where
/// appropriate. Context initialisation and usage incurs no dynamic
/// allocation, so there is no release function. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_hmac_key_context { pub dig_vtable : * const br_hash_class , pub ksi : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub kso : [ :: std :: os :: raw :: c_uchar ; 64usize ] , } # [ test ] fn bindgen_test_layout_br_hmac_key_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_hmac_key_context > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( br_hmac_key_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_hmac_key_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_hmac_key_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_key_context > ( ) ) ) . dig_vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_key_context ) , "::" , stringify ! ( dig_vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_key_context > ( ) ) ) . ksi as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_key_context ) , "::" , stringify ! ( ksi ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_key_context > ( ) ) ) . kso as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_key_context ) , "::" , stringify ! ( kso ) ) ) ; } extern "C" {
 
 /// \brief HMAC key context initialisation.
///
/// Initialise the key context with the provided key, using the hash function
/// identified by `digest_vtable`. This supports arbitrary key lengths.
///
/// \param kc              HMAC key context to initialise.
/// \param digest_vtable   pointer to the hash function implementation vtable.
/// \param key             pointer to the HMAC secret key.
/// \param key_len         HMAC secret key length (in bytes). 
 
 pub fn br_hmac_key_init ( kc : * mut br_hmac_key_context , digest_vtable : * const br_hash_class , key : * const :: std :: os :: raw :: c_void , key_len : usize , ) ; 
} 
 /// \brief HMAC computation context.
///
/// The HMAC computation context maintains the state for a single HMAC
/// computation. It is modified as input bytes are injected. The context
/// is caller-allocated and has no release function since it does not
/// dynamically allocate external resources. Its contents are opaque. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_hmac_context { pub dig : br_hash_compat_context , pub kso : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub out_len : usize , } # [ test ] fn bindgen_test_layout_br_hmac_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_hmac_context > ( ) , 280usize , concat ! ( "Size of: " , stringify ! ( br_hmac_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_hmac_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_hmac_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_context > ( ) ) ) . dig as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_context ) , "::" , stringify ! ( dig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_context > ( ) ) ) . kso as * const _ as usize } , 208usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_context ) , "::" , stringify ! ( kso ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_context > ( ) ) ) . out_len as * const _ as usize } , 272usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_context ) , "::" , stringify ! ( out_len ) ) ) ; } extern "C" {
 
 /// \brief HMAC computation initialisation.
///
/// Initialise a HMAC context with a key context. The key context is
/// unmodified. Relevant data from the key context is immediately copied;
/// the key context can thus be independently reused, modified or released
/// without impacting this HMAC computation.
///
/// An explicit output length can be specified; the actual output length
/// will be the minimum of that value and the natural HMAC output length.
/// If `out_len` is 0, then the natural HMAC output length is selected. The
/// "natural output length" is the output length of the underlying hash
/// function.
///
/// \param ctx       HMAC context to initialise.
/// \param kc        HMAC key context (already initialised with the key).
/// \param out_len   HMAC output length (0 to select "natural length"). 
 
 pub fn br_hmac_init ( ctx : * mut br_hmac_context , kc : * const br_hmac_key_context , out_len : usize , ) ; 
} extern "C" {
 
 /// \brief Inject some bytes in HMAC.
///
/// The provided `len` bytes are injected as extra input in the HMAC
/// computation incarnated by the `ctx` HMAC context. It is acceptable
/// that `len` is zero, in which case `data` is ignored (and may be
/// `NULL`) and this function does nothing. 
 
 pub fn br_hmac_update ( ctx : * mut br_hmac_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute the HMAC output.
///
/// The destination buffer MUST be large enough to accomodate the result;
/// its length is at most the "natural length" of HMAC (i.e. the output
/// length of the underlying hash function). The context is NOT modified;
/// further bytes may be processed. Thus, "partial HMAC" values can be
/// efficiently obtained.
///
/// Returned value is the output length (in bytes).
///
/// \param ctx   HMAC computation context.
/// \param out   destination buffer for the HMAC output.
/// \return  the produced value length (in bytes). 
 
 pub fn br_hmac_out ( ctx : * const br_hmac_context , out : * mut :: std :: os :: raw :: c_void , ) -> usize ; 
} extern "C" {
 
 /// \brief Constant-time HMAC computation.
///
/// This function compute the HMAC output in constant time. Some extra
/// input bytes are processed, then the output is computed. The extra
/// input consists in the `len` bytes pointed to by `data`. The `len`
/// parameter must lie between `min_len` and `max_len` (inclusive);
/// `max_len` bytes are actually read from `data`. Computing time (and
/// memory access pattern) will not depend upon the data byte contents or
/// the value of `len`.
///
/// The output is written in the `out` buffer, that MUST be large enough
/// to receive it.
///
/// The difference `max_len - min_len` MUST be less than 2<sup>30</sup>
/// (i.e. about one gigabyte).
///
/// This function computes the output properly only if the underlying
/// hash function uses MD padding (i.e. MD5, SHA-1, SHA-224, SHA-256,
/// SHA-384 or SHA-512).
///
/// The provided context is NOT modified.
///
/// \param ctx       the (already initialised) HMAC computation context.
/// \param data      the extra input bytes.
/// \param len       the extra input length (in bytes).
/// \param min_len   minimum extra input length (in bytes).
/// \param max_len   maximum extra input length (in bytes).
/// \param out       destination buffer for the HMAC output.
/// \return  the produced value length (in bytes). 
 
 pub fn br_hmac_outCT ( ctx : * const br_hmac_context , data : * const :: std :: os :: raw :: c_void , len : usize , min_len : usize , max_len : usize , out : * mut :: std :: os :: raw :: c_void , ) -> usize ; 
} 
 /// \brief Class type for PRNG implementations.
///
/// A `br_prng_class` instance references the methods implementing a PRNG.
/// Constant instances of this structure are defined for each implemented
/// PRNG. Such instances are also called "vtables". 
 pub type br_prng_class = br_prng_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_prng_class_ { 
 /// \brief Size (in bytes) of the context structure appropriate for
    /// running this PRNG. 
 pub context_size : usize , 
 /// \brief Initialisation method.
    ///
    /// The context to initialise is provided as a pointer to its
    /// first field (the vtable pointer); this function sets that
    /// first field to a pointer to the vtable.
    ///
    /// The extra parameters depend on the implementation; each
    /// implementation defines what kind of extra parameters it
    /// expects (if any).
    ///
    /// Requirements on the initial seed depend on the implemented
    /// PRNG.
    ///
    /// \param ctx        PRNG context to initialise.
    /// \param params     extra parameters for the PRNG.
    /// \param seed       initial seed.
    /// \param seed_len   initial seed length (in bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_prng_class , params : * const :: std :: os :: raw :: c_void , seed : * const :: std :: os :: raw :: c_void , seed_len : usize ) > , 
 /// \brief Random bytes generation.
    ///
    /// This method produces `len` pseudorandom bytes, in the `out`
    /// buffer. The context is updated accordingly.
    ///
    /// \param ctx   PRNG context.
    /// \param out   output buffer.
    /// \param len   number of pseudorandom bytes to produce. 
 pub generate : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_prng_class , out : * mut :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Inject additional seed bytes.
    ///
    /// The provided seed bytes are added into the PRNG internal
    /// entropy pool.
    ///
    /// \param ctx        PRNG context.
    /// \param seed       additional seed.
    /// \param seed_len   additional seed length (in bytes). 
 pub update : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_prng_class , seed : * const :: std :: os :: raw :: c_void , seed_len : usize ) > , } # [ test ] fn bindgen_test_layout_br_prng_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_prng_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_prng_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_prng_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_prng_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_prng_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_prng_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_prng_class_ > ( ) ) ) . init as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_prng_class_ ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_prng_class_ > ( ) ) ) . generate as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_prng_class_ ) , "::" , stringify ! ( generate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_prng_class_ > ( ) ) ) . update as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_prng_class_ ) , "::" , stringify ! ( update ) ) ) ; } 
 /// \brief Context for HMAC_DRBG.
///
/// The context contents are opaque, except the first field, which
/// supports OOP. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_hmac_drbg_context { 
 /// \brief Pointer to the vtable.
    ///
    /// This field is set with the initialisation method/function. 
 pub vtable : * const br_prng_class , pub K : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub V : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub digest_class : * const br_hash_class , } # [ test ] fn bindgen_test_layout_br_hmac_drbg_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_hmac_drbg_context > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( br_hmac_drbg_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_hmac_drbg_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_hmac_drbg_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_drbg_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_drbg_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_drbg_context > ( ) ) ) . K as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_drbg_context ) , "::" , stringify ! ( K ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_drbg_context > ( ) ) ) . V as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_drbg_context ) , "::" , stringify ! ( V ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_hmac_drbg_context > ( ) ) ) . digest_class as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( br_hmac_drbg_context ) , "::" , stringify ! ( digest_class ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_hmac_drbg_vtable" ] 
 pub static mut  br_hmac_drbg_vtable  :  br_prng_class ;
} extern "C" {
 
 /// \brief HMAC_DRBG initialisation.
///
/// The context to initialise is provided as a pointer to its first field
/// (the vtable pointer); this function sets that first field to a
/// pointer to the vtable.
///
/// The `seed` value is what is called, in NIST terminology, the
/// concatenation of the "seed", "nonce" and "personalization string", in
/// that order.
///
/// The `digest_class` parameter defines the underlying hash function.
/// Formally, the NIST standard specifies that the hash function shall
/// be only SHA-1 or one of the SHA-2 functions. This implementation also
/// works with any other implemented hash function (such as MD5), but
/// this is non-standard and therefore not recommended.
///
/// \param ctx            HMAC_DRBG context to initialise.
/// \param digest_class   vtable for the underlying hash function.
/// \param seed           initial seed.
/// \param seed_len       initial seed length (in bytes). 
 
 pub fn br_hmac_drbg_init ( ctx : * mut br_hmac_drbg_context , digest_class : * const br_hash_class , seed : * const :: std :: os :: raw :: c_void , seed_len : usize , ) ; 
} extern "C" {
 
 /// \brief Random bytes generation with HMAC_DRBG.
///
/// This method produces `len` pseudorandom bytes, in the `out`
/// buffer. The context is updated accordingly. Formally, requesting
/// more than 65536 bytes in one request falls out of specification
/// limits (but it won't fail).
///
/// \param ctx   HMAC_DRBG context.
/// \param out   output buffer.
/// \param len   number of pseudorandom bytes to produce. 
 
 pub fn br_hmac_drbg_generate ( ctx : * mut br_hmac_drbg_context , out : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Inject additional seed bytes in HMAC_DRBG.
///
/// The provided seed bytes are added into the HMAC_DRBG internal
/// entropy pool. The process does not _replace_ existing entropy,
/// thus pushing non-random bytes (i.e. bytes which are known to the
/// attackers) does not degrade the overall quality of generated bytes.
///
/// \param ctx        HMAC_DRBG context.
/// \param seed       additional seed.
/// \param seed_len   additional seed length (in bytes). 
 
 pub fn br_hmac_drbg_update ( ctx : * mut br_hmac_drbg_context , seed : * const :: std :: os :: raw :: c_void , seed_len : usize , ) ; 
} 
 /// \brief Type for a provider of entropy seeds.
///
/// A "seeder" is a function that is able to obtain random values from
/// some source and inject them as entropy seed in a PRNG. A seeder
/// shall guarantee that the total entropy of the injected seed is large
/// enough to seed a PRNG for purposes of cryptographic key generation
/// (i.e. at least 128 bits).
///
/// A seeder may report a failure to obtain adequate entropy. Seeders
/// shall endeavour to fix themselves transient errors by trying again;
/// thus, callers may consider reported errors as permanent.
///
/// \param ctx   PRNG context to seed.
/// \return  1 on success, 0 on error. 
 pub type br_prng_seeder = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_prng_class ) -> :: std :: os :: raw :: c_int > ; extern "C" {
 
 /// \brief Get a seeder backed by the operating system or hardware.
///
/// Get a seeder that feeds on RNG facilities provided by the current
/// operating system or hardware. If no such facility is known, then 0
/// is returned.
///
/// If `name` is not `NULL`, then `*name` is set to a symbolic string
/// that identifies the seeder implemention. If no seeder is returned
/// and `name` is not `NULL`, then `*name` is set to a pointer to the
/// constant string `"none"`.
///
/// \param name   receiver for seeder name, or `NULL`.
/// \return  the system seeder, if available, or 0. 
 
 pub fn br_prng_seeder_system ( name : * mut * const :: std :: os :: raw :: c_char , ) -> br_prng_seeder ; 
} 
 /// \brief Type for a seed chunk.
///
/// Each chunk may have an arbitrary length, and may be empty (no byte at
/// all). If the chunk length is zero, then the pointer to the chunk data
/// may be `NULL`. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_tls_prf_seed_chunk { 
 /// \brief Pointer to the chunk data. 
 pub data : * const :: std :: os :: raw :: c_void , 
 /// \brief Chunk length (in bytes). 
 pub len : usize , } # [ test ] fn bindgen_test_layout_br_tls_prf_seed_chunk ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_tls_prf_seed_chunk > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( br_tls_prf_seed_chunk ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_tls_prf_seed_chunk > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_tls_prf_seed_chunk ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_tls_prf_seed_chunk > ( ) ) ) . data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_tls_prf_seed_chunk ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_tls_prf_seed_chunk > ( ) ) ) . len as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_tls_prf_seed_chunk ) , "::" , stringify ! ( len ) ) ) ; } extern "C" {
 
 /// \brief PRF implementation for TLS 1.0 and 1.1.
///
/// This PRF is the one specified by TLS 1.0 and 1.1. It internally uses
/// MD5 and SHA-1.
///
/// \param dst          destination buffer.
/// \param len          output length (in bytes).
/// \param secret       secret value (key) for this computation.
/// \param secret_len   length of "secret" (in bytes).
/// \param label        PRF label (zero-terminated ASCII string).
/// \param seed_num     number of seed chunks.
/// \param seed         seed chnks for this computation (usually non-secret). 
 
 pub fn br_tls10_prf ( dst : * mut :: std :: os :: raw :: c_void , len : usize , secret : * const :: std :: os :: raw :: c_void , secret_len : usize , label : * const :: std :: os :: raw :: c_char , seed_num : usize , seed : * const br_tls_prf_seed_chunk , ) ; 
} extern "C" {
 
 /// \brief PRF implementation for TLS 1.2, with SHA-256.
///
/// This PRF is the one specified by TLS 1.2, when the underlying hash
/// function is SHA-256.
///
/// \param dst          destination buffer.
/// \param len          output length (in bytes).
/// \param secret       secret value (key) for this computation.
/// \param secret_len   length of "secret" (in bytes).
/// \param label        PRF label (zero-terminated ASCII string).
/// \param seed_num     number of seed chunks.
/// \param seed         seed chnks for this computation (usually non-secret). 
 
 pub fn br_tls12_sha256_prf ( dst : * mut :: std :: os :: raw :: c_void , len : usize , secret : * const :: std :: os :: raw :: c_void , secret_len : usize , label : * const :: std :: os :: raw :: c_char , seed_num : usize , seed : * const br_tls_prf_seed_chunk , ) ; 
} extern "C" {
 
 /// \brief PRF implementation for TLS 1.2, with SHA-384.
///
/// This PRF is the one specified by TLS 1.2, when the underlying hash
/// function is SHA-384.
///
/// \param dst          destination buffer.
/// \param len          output length (in bytes).
/// \param secret       secret value (key) for this computation.
/// \param secret_len   length of "secret" (in bytes).
/// \param label        PRF label (zero-terminated ASCII string).
/// \param seed_num     number of seed chunks.
/// \param seed         seed chnks for this computation (usually non-secret). 
 
 pub fn br_tls12_sha384_prf ( dst : * mut :: std :: os :: raw :: c_void , len : usize , secret : * const :: std :: os :: raw :: c_void , secret_len : usize , label : * const :: std :: os :: raw :: c_char , seed_num : usize , seed : * const br_tls_prf_seed_chunk , ) ; 
} 
 /// brief A convenient type name for a PRF implementation.
///
/// \param dst          destination buffer.
/// \param len          output length (in bytes).
/// \param secret       secret value (key) for this computation.
/// \param secret_len   length of "secret" (in bytes).
/// \param label        PRF label (zero-terminated ASCII string).
/// \param seed_num     number of seed chunks.
/// \param seed         seed chnks for this computation (usually non-secret). 
 pub type br_tls_prf_impl = :: std :: option :: Option < unsafe extern "C" fn ( dst : * mut :: std :: os :: raw :: c_void , len : usize , secret : * const :: std :: os :: raw :: c_void , secret_len : usize , label : * const :: std :: os :: raw :: c_char , seed_num : usize , seed : * const br_tls_prf_seed_chunk ) > ; 
 /// \brief Class type for CBC encryption implementations.
///
/// A `br_block_cbcenc_class` instance points to the functions implementing
/// a specific block cipher, when used in CBC mode for encrypting data. 
 pub type br_block_cbcenc_class = br_block_cbcenc_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_block_cbcenc_class_ { 
 /// \brief Size (in bytes) of the context structure appropriate
    /// for containing subkeys. 
 pub context_size : usize , 
 /// \brief Size of individual blocks (in bytes). 
 pub block_size : :: std :: os :: raw :: c_uint , 
 /// \brief Base-2 logarithm of the size of individual blocks,
    /// expressed in bytes. 
 pub log_block_size : :: std :: os :: raw :: c_uint , 
 /// \brief Initialisation function.
    ///
    /// This function sets the `vtable` field in the context structure.
    /// The key length MUST be one of the key lengths supported by
    /// the implementation.
    ///
    /// \param ctx       context structure to initialise.
    /// \param key       secret key.
    /// \param key_len   key length (in bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_block_cbcenc_class , key : * const :: std :: os :: raw :: c_void , key_len : usize ) > , 
 /// \brief Run the CBC encryption.
    ///
    /// The `iv` parameter points to the IV for this run; it is
    /// updated with a copy of the last encrypted block. The data
    /// is encrypted "in place"; its length (`len`) MUST be a
    /// multiple of the block size.
    ///
    /// \param ctx    context structure (already initialised).
    /// \param iv     IV for CBC encryption (updated).
    /// \param data   data to encrypt.
    /// \param len    data length (in bytes, multiple of block size). 
 pub run : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_block_cbcenc_class , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize ) > , } # [ test ] fn bindgen_test_layout_br_block_cbcenc_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_block_cbcenc_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_block_cbcenc_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_block_cbcenc_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_block_cbcenc_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcenc_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcenc_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcenc_class_ > ( ) ) ) . block_size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcenc_class_ ) , "::" , stringify ! ( block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcenc_class_ > ( ) ) ) . log_block_size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcenc_class_ ) , "::" , stringify ! ( log_block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcenc_class_ > ( ) ) ) . init as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcenc_class_ ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcenc_class_ > ( ) ) ) . run as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcenc_class_ ) , "::" , stringify ! ( run ) ) ) ; } 
 /// \brief Class type for CBC decryption implementations.
///
/// A `br_block_cbcdec_class` instance points to the functions implementing
/// a specific block cipher, when used in CBC mode for decrypting data. 
 pub type br_block_cbcdec_class = br_block_cbcdec_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_block_cbcdec_class_ { 
 /// \brief Size (in bytes) of the context structure appropriate
    /// for containing subkeys. 
 pub context_size : usize , 
 /// \brief Size of individual blocks (in bytes). 
 pub block_size : :: std :: os :: raw :: c_uint , 
 /// \brief Base-2 logarithm of the size of individual blocks,
    /// expressed in bytes. 
 pub log_block_size : :: std :: os :: raw :: c_uint , 
 /// \brief Initialisation function.
    ///
    /// This function sets the `vtable` field in the context structure.
    /// The key length MUST be one of the key lengths supported by
    /// the implementation.
    ///
    /// \param ctx       context structure to initialise.
    /// \param key       secret key.
    /// \param key_len   key length (in bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_block_cbcdec_class , key : * const :: std :: os :: raw :: c_void , key_len : usize ) > , 
 /// \brief Run the CBC decryption.
    ///
    /// The `iv` parameter points to the IV for this run; it is
    /// updated with a copy of the last encrypted block. The data
    /// is decrypted "in place"; its length (`len`) MUST be a
    /// multiple of the block size.
    ///
    /// \param ctx    context structure (already initialised).
    /// \param iv     IV for CBC decryption (updated).
    /// \param data   data to decrypt.
    /// \param len    data length (in bytes, multiple of block size). 
 pub run : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_block_cbcdec_class , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize ) > , } # [ test ] fn bindgen_test_layout_br_block_cbcdec_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_block_cbcdec_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_block_cbcdec_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_block_cbcdec_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_block_cbcdec_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcdec_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcdec_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcdec_class_ > ( ) ) ) . block_size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcdec_class_ ) , "::" , stringify ! ( block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcdec_class_ > ( ) ) ) . log_block_size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcdec_class_ ) , "::" , stringify ! ( log_block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcdec_class_ > ( ) ) ) . init as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcdec_class_ ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_cbcdec_class_ > ( ) ) ) . run as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_block_cbcdec_class_ ) , "::" , stringify ! ( run ) ) ) ; } 
 /// \brief Class type for CTR encryption/decryption implementations.
///
/// A `br_block_ctr_class` instance points to the functions implementing
/// a specific block cipher, when used in CTR mode for encrypting or
/// decrypting data. 
 pub type br_block_ctr_class = br_block_ctr_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_block_ctr_class_ { 
 /// \brief Size (in bytes) of the context structure appropriate
    /// for containing subkeys. 
 pub context_size : usize , 
 /// \brief Size of individual blocks (in bytes). 
 pub block_size : :: std :: os :: raw :: c_uint , 
 /// \brief Base-2 logarithm of the size of individual blocks,
    /// expressed in bytes. 
 pub log_block_size : :: std :: os :: raw :: c_uint , 
 /// \brief Initialisation function.
    ///
    /// This function sets the `vtable` field in the context structure.
    /// The key length MUST be one of the key lengths supported by
    /// the implementation.
    ///
    /// \param ctx       context structure to initialise.
    /// \param key       secret key.
    /// \param key_len   key length (in bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_block_ctr_class , key : * const :: std :: os :: raw :: c_void , key_len : usize ) > , 
 /// \brief Run the CTR encryption or decryption.
    ///
    /// The `iv` parameter points to the IV for this run; its
    /// length is exactly 4 bytes less than the block size (e.g.
    /// 12 bytes for AES/CTR). The IV is combined with a 32-bit
    /// block counter to produce the block value which is processed
    /// with the block cipher.
    ///
    /// The data to encrypt or decrypt is updated "in place". Its
    /// length (`len` bytes) is not required to be a multiple of
    /// the block size; if the final block is partial, then the
    /// corresponding key stream bits are dropped.
    ///
    /// The resulting counter value is returned.
    ///
    /// \param ctx    context structure (already initialised).
    /// \param iv     IV for CTR encryption/decryption.
    /// \param cc     initial value for the block counter.
    /// \param data   data to encrypt or decrypt.
    /// \param len    data length (in bytes).
    /// \return  the new block counter value. 
 pub run : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_block_ctr_class , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize ) -> u32 > , } # [ test ] fn bindgen_test_layout_br_block_ctr_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_block_ctr_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_block_ctr_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_block_ctr_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_block_ctr_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctr_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctr_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctr_class_ > ( ) ) ) . block_size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctr_class_ ) , "::" , stringify ! ( block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctr_class_ > ( ) ) ) . log_block_size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctr_class_ ) , "::" , stringify ! ( log_block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctr_class_ > ( ) ) ) . init as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctr_class_ ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctr_class_ > ( ) ) ) . run as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctr_class_ ) , "::" , stringify ! ( run ) ) ) ; } 
 /// \brief Class type for combined CTR and CBC-MAC implementations.
///
/// A `br_block_ctrcbc_class` instance points to the functions implementing
/// a specific block cipher, when used in CTR mode for encrypting or
/// decrypting data, along with CBC-MAC. 
 pub type br_block_ctrcbc_class = br_block_ctrcbc_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_block_ctrcbc_class_ { 
 /// \brief Size (in bytes) of the context structure appropriate
    /// for containing subkeys. 
 pub context_size : usize , 
 /// \brief Size of individual blocks (in bytes). 
 pub block_size : :: std :: os :: raw :: c_uint , 
 /// \brief Base-2 logarithm of the size of individual blocks,
    /// expressed in bytes. 
 pub log_block_size : :: std :: os :: raw :: c_uint , 
 /// \brief Initialisation function.
    ///
    /// This function sets the `vtable` field in the context structure.
    /// The key length MUST be one of the key lengths supported by
    /// the implementation.
    ///
    /// \param ctx       context structure to initialise.
    /// \param key       secret key.
    /// \param key_len   key length (in bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_block_ctrcbc_class , key : * const :: std :: os :: raw :: c_void , key_len : usize ) > , 
 /// \brief Run the CTR encryption + CBC-MAC.
    ///
    /// The `ctr` parameter points to the counter; its length shall
    /// be equal to the block size. It is updated by this function
    /// as encryption proceeds.
    ///
    /// The `cbcmac` parameter points to the IV for CBC-MAC. The MAC
    /// is computed over the encrypted data (output of CTR
    /// encryption). Its length shall be equal to the block size. The
    /// computed CBC-MAC value is written over the `cbcmac` array.
    ///
    /// The data to encrypt is updated "in place". Its length (`len`
    /// bytes) MUST be a multiple of the block size.
    ///
    /// \param ctx      context structure (already initialised).
    /// \param ctr      counter for CTR encryption (initial and final).
    /// \param cbcmac   IV and output buffer for CBC-MAC.
    /// \param data     data to encrypt.
    /// \param len      data length (in bytes). 
 pub encrypt : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_block_ctrcbc_class , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Run the CTR decryption + CBC-MAC.
    ///
    /// The `ctr` parameter points to the counter; its length shall
    /// be equal to the block size. It is updated by this function
    /// as decryption proceeds.
    ///
    /// The `cbcmac` parameter points to the IV for CBC-MAC. The MAC
    /// is computed over the encrypted data (i.e. before CTR
    /// decryption). Its length shall be equal to the block size. The
    /// computed CBC-MAC value is written over the `cbcmac` array.
    ///
    /// The data to decrypt is updated "in place". Its length (`len`
    /// bytes) MUST be a multiple of the block size.
    ///
    /// \param ctx      context structure (already initialised).
    /// \param ctr      counter for CTR encryption (initial and final).
    /// \param cbcmac   IV and output buffer for CBC-MAC.
    /// \param data     data to decrypt.
    /// \param len      data length (in bytes). 
 pub decrypt : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_block_ctrcbc_class , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Run the CTR encryption/decryption only.
    ///
    /// The `ctr` parameter points to the counter; its length shall
    /// be equal to the block size. It is updated by this function
    /// as decryption proceeds.
    ///
    /// The data to decrypt is updated "in place". Its length (`len`
    /// bytes) MUST be a multiple of the block size.
    ///
    /// \param ctx      context structure (already initialised).
    /// \param ctr      counter for CTR encryption (initial and final).
    /// \param data     data to decrypt.
    /// \param len      data length (in bytes). 
 pub ctr : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_block_ctrcbc_class , ctr : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Run the CBC-MAC only.
    ///
    /// The `cbcmac` parameter points to the IV for CBC-MAC. The MAC
    /// is computed over the encrypted data (i.e. before CTR
    /// decryption). Its length shall be equal to the block size. The
    /// computed CBC-MAC value is written over the `cbcmac` array.
    ///
    /// The data is unmodified. Its length (`len` bytes) MUST be a
    /// multiple of the block size.
    ///
    /// \param ctx      context structure (already initialised).
    /// \param cbcmac   IV and output buffer for CBC-MAC.
    /// \param data     data to decrypt.
    /// \param len      data length (in bytes). 
 pub mac : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_block_ctrcbc_class , cbcmac : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize ) > , } # [ test ] fn bindgen_test_layout_br_block_ctrcbc_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_block_ctrcbc_class_ > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( br_block_ctrcbc_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_block_ctrcbc_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_block_ctrcbc_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctrcbc_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctrcbc_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctrcbc_class_ > ( ) ) ) . block_size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctrcbc_class_ ) , "::" , stringify ! ( block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctrcbc_class_ > ( ) ) ) . log_block_size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctrcbc_class_ ) , "::" , stringify ! ( log_block_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctrcbc_class_ > ( ) ) ) . init as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctrcbc_class_ ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctrcbc_class_ > ( ) ) ) . encrypt as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctrcbc_class_ ) , "::" , stringify ! ( encrypt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctrcbc_class_ > ( ) ) ) . decrypt as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctrcbc_class_ ) , "::" , stringify ! ( decrypt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctrcbc_class_ > ( ) ) ) . ctr as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctrcbc_class_ ) , "::" , stringify ! ( ctr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_block_ctrcbc_class_ > ( ) ) ) . mac as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_block_ctrcbc_class_ ) , "::" , stringify ! ( mac ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_big` implementation, CBC encryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_big_cbcenc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcenc_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_big_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_big_cbcenc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_big_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_big_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_big_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_cbcenc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_cbcenc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_cbcenc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_cbcenc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_big` implementation, CBC decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_big_cbcdec_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcdec_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_big_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_big_cbcdec_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_big_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_big_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_big_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_cbcdec_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_cbcdec_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_cbcdec_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_cbcdec_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_big` implementation, CTR encryption
/// and decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_big_ctr_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctr_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_big_ctr_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_big_ctr_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_big_ctr_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_big_ctr_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_big_ctr_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_ctr_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_ctr_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_ctr_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_ctr_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_ctr_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_ctr_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_big` implementation, CTR encryption
/// and decryption + CBC-MAC).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_big_ctrcbc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctrcbc_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_big_ctrcbc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_big_ctrcbc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_big_ctrcbc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_big_ctrcbc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_big_ctrcbc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_ctrcbc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_ctrcbc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_ctrcbc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_ctrcbc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_big_ctrcbc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_big_ctrcbc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_aes_big_cbcenc_vtable" ] 
 pub static mut  br_aes_big_cbcenc_vtable  :  br_block_cbcenc_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_big_cbcdec_vtable" ] 
 pub static mut  br_aes_big_cbcdec_vtable  :  br_block_cbcdec_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_big_ctr_vtable" ] 
 pub static mut  br_aes_big_ctr_vtable  :  br_block_ctr_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_big_ctrcbc_vtable" ] 
 pub static mut  br_aes_big_ctrcbc_vtable  :  br_block_ctrcbc_class ;
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC encryption
/// (`aes_big` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_big_cbcenc_init ( ctx : * mut br_aes_big_cbcenc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC decryption
/// (`aes_big` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_big_cbcdec_init ( ctx : * mut br_aes_big_cbcdec_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR encryption
/// and decryption (`aes_big` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_big_ctr_init ( ctx : * mut br_aes_big_ctr_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR + CBC-MAC
/// (`aes_big` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_big_ctrcbc_init ( ctx : * mut br_aes_big_ctrcbc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC encryption with AES (`aes_big` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to encrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_big_cbcenc_run ( ctx : * const br_aes_big_cbcenc_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC decryption with AES (`aes_big` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_big_cbcdec_run ( ctx : * const br_aes_big_cbcdec_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption and decryption with AES (`aes_big` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (constant, 12 bytes).
/// \param cc     initial block counter value.
/// \param data   data to encrypt or decrypt (updated).
/// \param len    data length (in bytes).
/// \return  new block counter value. 
 
 pub fn br_aes_big_ctr_run ( ctx : * const br_aes_big_ctr_keys , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief CTR encryption + CBC-MAC with AES (`aes_big` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to encrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_big_ctrcbc_encrypt ( ctx : * const br_aes_big_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR decryption + CBC-MAC with AES (`aes_big` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to decrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_big_ctrcbc_decrypt ( ctx : * const br_aes_big_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption/decryption with AES (`aes_big` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param data     data to MAC (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_big_ctrcbc_ctr ( ctx : * const br_aes_big_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC-MAC with AES (`aes_big` implementation).
///
/// \param ctx      context (already initialised).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to MAC (unmodified).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_big_ctrcbc_mac ( ctx : * const br_aes_big_ctrcbc_keys , cbcmac : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} 
 /// \brief Context for AES subkeys (`aes_small` implementation, CBC encryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_small_cbcenc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcenc_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_small_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_small_cbcenc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_small_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_small_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_small_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_cbcenc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_cbcenc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_cbcenc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_cbcenc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_small` implementation, CBC decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_small_cbcdec_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcdec_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_small_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_small_cbcdec_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_small_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_small_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_small_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_cbcdec_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_cbcdec_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_cbcdec_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_cbcdec_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_small` implementation, CTR encryption
/// and decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_small_ctr_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctr_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_small_ctr_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_small_ctr_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_small_ctr_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_small_ctr_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_small_ctr_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_ctr_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_ctr_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_ctr_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_ctr_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_ctr_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_ctr_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_small` implementation, CTR encryption
/// and decryption + CBC-MAC).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_small_ctrcbc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctrcbc_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_small_ctrcbc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_small_ctrcbc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_small_ctrcbc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_small_ctrcbc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_small_ctrcbc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_ctrcbc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_ctrcbc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_ctrcbc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_ctrcbc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_small_ctrcbc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_small_ctrcbc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_aes_small_cbcenc_vtable" ] 
 pub static mut  br_aes_small_cbcenc_vtable  :  br_block_cbcenc_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_small_cbcdec_vtable" ] 
 pub static mut  br_aes_small_cbcdec_vtable  :  br_block_cbcdec_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_small_ctr_vtable" ] 
 pub static mut  br_aes_small_ctr_vtable  :  br_block_ctr_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_small_ctrcbc_vtable" ] 
 pub static mut  br_aes_small_ctrcbc_vtable  :  br_block_ctrcbc_class ;
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC encryption
/// (`aes_small` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_small_cbcenc_init ( ctx : * mut br_aes_small_cbcenc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC decryption
/// (`aes_small` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_small_cbcdec_init ( ctx : * mut br_aes_small_cbcdec_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR encryption
/// and decryption (`aes_small` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_small_ctr_init ( ctx : * mut br_aes_small_ctr_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR + CBC-MAC
/// (`aes_small` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_small_ctrcbc_init ( ctx : * mut br_aes_small_ctrcbc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC encryption with AES (`aes_small` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to encrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_small_cbcenc_run ( ctx : * const br_aes_small_cbcenc_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC decryption with AES (`aes_small` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_small_cbcdec_run ( ctx : * const br_aes_small_cbcdec_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption and decryption with AES (`aes_small` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (constant, 12 bytes).
/// \param cc     initial block counter value.
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes).
/// \return  new block counter value. 
 
 pub fn br_aes_small_ctr_run ( ctx : * const br_aes_small_ctr_keys , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief CTR encryption + CBC-MAC with AES (`aes_small` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to encrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_small_ctrcbc_encrypt ( ctx : * const br_aes_small_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR decryption + CBC-MAC with AES (`aes_small` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to decrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_small_ctrcbc_decrypt ( ctx : * const br_aes_small_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption/decryption with AES (`aes_small` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param data     data to MAC (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_small_ctrcbc_ctr ( ctx : * const br_aes_small_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC-MAC with AES (`aes_small` implementation).
///
/// \param ctx      context (already initialised).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to MAC (unmodified).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_small_ctrcbc_mac ( ctx : * const br_aes_small_ctrcbc_keys , cbcmac : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} 
 /// \brief Context for AES subkeys (`aes_ct` implementation, CBC encryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_ct_cbcenc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcenc_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_ct_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_ct_cbcenc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_ct_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_ct_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_ct_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_cbcenc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_cbcenc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_cbcenc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_cbcenc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_ct` implementation, CBC decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_ct_cbcdec_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcdec_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_ct_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_ct_cbcdec_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_ct_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_ct_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_ct_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_cbcdec_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_cbcdec_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_cbcdec_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_cbcdec_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_ct` implementation, CTR encryption
/// and decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_ct_ctr_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctr_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_ct_ctr_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_ct_ctr_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_ct_ctr_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_ct_ctr_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_ct_ctr_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_ctr_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_ctr_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_ctr_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_ctr_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_ctr_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_ctr_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_ct` implementation, CTR encryption
/// and decryption + CBC-MAC).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_ct_ctrcbc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctrcbc_class , pub skey : [ u32 ; 60usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_ct_ctrcbc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_ct_ctrcbc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_ct_ctrcbc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_ct_ctrcbc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_ct_ctrcbc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_ctrcbc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_ctrcbc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_ctrcbc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_ctrcbc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct_ctrcbc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct_ctrcbc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_aes_ct_cbcenc_vtable" ] 
 pub static mut  br_aes_ct_cbcenc_vtable  :  br_block_cbcenc_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_ct_cbcdec_vtable" ] 
 pub static mut  br_aes_ct_cbcdec_vtable  :  br_block_cbcdec_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_ct_ctr_vtable" ] 
 pub static mut  br_aes_ct_ctr_vtable  :  br_block_ctr_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_ct_ctrcbc_vtable" ] 
 pub static mut  br_aes_ct_ctrcbc_vtable  :  br_block_ctrcbc_class ;
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC encryption
/// (`aes_ct` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_ct_cbcenc_init ( ctx : * mut br_aes_ct_cbcenc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC decryption
/// (`aes_ct` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_ct_cbcdec_init ( ctx : * mut br_aes_ct_cbcdec_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR encryption
/// and decryption (`aes_ct` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_ct_ctr_init ( ctx : * mut br_aes_ct_ctr_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR + CBC-MAC
/// (`aes_ct` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_ct_ctrcbc_init ( ctx : * mut br_aes_ct_ctrcbc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC encryption with AES (`aes_ct` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to encrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_ct_cbcenc_run ( ctx : * const br_aes_ct_cbcenc_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC decryption with AES (`aes_ct` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_ct_cbcdec_run ( ctx : * const br_aes_ct_cbcdec_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption and decryption with AES (`aes_ct` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (constant, 12 bytes).
/// \param cc     initial block counter value.
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes).
/// \return  new block counter value. 
 
 pub fn br_aes_ct_ctr_run ( ctx : * const br_aes_ct_ctr_keys , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief CTR encryption + CBC-MAC with AES (`aes_ct` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to encrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_ct_ctrcbc_encrypt ( ctx : * const br_aes_ct_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR decryption + CBC-MAC with AES (`aes_ct` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to decrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_ct_ctrcbc_decrypt ( ctx : * const br_aes_ct_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption/decryption with AES (`aes_ct` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param data     data to MAC (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_ct_ctrcbc_ctr ( ctx : * const br_aes_ct_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC-MAC with AES (`aes_ct` implementation).
///
/// \param ctx      context (already initialised).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to MAC (unmodified).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_ct_ctrcbc_mac ( ctx : * const br_aes_ct_ctrcbc_keys , cbcmac : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} 
 /// \brief Context for AES subkeys (`aes_ct64` implementation, CBC encryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_aes_ct64_cbcenc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcenc_class , pub skey : [ u64 ; 30usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_ct64_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_ct64_cbcenc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_ct64_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_ct64_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_ct64_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_cbcenc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_cbcenc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_cbcenc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_cbcenc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_ct64` implementation, CBC decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_aes_ct64_cbcdec_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcdec_class , pub skey : [ u64 ; 30usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_ct64_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_ct64_cbcdec_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_ct64_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_ct64_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_ct64_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_cbcdec_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_cbcdec_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_cbcdec_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_cbcdec_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_ct64` implementation, CTR encryption
/// and decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_aes_ct64_ctr_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctr_class , pub skey : [ u64 ; 30usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_ct64_ctr_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_ct64_ctr_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_ct64_ctr_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_ct64_ctr_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_ct64_ctr_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_ctr_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_ctr_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_ctr_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_ctr_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_ctr_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_ctr_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_ct64` implementation, CTR encryption
/// and decryption + CBC-MAC).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_aes_ct64_ctrcbc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctrcbc_class , pub skey : [ u64 ; 30usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_aes_ct64_ctrcbc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_ct64_ctrcbc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_ct64_ctrcbc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_ct64_ctrcbc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_ct64_ctrcbc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_ctrcbc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_ctrcbc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_ctrcbc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_ctrcbc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_ct64_ctrcbc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_ct64_ctrcbc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_aes_ct64_cbcenc_vtable" ] 
 pub static mut  br_aes_ct64_cbcenc_vtable  :  br_block_cbcenc_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_ct64_cbcdec_vtable" ] 
 pub static mut  br_aes_ct64_cbcdec_vtable  :  br_block_cbcdec_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_ct64_ctr_vtable" ] 
 pub static mut  br_aes_ct64_ctr_vtable  :  br_block_ctr_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_ct64_ctrcbc_vtable" ] 
 pub static mut  br_aes_ct64_ctrcbc_vtable  :  br_block_ctrcbc_class ;
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC encryption
/// (`aes_ct64` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_ct64_cbcenc_init ( ctx : * mut br_aes_ct64_cbcenc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC decryption
/// (`aes_ct64` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_ct64_cbcdec_init ( ctx : * mut br_aes_ct64_cbcdec_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR encryption
/// and decryption (`aes_ct64` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_ct64_ctr_init ( ctx : * mut br_aes_ct64_ctr_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR + CBC-MAC
/// (`aes_ct64` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_ct64_ctrcbc_init ( ctx : * mut br_aes_ct64_ctrcbc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC encryption with AES (`aes_ct64` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to encrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_ct64_cbcenc_run ( ctx : * const br_aes_ct64_cbcenc_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC decryption with AES (`aes_ct64` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_ct64_cbcdec_run ( ctx : * const br_aes_ct64_cbcdec_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption and decryption with AES (`aes_ct64` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (constant, 12 bytes).
/// \param cc     initial block counter value.
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes).
/// \return  new block counter value. 
 
 pub fn br_aes_ct64_ctr_run ( ctx : * const br_aes_ct64_ctr_keys , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief CTR encryption + CBC-MAC with AES (`aes_ct64` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to encrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_ct64_ctrcbc_encrypt ( ctx : * const br_aes_ct64_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR decryption + CBC-MAC with AES (`aes_ct64` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to decrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_ct64_ctrcbc_decrypt ( ctx : * const br_aes_ct64_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption/decryption with AES (`aes_ct64` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param data     data to MAC (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_ct64_ctrcbc_ctr ( ctx : * const br_aes_ct64_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC-MAC with AES (`aes_ct64` implementation).
///
/// \param ctx      context (already initialised).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to MAC (unmodified).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_ct64_ctrcbc_mac ( ctx : * const br_aes_ct64_ctrcbc_keys , cbcmac : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} 
 /// \brief Context for AES subkeys (`aes_x86ni` implementation, CBC encryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_x86ni_cbcenc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcenc_class , pub skey : br_aes_x86ni_cbcenc_keys__bindgen_ty_1 , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_x86ni_cbcenc_keys__bindgen_ty_1 { pub skni : [ :: std :: os :: raw :: c_uchar ; 240usize ] , _bindgen_union_align : [ u8 ; 240usize ] , } # [ test ] fn bindgen_test_layout_br_aes_x86ni_cbcenc_keys__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_x86ni_cbcenc_keys__bindgen_ty_1 > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( br_aes_x86ni_cbcenc_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_x86ni_cbcenc_keys__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( br_aes_x86ni_cbcenc_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_cbcenc_keys__bindgen_ty_1 > ( ) ) ) . skni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_cbcenc_keys__bindgen_ty_1 ) , "::" , stringify ! ( skni ) ) ) ; } # [ test ] fn bindgen_test_layout_br_aes_x86ni_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_x86ni_cbcenc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_x86ni_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_x86ni_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_x86ni_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_cbcenc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_cbcenc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_cbcenc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_cbcenc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_x86ni` implementation, CBC decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_x86ni_cbcdec_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcdec_class , pub skey : br_aes_x86ni_cbcdec_keys__bindgen_ty_1 , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_x86ni_cbcdec_keys__bindgen_ty_1 { pub skni : [ :: std :: os :: raw :: c_uchar ; 240usize ] , _bindgen_union_align : [ u8 ; 240usize ] , } # [ test ] fn bindgen_test_layout_br_aes_x86ni_cbcdec_keys__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_x86ni_cbcdec_keys__bindgen_ty_1 > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( br_aes_x86ni_cbcdec_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_x86ni_cbcdec_keys__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( br_aes_x86ni_cbcdec_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_cbcdec_keys__bindgen_ty_1 > ( ) ) ) . skni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_cbcdec_keys__bindgen_ty_1 ) , "::" , stringify ! ( skni ) ) ) ; } # [ test ] fn bindgen_test_layout_br_aes_x86ni_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_x86ni_cbcdec_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_x86ni_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_x86ni_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_x86ni_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_cbcdec_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_cbcdec_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_cbcdec_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_cbcdec_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_x86ni` implementation, CTR encryption
/// and decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_x86ni_ctr_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctr_class , pub skey : br_aes_x86ni_ctr_keys__bindgen_ty_1 , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_x86ni_ctr_keys__bindgen_ty_1 { pub skni : [ :: std :: os :: raw :: c_uchar ; 240usize ] , _bindgen_union_align : [ u8 ; 240usize ] , } # [ test ] fn bindgen_test_layout_br_aes_x86ni_ctr_keys__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_x86ni_ctr_keys__bindgen_ty_1 > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( br_aes_x86ni_ctr_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_x86ni_ctr_keys__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( br_aes_x86ni_ctr_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_ctr_keys__bindgen_ty_1 > ( ) ) ) . skni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_ctr_keys__bindgen_ty_1 ) , "::" , stringify ! ( skni ) ) ) ; } # [ test ] fn bindgen_test_layout_br_aes_x86ni_ctr_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_x86ni_ctr_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_x86ni_ctr_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_x86ni_ctr_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_x86ni_ctr_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_ctr_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_ctr_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_ctr_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_ctr_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_ctr_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_ctr_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_x86ni` implementation, CTR encryption
/// and decryption + CBC-MAC).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_x86ni_ctrcbc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctrcbc_class , pub skey : br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 { pub skni : [ :: std :: os :: raw :: c_uchar ; 240usize ] , _bindgen_union_align : [ u8 ; 240usize ] , } # [ test ] fn bindgen_test_layout_br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 > ( ) ) ) . skni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_ctrcbc_keys__bindgen_ty_1 ) , "::" , stringify ! ( skni ) ) ) ; } # [ test ] fn bindgen_test_layout_br_aes_x86ni_ctrcbc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_x86ni_ctrcbc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_x86ni_ctrcbc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_x86ni_ctrcbc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_x86ni_ctrcbc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_ctrcbc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_ctrcbc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_ctrcbc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_ctrcbc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_x86ni_ctrcbc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_x86ni_ctrcbc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_aes_x86ni_cbcenc_vtable" ] 
 pub static mut  br_aes_x86ni_cbcenc_vtable  :  br_block_cbcenc_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_x86ni_cbcdec_vtable" ] 
 pub static mut  br_aes_x86ni_cbcdec_vtable  :  br_block_cbcdec_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_x86ni_ctr_vtable" ] 
 pub static mut  br_aes_x86ni_ctr_vtable  :  br_block_ctr_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_x86ni_ctrcbc_vtable" ] 
 pub static mut  br_aes_x86ni_ctrcbc_vtable  :  br_block_ctrcbc_class ;
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC encryption
/// (`aes_x86ni` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_x86ni_cbcenc_init ( ctx : * mut br_aes_x86ni_cbcenc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC decryption
/// (`aes_x86ni` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_x86ni_cbcdec_init ( ctx : * mut br_aes_x86ni_cbcdec_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR encryption
/// and decryption (`aes_x86ni` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_x86ni_ctr_init ( ctx : * mut br_aes_x86ni_ctr_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR + CBC-MAC
/// (`aes_x86ni` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_x86ni_ctrcbc_init ( ctx : * mut br_aes_x86ni_ctrcbc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC encryption with AES (`aes_x86ni` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to encrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_x86ni_cbcenc_run ( ctx : * const br_aes_x86ni_cbcenc_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC decryption with AES (`aes_x86ni` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_x86ni_cbcdec_run ( ctx : * const br_aes_x86ni_cbcdec_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption and decryption with AES (`aes_x86ni` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (constant, 12 bytes).
/// \param cc     initial block counter value.
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes).
/// \return  new block counter value. 
 
 pub fn br_aes_x86ni_ctr_run ( ctx : * const br_aes_x86ni_ctr_keys , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief CTR encryption + CBC-MAC with AES (`aes_x86ni` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to encrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_x86ni_ctrcbc_encrypt ( ctx : * const br_aes_x86ni_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR decryption + CBC-MAC with AES (`aes_x86ni` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to decrypt (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_x86ni_ctrcbc_decrypt ( ctx : * const br_aes_x86ni_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , cbcmac : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption/decryption with AES (`aes_x86ni` implementation).
///
/// \param ctx      context (already initialised).
/// \param ctr      counter for CTR (16 bytes, updated).
/// \param data     data to MAC (updated).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_x86ni_ctrcbc_ctr ( ctx : * const br_aes_x86ni_ctrcbc_keys , ctr : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC-MAC with AES (`aes_x86ni` implementation).
///
/// \param ctx      context (already initialised).
/// \param cbcmac   IV for CBC-MAC (updated).
/// \param data     data to MAC (unmodified).
/// \param len      data length (in bytes, MUST be a multiple of 16). 
 
 pub fn br_aes_x86ni_ctrcbc_mac ( ctx : * const br_aes_x86ni_ctrcbc_keys , cbcmac : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Obtain the `aes_x86ni` AES-CBC (encryption) implementation, if
/// available.
///
/// This function returns a pointer to `br_aes_x86ni_cbcenc_vtable`, if
/// that implementation was compiled in the library _and_ the x86 AES
/// opcodes are available on the currently running CPU. If either of
/// these conditions is not met, then this function returns `NULL`.
///
/// \return  the `aes_x86ni` AES-CBC (encryption) implementation, or `NULL`. 
 
 pub fn br_aes_x86ni_cbcenc_get_vtable ( ) -> * const br_block_cbcenc_class ; 
} extern "C" {
 
 /// \brief Obtain the `aes_x86ni` AES-CBC (decryption) implementation, if
/// available.
///
/// This function returns a pointer to `br_aes_x86ni_cbcdec_vtable`, if
/// that implementation was compiled in the library _and_ the x86 AES
/// opcodes are available on the currently running CPU. If either of
/// these conditions is not met, then this function returns `NULL`.
///
/// \return  the `aes_x86ni` AES-CBC (decryption) implementation, or `NULL`. 
 
 pub fn br_aes_x86ni_cbcdec_get_vtable ( ) -> * const br_block_cbcdec_class ; 
} extern "C" {
 
 /// \brief Obtain the `aes_x86ni` AES-CTR implementation, if available.
///
/// This function returns a pointer to `br_aes_x86ni_ctr_vtable`, if
/// that implementation was compiled in the library _and_ the x86 AES
/// opcodes are available on the currently running CPU. If either of
/// these conditions is not met, then this function returns `NULL`.
///
/// \return  the `aes_x86ni` AES-CTR implementation, or `NULL`. 
 
 pub fn br_aes_x86ni_ctr_get_vtable ( ) -> * const br_block_ctr_class ; 
} extern "C" {
 
 /// \brief Obtain the `aes_x86ni` AES-CTR + CBC-MAC implementation, if
/// available.
///
/// This function returns a pointer to `br_aes_x86ni_ctrcbc_vtable`, if
/// that implementation was compiled in the library _and_ the x86 AES
/// opcodes are available on the currently running CPU. If either of
/// these conditions is not met, then this function returns `NULL`.
///
/// \return  the `aes_x86ni` AES-CTR implementation, or `NULL`. 
 
 pub fn br_aes_x86ni_ctrcbc_get_vtable ( ) -> * const br_block_ctrcbc_class ; 
} 
 /// \brief Context for AES subkeys (`aes_pwr8` implementation, CBC encryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_pwr8_cbcenc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcenc_class , pub skey : br_aes_pwr8_cbcenc_keys__bindgen_ty_1 , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_pwr8_cbcenc_keys__bindgen_ty_1 { pub skni : [ :: std :: os :: raw :: c_uchar ; 240usize ] , _bindgen_union_align : [ u8 ; 240usize ] , } # [ test ] fn bindgen_test_layout_br_aes_pwr8_cbcenc_keys__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_pwr8_cbcenc_keys__bindgen_ty_1 > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( br_aes_pwr8_cbcenc_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_pwr8_cbcenc_keys__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( br_aes_pwr8_cbcenc_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_cbcenc_keys__bindgen_ty_1 > ( ) ) ) . skni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_cbcenc_keys__bindgen_ty_1 ) , "::" , stringify ! ( skni ) ) ) ; } # [ test ] fn bindgen_test_layout_br_aes_pwr8_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_pwr8_cbcenc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_pwr8_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_pwr8_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_pwr8_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_cbcenc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_cbcenc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_cbcenc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_cbcenc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_pwr8` implementation, CBC decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_pwr8_cbcdec_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcdec_class , pub skey : br_aes_pwr8_cbcdec_keys__bindgen_ty_1 , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_pwr8_cbcdec_keys__bindgen_ty_1 { pub skni : [ :: std :: os :: raw :: c_uchar ; 240usize ] , _bindgen_union_align : [ u8 ; 240usize ] , } # [ test ] fn bindgen_test_layout_br_aes_pwr8_cbcdec_keys__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_pwr8_cbcdec_keys__bindgen_ty_1 > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( br_aes_pwr8_cbcdec_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_pwr8_cbcdec_keys__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( br_aes_pwr8_cbcdec_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_cbcdec_keys__bindgen_ty_1 > ( ) ) ) . skni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_cbcdec_keys__bindgen_ty_1 ) , "::" , stringify ! ( skni ) ) ) ; } # [ test ] fn bindgen_test_layout_br_aes_pwr8_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_pwr8_cbcdec_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_pwr8_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_pwr8_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_pwr8_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_cbcdec_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_cbcdec_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_cbcdec_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_cbcdec_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for AES subkeys (`aes_pwr8` implementation, CTR encryption
/// and decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_aes_pwr8_ctr_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_ctr_class , pub skey : br_aes_pwr8_ctr_keys__bindgen_ty_1 , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_pwr8_ctr_keys__bindgen_ty_1 { pub skni : [ :: std :: os :: raw :: c_uchar ; 240usize ] , _bindgen_union_align : [ u8 ; 240usize ] , } # [ test ] fn bindgen_test_layout_br_aes_pwr8_ctr_keys__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_pwr8_ctr_keys__bindgen_ty_1 > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( br_aes_pwr8_ctr_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_pwr8_ctr_keys__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( br_aes_pwr8_ctr_keys__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_ctr_keys__bindgen_ty_1 > ( ) ) ) . skni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_ctr_keys__bindgen_ty_1 ) , "::" , stringify ! ( skni ) ) ) ; } # [ test ] fn bindgen_test_layout_br_aes_pwr8_ctr_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_pwr8_ctr_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_pwr8_ctr_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_pwr8_ctr_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_pwr8_ctr_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_ctr_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_ctr_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_ctr_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_ctr_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_pwr8_ctr_keys > ( ) ) ) . num_rounds as * const _ as usize } , 248usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_pwr8_ctr_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_aes_pwr8_cbcenc_vtable" ] 
 pub static mut  br_aes_pwr8_cbcenc_vtable  :  br_block_cbcenc_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_pwr8_cbcdec_vtable" ] 
 pub static mut  br_aes_pwr8_cbcdec_vtable  :  br_block_cbcdec_class ;
} extern "C" {
 # [ link_name = "\u{1}br_aes_pwr8_ctr_vtable" ] 
 pub static mut  br_aes_pwr8_ctr_vtable  :  br_block_ctr_class ;
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC encryption
/// (`aes_pwr8` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_pwr8_cbcenc_init ( ctx : * mut br_aes_pwr8_cbcenc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CBC decryption
/// (`aes_pwr8` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_pwr8_cbcdec_init ( ctx : * mut br_aes_pwr8_cbcdec_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for AES CTR encryption
/// and decryption (`aes_pwr8` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_aes_pwr8_ctr_init ( ctx : * mut br_aes_pwr8_ctr_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC encryption with AES (`aes_pwr8` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to encrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_pwr8_cbcenc_run ( ctx : * const br_aes_pwr8_cbcenc_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC decryption with AES (`aes_pwr8` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 16). 
 
 pub fn br_aes_pwr8_cbcdec_run ( ctx : * const br_aes_pwr8_cbcdec_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CTR encryption and decryption with AES (`aes_pwr8` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (constant, 12 bytes).
/// \param cc     initial block counter value.
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes).
/// \return  new block counter value. 
 
 pub fn br_aes_pwr8_ctr_run ( ctx : * const br_aes_pwr8_ctr_keys , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief Obtain the `aes_pwr8` AES-CBC (encryption) implementation, if
/// available.
///
/// This function returns a pointer to `br_aes_pwr8_cbcenc_vtable`, if
/// that implementation was compiled in the library _and_ the POWER8
/// crypto opcodes are available on the currently running CPU. If either
/// of these conditions is not met, then this function returns `NULL`.
///
/// \return  the `aes_pwr8` AES-CBC (encryption) implementation, or `NULL`. 
 
 pub fn br_aes_pwr8_cbcenc_get_vtable ( ) -> * const br_block_cbcenc_class ; 
} extern "C" {
 
 /// \brief Obtain the `aes_pwr8` AES-CBC (decryption) implementation, if
/// available.
///
/// This function returns a pointer to `br_aes_pwr8_cbcdec_vtable`, if
/// that implementation was compiled in the library _and_ the POWER8
/// crypto opcodes are available on the currently running CPU. If either
/// of these conditions is not met, then this function returns `NULL`.
///
/// \return  the `aes_pwr8` AES-CBC (decryption) implementation, or `NULL`. 
 
 pub fn br_aes_pwr8_cbcdec_get_vtable ( ) -> * const br_block_cbcdec_class ; 
} extern "C" {
 
 /// \brief Obtain the `aes_pwr8` AES-CTR implementation, if available.
///
/// This function returns a pointer to `br_aes_pwr8_ctr_vtable`, if that
/// implementation was compiled in the library _and_ the POWER8 crypto
/// opcodes are available on the currently running CPU. If either of
/// these conditions is not met, then this function returns `NULL`.
///
/// \return  the `aes_pwr8` AES-CTR implementation, or `NULL`. 
 
 pub fn br_aes_pwr8_ctr_get_vtable ( ) -> * const br_block_ctr_class ; 
} 
 /// \brief Aggregate structure large enough to be used as context for
/// subkeys (CBC encryption) for all AES implementations. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_gen_cbcenc_keys { pub vtable : * const br_block_cbcenc_class , pub c_big : br_aes_big_cbcenc_keys , pub c_small : br_aes_small_cbcenc_keys , pub c_ct : br_aes_ct_cbcenc_keys , pub c_ct64 : br_aes_ct64_cbcenc_keys , pub c_x86ni : br_aes_x86ni_cbcenc_keys , pub c_pwr8 : br_aes_pwr8_cbcenc_keys , _bindgen_union_align : [ u64 ; 32usize ] , } # [ test ] fn bindgen_test_layout_br_aes_gen_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_gen_cbcenc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_gen_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_gen_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_gen_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcenc_keys > ( ) ) ) . c_big as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcenc_keys ) , "::" , stringify ! ( c_big ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcenc_keys > ( ) ) ) . c_small as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcenc_keys ) , "::" , stringify ! ( c_small ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcenc_keys > ( ) ) ) . c_ct as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcenc_keys ) , "::" , stringify ! ( c_ct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcenc_keys > ( ) ) ) . c_ct64 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcenc_keys ) , "::" , stringify ! ( c_ct64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcenc_keys > ( ) ) ) . c_x86ni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcenc_keys ) , "::" , stringify ! ( c_x86ni ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcenc_keys > ( ) ) ) . c_pwr8 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcenc_keys ) , "::" , stringify ! ( c_pwr8 ) ) ) ; } 
 /// \brief Aggregate structure large enough to be used as context for
/// subkeys (CBC decryption) for all AES implementations. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_gen_cbcdec_keys { pub vtable : * const br_block_cbcdec_class , pub c_big : br_aes_big_cbcdec_keys , pub c_small : br_aes_small_cbcdec_keys , pub c_ct : br_aes_ct_cbcdec_keys , pub c_ct64 : br_aes_ct64_cbcdec_keys , pub c_x86ni : br_aes_x86ni_cbcdec_keys , pub c_pwr8 : br_aes_pwr8_cbcdec_keys , _bindgen_union_align : [ u64 ; 32usize ] , } # [ test ] fn bindgen_test_layout_br_aes_gen_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_gen_cbcdec_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_gen_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_gen_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_gen_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcdec_keys > ( ) ) ) . c_big as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcdec_keys ) , "::" , stringify ! ( c_big ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcdec_keys > ( ) ) ) . c_small as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcdec_keys ) , "::" , stringify ! ( c_small ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcdec_keys > ( ) ) ) . c_ct as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcdec_keys ) , "::" , stringify ! ( c_ct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcdec_keys > ( ) ) ) . c_ct64 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcdec_keys ) , "::" , stringify ! ( c_ct64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcdec_keys > ( ) ) ) . c_x86ni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcdec_keys ) , "::" , stringify ! ( c_x86ni ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_cbcdec_keys > ( ) ) ) . c_pwr8 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_cbcdec_keys ) , "::" , stringify ! ( c_pwr8 ) ) ) ; } 
 /// \brief Aggregate structure large enough to be used as context for
/// subkeys (CTR encryption and decryption) for all AES implementations. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_gen_ctr_keys { pub vtable : * const br_block_ctr_class , pub c_big : br_aes_big_ctr_keys , pub c_small : br_aes_small_ctr_keys , pub c_ct : br_aes_ct_ctr_keys , pub c_ct64 : br_aes_ct64_ctr_keys , pub c_x86ni : br_aes_x86ni_ctr_keys , pub c_pwr8 : br_aes_pwr8_ctr_keys , _bindgen_union_align : [ u64 ; 32usize ] , } # [ test ] fn bindgen_test_layout_br_aes_gen_ctr_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_gen_ctr_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_gen_ctr_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_gen_ctr_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_gen_ctr_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctr_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctr_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctr_keys > ( ) ) ) . c_big as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctr_keys ) , "::" , stringify ! ( c_big ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctr_keys > ( ) ) ) . c_small as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctr_keys ) , "::" , stringify ! ( c_small ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctr_keys > ( ) ) ) . c_ct as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctr_keys ) , "::" , stringify ! ( c_ct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctr_keys > ( ) ) ) . c_ct64 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctr_keys ) , "::" , stringify ! ( c_ct64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctr_keys > ( ) ) ) . c_x86ni as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctr_keys ) , "::" , stringify ! ( c_x86ni ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctr_keys > ( ) ) ) . c_pwr8 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctr_keys ) , "::" , stringify ! ( c_pwr8 ) ) ) ; } 
 /// \brief Aggregate structure large enough to be used as context for
/// subkeys (CTR encryption/decryption + CBC-MAC) for all AES implementations. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_aes_gen_ctrcbc_keys { pub vtable : * const br_block_ctrcbc_class , pub c_big : br_aes_big_ctrcbc_keys , pub c_small : br_aes_small_ctrcbc_keys , pub c_ct : br_aes_ct_ctrcbc_keys , pub c_ct64 : br_aes_ct64_ctrcbc_keys , _bindgen_union_align : [ u64 ; 32usize ] , } # [ test ] fn bindgen_test_layout_br_aes_gen_ctrcbc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aes_gen_ctrcbc_keys > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_aes_gen_ctrcbc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aes_gen_ctrcbc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aes_gen_ctrcbc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctrcbc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctrcbc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctrcbc_keys > ( ) ) ) . c_big as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctrcbc_keys ) , "::" , stringify ! ( c_big ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctrcbc_keys > ( ) ) ) . c_small as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctrcbc_keys ) , "::" , stringify ! ( c_small ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctrcbc_keys > ( ) ) ) . c_ct as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctrcbc_keys ) , "::" , stringify ! ( c_ct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aes_gen_ctrcbc_keys > ( ) ) ) . c_ct64 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aes_gen_ctrcbc_keys ) , "::" , stringify ! ( c_ct64 ) ) ) ; } 
 /// \brief Context for DES subkeys (`des_tab` implementation, CBC encryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_des_tab_cbcenc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcenc_class , pub skey : [ u32 ; 96usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_des_tab_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_des_tab_cbcenc_keys > ( ) , 400usize , concat ! ( "Size of: " , stringify ! ( br_des_tab_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_des_tab_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_des_tab_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_tab_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_tab_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_tab_cbcenc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_des_tab_cbcenc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_tab_cbcenc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 392usize , concat ! ( "Offset of field: " , stringify ! ( br_des_tab_cbcenc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for DES subkeys (`des_tab` implementation, CBC decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_des_tab_cbcdec_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcdec_class , pub skey : [ u32 ; 96usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_des_tab_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_des_tab_cbcdec_keys > ( ) , 400usize , concat ! ( "Size of: " , stringify ! ( br_des_tab_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_des_tab_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_des_tab_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_tab_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_tab_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_tab_cbcdec_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_des_tab_cbcdec_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_tab_cbcdec_keys > ( ) ) ) . num_rounds as * const _ as usize } , 392usize , concat ! ( "Offset of field: " , stringify ! ( br_des_tab_cbcdec_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_des_tab_cbcenc_vtable" ] 
 pub static mut  br_des_tab_cbcenc_vtable  :  br_block_cbcenc_class ;
} extern "C" {
 # [ link_name = "\u{1}br_des_tab_cbcdec_vtable" ] 
 pub static mut  br_des_tab_cbcdec_vtable  :  br_block_cbcdec_class ;
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for DES CBC encryption
/// (`des_tab` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_des_tab_cbcenc_init ( ctx : * mut br_des_tab_cbcenc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for DES CBC decryption
/// (`des_tab` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_des_tab_cbcdec_init ( ctx : * mut br_des_tab_cbcdec_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC encryption with DES (`des_tab` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to encrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 8). 
 
 pub fn br_des_tab_cbcenc_run ( ctx : * const br_des_tab_cbcenc_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC decryption with DES (`des_tab` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 8). 
 
 pub fn br_des_tab_cbcdec_run ( ctx : * const br_des_tab_cbcdec_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} 
 /// \brief Context for DES subkeys (`des_ct` implementation, CBC encryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_des_ct_cbcenc_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcenc_class , pub skey : [ u32 ; 96usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_des_ct_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_des_ct_cbcenc_keys > ( ) , 400usize , concat ! ( "Size of: " , stringify ! ( br_des_ct_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_des_ct_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_des_ct_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_ct_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_ct_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_ct_cbcenc_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_des_ct_cbcenc_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_ct_cbcenc_keys > ( ) ) ) . num_rounds as * const _ as usize } , 392usize , concat ! ( "Offset of field: " , stringify ! ( br_des_ct_cbcenc_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } 
 /// \brief Context for DES subkeys (`des_ct` implementation, CBC decryption).
///
/// First field is a pointer to the vtable; it is set by the initialisation
/// function. Other fields are not supposed to be accessed by user code. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_des_ct_cbcdec_keys { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_block_cbcdec_class , pub skey : [ u32 ; 96usize ] , pub num_rounds : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_des_ct_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_des_ct_cbcdec_keys > ( ) , 400usize , concat ! ( "Size of: " , stringify ! ( br_des_ct_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_des_ct_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_des_ct_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_ct_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_ct_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_ct_cbcdec_keys > ( ) ) ) . skey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_des_ct_cbcdec_keys ) , "::" , stringify ! ( skey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_ct_cbcdec_keys > ( ) ) ) . num_rounds as * const _ as usize } , 392usize , concat ! ( "Offset of field: " , stringify ! ( br_des_ct_cbcdec_keys ) , "::" , stringify ! ( num_rounds ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_des_ct_cbcenc_vtable" ] 
 pub static mut  br_des_ct_cbcenc_vtable  :  br_block_cbcenc_class ;
} extern "C" {
 # [ link_name = "\u{1}br_des_ct_cbcdec_vtable" ] 
 pub static mut  br_des_ct_cbcdec_vtable  :  br_block_cbcdec_class ;
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for DES CBC encryption
/// (`des_ct` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_des_ct_cbcenc_init ( ctx : * mut br_des_ct_cbcenc_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Context initialisation (key schedule) for DES CBC decryption
/// (`des_ct` implementation).
///
/// \param ctx   context to initialise.
/// \param key   secret key.
/// \param len   secret key length (in bytes). 
 
 pub fn br_des_ct_cbcdec_init ( ctx : * mut br_des_ct_cbcdec_keys , key : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC encryption with DES (`des_ct` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to encrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 8). 
 
 pub fn br_des_ct_cbcenc_run ( ctx : * const br_des_ct_cbcenc_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief CBC decryption with DES (`des_ct` implementation).
///
/// \param ctx    context (already initialised).
/// \param iv     IV (updated).
/// \param data   data to decrypt (updated).
/// \param len    data length (in bytes, MUST be multiple of 8). 
 
 pub fn br_des_ct_cbcdec_run ( ctx : * const br_des_ct_cbcdec_keys , iv : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} 
 /// \brief Aggregate structure large enough to be used as context for
/// subkeys (CBC encryption) for all DES implementations. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_des_gen_cbcenc_keys { pub vtable : * const br_block_cbcenc_class , pub tab : br_des_tab_cbcenc_keys , pub ct : br_des_ct_cbcenc_keys , _bindgen_union_align : [ u64 ; 50usize ] , } # [ test ] fn bindgen_test_layout_br_des_gen_cbcenc_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_des_gen_cbcenc_keys > ( ) , 400usize , concat ! ( "Size of: " , stringify ! ( br_des_gen_cbcenc_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_des_gen_cbcenc_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_des_gen_cbcenc_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_gen_cbcenc_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_gen_cbcenc_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_gen_cbcenc_keys > ( ) ) ) . tab as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_gen_cbcenc_keys ) , "::" , stringify ! ( tab ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_gen_cbcenc_keys > ( ) ) ) . ct as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_gen_cbcenc_keys ) , "::" , stringify ! ( ct ) ) ) ; } 
 /// \brief Aggregate structure large enough to be used as context for
/// subkeys (CBC decryption) for all DES implementations. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_des_gen_cbcdec_keys { pub vtable : * const br_block_cbcdec_class , pub c_tab : br_des_tab_cbcdec_keys , pub c_ct : br_des_ct_cbcdec_keys , _bindgen_union_align : [ u64 ; 50usize ] , } # [ test ] fn bindgen_test_layout_br_des_gen_cbcdec_keys ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_des_gen_cbcdec_keys > ( ) , 400usize , concat ! ( "Size of: " , stringify ! ( br_des_gen_cbcdec_keys ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_des_gen_cbcdec_keys > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_des_gen_cbcdec_keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_gen_cbcdec_keys > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_gen_cbcdec_keys ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_gen_cbcdec_keys > ( ) ) ) . c_tab as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_gen_cbcdec_keys ) , "::" , stringify ! ( c_tab ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_des_gen_cbcdec_keys > ( ) ) ) . c_ct as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_des_gen_cbcdec_keys ) , "::" , stringify ! ( c_ct ) ) ) ; } 
 /// \brief Type for a ChaCha20 implementation.
///
/// An implementation follows the description in RFC 7539:
///
/// - Key is 256 bits (`key` points to exactly 32 bytes).
///
/// - IV is 96 bits (`iv` points to exactly 12 bytes).
///
/// - Block counter is over 32 bits and starts at value `cc`; the
/// resulting value is returned.
///
/// Data (pointed to by `data`, of length `len`) is encrypted/decrypted
/// in place. If `len` is not a multiple of 64, then the excess bytes from
/// the last block processing are dropped (therefore, "chunked" processing
/// works only as long as each non-final chunk has a length multiple of 64).
///
/// \param key    secret key (32 bytes).
/// \param iv     IV (12 bytes).
/// \param cc     initial counter value.
/// \param data   data to encrypt or decrypt.
/// \param len    data length (in bytes). 
 pub type br_chacha20_run = :: std :: option :: Option < unsafe extern "C" fn ( key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize ) -> u32 > ; extern "C" {
 
 /// \brief ChaCha20 implementation (straightforward C code, constant-time).
///
/// \see br_chacha20_run
///
/// \param key    secret key (32 bytes).
/// \param iv     IV (12 bytes).
/// \param cc     initial counter value.
/// \param data   data to encrypt or decrypt.
/// \param len    data length (in bytes). 
 
 pub fn br_chacha20_ct_run ( key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief ChaCha20 implementation (SSE2 code, constant-time).
///
/// This implementation is available only on x86 platforms, depending on
/// compiler support. Moreover, in 32-bit mode, it might not actually run,
/// if the underlying hardware does not implement the SSE2 opcode (in
/// 64-bit mode, SSE2 is part of the ABI, so if the code could be compiled
/// at all, then it can run). Use `br_chacha20_sse2_get()` to safely obtain
/// a pointer to that function.
///
/// \see br_chacha20_run
///
/// \param key    secret key (32 bytes).
/// \param iv     IV (12 bytes).
/// \param cc     initial counter value.
/// \param data   data to encrypt or decrypt.
/// \param len    data length (in bytes). 
 
 pub fn br_chacha20_sse2_run ( key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void , cc : u32 , data : * mut :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief Obtain the `sse2` ChaCha20 implementation, if available.
///
/// This function returns a pointer to `br_chacha20_sse2_run`, if
/// that implementation was compiled in the library _and_ the SSE2
/// opcodes are available on the currently running CPU. If either of
/// these conditions is not met, then this function returns `0`.
///
/// \return  the `sse2` ChaCha20 implementation, or `0`. 
 
 pub fn br_chacha20_sse2_get ( ) -> br_chacha20_run ; 
} 
 /// \brief Type for a ChaCha20+Poly1305 AEAD implementation.
///
/// The provided data is encrypted or decrypted with ChaCha20. The
/// authentication tag is computed on the concatenation of the
/// additional data and the ciphertext, with the padding and lengths
/// as described in RFC 7539 (section 2.8).
///
/// After decryption, the caller is responsible for checking that the
/// computed tag matches the expected value.
///
/// \param key       secret key (32 bytes).
/// \param iv        nonce (12 bytes).
/// \param data      data to encrypt or decrypt.
/// \param len       data length (in bytes).
/// \param aad       additional authenticated data.
/// \param aad_len   length of additional authenticated data (in bytes).
/// \param tag       output buffer for the authentication tag.
/// \param ichacha   implementation of ChaCha20.
/// \param encrypt   non-zero for encryption, zero for decryption. 
 pub type br_poly1305_run = :: std :: option :: Option < unsafe extern "C" fn ( key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , aad : * const :: std :: os :: raw :: c_void , aad_len : usize , tag : * mut :: std :: os :: raw :: c_void , ichacha : br_chacha20_run , encrypt : :: std :: os :: raw :: c_int ) > ; extern "C" {
 
 /// \brief ChaCha20+Poly1305 AEAD implementation (mixed 32-bit multiplications).
///
/// \see br_poly1305_run
///
/// \param key       secret key (32 bytes).
/// \param iv        nonce (12 bytes).
/// \param data      data to encrypt or decrypt.
/// \param len       data length (in bytes).
/// \param aad       additional authenticated data.
/// \param aad_len   length of additional authenticated data (in bytes).
/// \param tag       output buffer for the authentication tag.
/// \param ichacha   implementation of ChaCha20.
/// \param encrypt   non-zero for encryption, zero for decryption. 
 
 pub fn br_poly1305_ctmul_run ( key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , aad : * const :: std :: os :: raw :: c_void , aad_len : usize , tag : * mut :: std :: os :: raw :: c_void , ichacha : br_chacha20_run , encrypt : :: std :: os :: raw :: c_int , ) ; 
} extern "C" {
 
 /// \brief ChaCha20+Poly1305 AEAD implementation (pure 32-bit multiplications).
///
/// \see br_poly1305_run
///
/// \param key       secret key (32 bytes).
/// \param iv        nonce (12 bytes).
/// \param data      data to encrypt or decrypt.
/// \param len       data length (in bytes).
/// \param aad       additional authenticated data.
/// \param aad_len   length of additional authenticated data (in bytes).
/// \param tag       output buffer for the authentication tag.
/// \param ichacha   implementation of ChaCha20.
/// \param encrypt   non-zero for encryption, zero for decryption. 
 
 pub fn br_poly1305_ctmul32_run ( key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , aad : * const :: std :: os :: raw :: c_void , aad_len : usize , tag : * mut :: std :: os :: raw :: c_void , ichacha : br_chacha20_run , encrypt : :: std :: os :: raw :: c_int , ) ; 
} extern "C" {
 
 /// \brief ChaCha20+Poly1305 AEAD implementation (i15).
///
/// This implementation relies on the generic big integer code "i15"
/// (which uses pure 32-bit multiplications). As such, it may save a
/// little code footprint in a context where "i15" is already included
/// (e.g. for elliptic curves or for RSA); however, it is also
/// substantially slower than the ctmul and ctmul32 implementations.
///
/// \see br_poly1305_run
///
/// \param key       secret key (32 bytes).
/// \param iv        nonce (12 bytes).
/// \param data      data to encrypt or decrypt.
/// \param len       data length (in bytes).
/// \param aad       additional authenticated data.
/// \param aad_len   length of additional authenticated data (in bytes).
/// \param tag       output buffer for the authentication tag.
/// \param ichacha   implementation of ChaCha20.
/// \param encrypt   non-zero for encryption, zero for decryption. 
 
 pub fn br_poly1305_i15_run ( key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , aad : * const :: std :: os :: raw :: c_void , aad_len : usize , tag : * mut :: std :: os :: raw :: c_void , ichacha : br_chacha20_run , encrypt : :: std :: os :: raw :: c_int , ) ; 
} extern "C" {
 
 /// \brief ChaCha20+Poly1305 AEAD implementation (ctmulq).
///
/// This implementation uses 64-bit multiplications (result over 128 bits).
/// It is available only on platforms that offer such a primitive (in
/// practice, 64-bit architectures). Use `br_poly1305_ctmulq_get()` to
/// dynamically obtain a pointer to that function, or 0 if not supported.
///
/// \see br_poly1305_run
///
/// \param key       secret key (32 bytes).
/// \param iv        nonce (12 bytes).
/// \param data      data to encrypt or decrypt.
/// \param len       data length (in bytes).
/// \param aad       additional authenticated data.
/// \param aad_len   length of additional authenticated data (in bytes).
/// \param tag       output buffer for the authentication tag.
/// \param ichacha   implementation of ChaCha20.
/// \param encrypt   non-zero for encryption, zero for decryption. 
 
 pub fn br_poly1305_ctmulq_run ( key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , len : usize , aad : * const :: std :: os :: raw :: c_void , aad_len : usize , tag : * mut :: std :: os :: raw :: c_void , ichacha : br_chacha20_run , encrypt : :: std :: os :: raw :: c_int , ) ; 
} extern "C" {
 
 /// \brief Get the ChaCha20+Poly1305 "ctmulq" implementation, if available.
///
/// This function returns a pointer to the `br_poly1305_ctmulq_run()`
/// function if supported on the current platform; otherwise, it returns 0.
///
/// \return  the ctmulq ChaCha20+Poly1305 implementation, or 0. 
 
 pub fn br_poly1305_ctmulq_get ( ) -> br_poly1305_run ; 
} 
 /// \brief Class type of an AEAD algorithm. 
 pub type br_aead_class = br_aead_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_aead_class_ { 
 /// \brief Size (in bytes) of authentication tags created by
    /// this AEAD algorithm. 
 pub tag_size : usize , 
 /// \brief Reset an AEAD context.
    ///
    /// This function resets an already initialised AEAD context for
    /// a new computation run. Implementations and keys are
    /// conserved. This function can be called at any time; it
    /// cancels any ongoing AEAD computation that uses the provided
    /// context structure.
    ///
    /// The provided IV is a _nonce_. Each AEAD algorithm has its
    /// own requirements on IV size and contents; for most of them,
    /// it is crucial to security that each nonce value is used
    /// only once for a given secret key.
    ///
    /// \param cc    AEAD context structure.
    /// \param iv    AEAD nonce to use.
    /// \param len   AEAD nonce length (in bytes). 
 pub reset : :: std :: option :: Option < unsafe extern "C" fn ( cc : * mut * const br_aead_class , iv : * const :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Inject additional authenticated data.
    ///
    /// The provided data is injected into a running AEAD
    /// computation. Additional data must be injected _before_ the
    /// call to `flip()`. Additional data can be injected in several
    /// chunks of arbitrary length.
    ///
    /// \param cc     AEAD context structure.
    /// \param data   pointer to additional authenticated data.
    /// \param len    length of additional authenticated data (in bytes). 
 pub aad_inject : :: std :: option :: Option < unsafe extern "C" fn ( cc : * mut * const br_aead_class , data : * const :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Finish injection of additional authenticated data.
    ///
    /// This function MUST be called before beginning the actual
    /// encryption or decryption (with `run()`), even if no
    /// additional authenticated data was injected. No additional
    /// authenticated data may be injected after this function call.
    ///
    /// \param cc   AEAD context structure. 
 pub flip : :: std :: option :: Option < unsafe extern "C" fn ( cc : * mut * const br_aead_class ) > , 
 /// \brief Encrypt or decrypt some data.
    ///
    /// Data encryption or decryption can be done after `flip()` has
    /// been called on the context. If `encrypt` is non-zero, then
    /// the provided data shall be plaintext, and it is encrypted in
    /// place. Otherwise, the data shall be ciphertext, and it is
    /// decrypted in place.
    ///
    /// Data may be provided in several chunks of arbitrary length.
    ///
    /// \param cc        AEAD context structure.
    /// \param encrypt   non-zero for encryption, zero for decryption.
    /// \param data      data to encrypt or decrypt.
    /// \param len       data length (in bytes). 
 pub run : :: std :: option :: Option < unsafe extern "C" fn ( cc : * mut * const br_aead_class , encrypt : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Compute authentication tag.
    ///
    /// Compute the AEAD authentication tag. The tag length depends
    /// on the AEAD algorithm; it is written in the provided `tag`
    /// buffer. This call terminates the AEAD run: no data may be
    /// processed with that AEAD context afterwards, until `reset()`
    /// is called to initiate a new AEAD run.
    ///
    /// The tag value must normally be sent along with the encrypted
    /// data. When decrypting, the tag value must be recomputed and
    /// compared with the received tag: if the two tag values differ,
    /// then either the tag or the encrypted data was altered in
    /// transit. As an alternative to this function, the
    /// `check_tag()` function may be used to compute and check the
    /// tag value.
    ///
    /// Tag length depends on the AEAD algorithm.
    ///
    /// \param cc    AEAD context structure.
    /// \param tag   destination buffer for the tag. 
 pub get_tag : :: std :: option :: Option < unsafe extern "C" fn ( cc : * mut * const br_aead_class , tag : * mut :: std :: os :: raw :: c_void ) > , 
 /// \brief Compute and check authentication tag.
    ///
    /// This function is an alternative to `get_tag()`, and is
    /// normally used on the receiving end (i.e. when decrypting
    /// messages). The tag value is recomputed and compared with the
    /// provided tag value. If they match, 1 is returned; on
    /// mismatch, 0 is returned. A returned value of 0 means that the
    /// data or the tag was altered in transit, normally leading to
    /// wholesale rejection of the complete message.
    ///
    /// Tag length depends on the AEAD algorithm.
    ///
    /// \param cc    AEAD context structure.
    /// \param tag   tag value to compare with.
    /// \return  1 on success (exact match of tag value), 0 otherwise. 
 pub check_tag : :: std :: option :: Option < unsafe extern "C" fn ( cc : * mut * const br_aead_class , tag : * const :: std :: os :: raw :: c_void ) -> u32 > , 
 /// \brief Compute authentication tag (with truncation).
    ///
    /// This function is similar to `get_tag()`, except that the tag
    /// length is provided. Some AEAD algorithms allow several tag
    /// lengths, usually by truncating the normal tag. Shorter tags
    /// mechanically increase success probability of forgeries.
    /// The range of allowed tag lengths depends on the algorithm.
    ///
    /// \param cc    AEAD context structure.
    /// \param tag   destination buffer for the tag.
    /// \param len   tag length (in bytes). 
 pub get_tag_trunc : :: std :: option :: Option < unsafe extern "C" fn ( cc : * mut * const br_aead_class , tag : * mut :: std :: os :: raw :: c_void , len : usize ) > , 
 /// \brief Compute and check authentication tag (with truncation).
    ///
    /// This function is similar to `check_tag()` except that it
    /// works over an explicit tag length. See `get_tag()` for a
    /// discussion of explicit tag lengths; the range of allowed tag
    /// lengths depends on the algorithm.
    ///
    /// \param cc    AEAD context structure.
    /// \param tag   tag value to compare with.
    /// \param len   tag length (in bytes).
    /// \return  1 on success (exact match of tag value), 0 otherwise. 
 pub check_tag_trunc : :: std :: option :: Option < unsafe extern "C" fn ( cc : * mut * const br_aead_class , tag : * const :: std :: os :: raw :: c_void , len : usize ) -> u32 > , } # [ test ] fn bindgen_test_layout_br_aead_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_aead_class_ > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( br_aead_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_aead_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_aead_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . tag_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( tag_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . reset as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( reset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . aad_inject as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( aad_inject ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . flip as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( flip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . run as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( run ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . get_tag as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( get_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . check_tag as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( check_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . get_tag_trunc as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( get_tag_trunc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_aead_class_ > ( ) ) ) . check_tag_trunc as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( br_aead_class_ ) , "::" , stringify ! ( check_tag_trunc ) ) ) ; } 
 /// \brief Context structure for GCM.
///
/// GCM is an AEAD mode that combines a block cipher in CTR mode with a
/// MAC based on GHASH, to provide authenticated encryption:
///
/// - Any block cipher with 16-byte blocks can be used with GCM.
///
/// - The nonce can have any length, from 0 up to 2^64-1 bits; however,
/// 96-bit nonces (12 bytes) are recommended (nonces with a length
/// distinct from 12 bytes are internally hashed, which risks reusing
/// nonce value with a small but not always negligible probability).
///
/// - Additional authenticated data may have length up to 2^64-1 bits.
///
/// - Message length may range up to 2^39-256 bits at most.
///
/// - The authentication tag has length 16 bytes.
///
/// The GCM initialisation function receives as parameter an
/// _initialised_ block cipher implementation context, with the secret
/// key already set. A pointer to that context will be kept within the
/// GCM context structure. It is up to the caller to allocate and
/// initialise that block cipher context. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_gcm_context { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_aead_class , pub bctx : * mut * const br_block_ctr_class , pub gh : br_ghash , pub h : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub j0_1 : [ :: std :: os :: raw :: c_uchar ; 12usize ] , pub buf : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub y : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub j0_2 : u32 , pub jc : u32 , pub count_aad : u64 , pub count_ctr : u64 , } # [ test ] fn bindgen_test_layout_br_gcm_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_gcm_context > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( br_gcm_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_gcm_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_gcm_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . bctx as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( bctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . gh as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( gh ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . h as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( h ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . j0_1 as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( j0_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . buf as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . y as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . j0_2 as * const _ as usize } , 84usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( j0_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . jc as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( jc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . count_aad as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( count_aad ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_gcm_context > ( ) ) ) . count_ctr as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( br_gcm_context ) , "::" , stringify ! ( count_ctr ) ) ) ; } extern "C" {
 
 /// \brief Initialize a GCM context.
///
/// A block cipher implementation, with its initialised context structure,
/// is provided. The block cipher MUST use 16-byte blocks in CTR mode,
/// and its secret key MUST have been already set in the provided context.
/// A GHASH implementation must also be provided. The parameters are linked
/// in the GCM context.
///
/// After this function has been called, the `br_gcm_reset()` function must
/// be called, to provide the IV for GCM computation.
///
/// \param ctx    GCM context structure.
/// \param bctx   block cipher context (already initialised with secret key).
/// \param gh     GHASH implementation. 
 
 pub fn br_gcm_init ( ctx : * mut br_gcm_context , bctx : * mut * const br_block_ctr_class , gh : br_ghash , ) ; 
} extern "C" {
 
 /// \brief Reset a GCM context.
///
/// This function resets an already initialised GCM context for a new
/// computation run. Implementations and keys are conserved. This function
/// can be called at any time; it cancels any ongoing GCM computation that
/// uses the provided context structure.
///
/// The provided IV is a _nonce_. It is critical to GCM security that IV
/// values are not repeated for the same encryption key. IV can have
/// arbitrary length (up to 2^64-1 bits), but the "normal" length is
/// 96 bits (12 bytes).
///
/// \param ctx   GCM context structure.
/// \param iv    GCM nonce to use.
/// \param len   GCM nonce length (in bytes). 
 
 pub fn br_gcm_reset ( ctx : * mut br_gcm_context , iv : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Inject additional authenticated data into GCM.
///
/// The provided data is injected into a running GCM computation. Additional
/// data must be injected _before_ the call to `br_gcm_flip()`.
/// Additional data can be injected in several chunks of arbitrary length;
/// the maximum total size of additional authenticated data is 2^64-1
/// bits.
///
/// \param ctx    GCM context structure.
/// \param data   pointer to additional authenticated data.
/// \param len    length of additional authenticated data (in bytes). 
 
 pub fn br_gcm_aad_inject ( ctx : * mut br_gcm_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Finish injection of additional authenticated data into GCM.
///
/// This function MUST be called before beginning the actual encryption
/// or decryption (with `br_gcm_run()`), even if no additional authenticated
/// data was injected. No additional authenticated data may be injected
/// after this function call.
///
/// \param ctx   GCM context structure. 
 
 pub fn br_gcm_flip ( ctx : * mut br_gcm_context , ) ; 
} extern "C" {
 
 /// \brief Encrypt or decrypt some data with GCM.
///
/// Data encryption or decryption can be done after `br_gcm_flip()`
/// has been called on the context. If `encrypt` is non-zero, then the
/// provided data shall be plaintext, and it is encrypted in place.
/// Otherwise, the data shall be ciphertext, and it is decrypted in place.
///
/// Data may be provided in several chunks of arbitrary length. The maximum
/// total length for data is 2^39-256 bits, i.e. about 65 gigabytes.
///
/// \param ctx       GCM context structure.
/// \param encrypt   non-zero for encryption, zero for decryption.
/// \param data      data to encrypt or decrypt.
/// \param len       data length (in bytes). 
 
 pub fn br_gcm_run ( ctx : * mut br_gcm_context , encrypt : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute GCM authentication tag.
///
/// Compute the GCM authentication tag. The tag is a 16-byte value which
/// is written in the provided `tag` buffer. This call terminates the
/// GCM run: no data may be processed with that GCM context afterwards,
/// until `br_gcm_reset()` is called to initiate a new GCM run.
///
/// The tag value must normally be sent along with the encrypted data.
/// When decrypting, the tag value must be recomputed and compared with
/// the received tag: if the two tag values differ, then either the tag
/// or the encrypted data was altered in transit. As an alternative to
/// this function, the `br_gcm_check_tag()` function can be used to
/// compute and check the tag value.
///
/// \param ctx   GCM context structure.
/// \param tag   destination buffer for the tag (16 bytes). 
 
 pub fn br_gcm_get_tag ( ctx : * mut br_gcm_context , tag : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Compute and check GCM authentication tag.
///
/// This function is an alternative to `br_gcm_get_tag()`, normally used
/// on the receiving end (i.e. when decrypting value). The tag value is
/// recomputed and compared with the provided tag value. If they match, 1
/// is returned; on mismatch, 0 is returned. A returned value of 0 means
/// that the data or the tag was altered in transit, normally leading to
/// wholesale rejection of the complete message.
///
/// \param ctx   GCM context structure.
/// \param tag   tag value to compare with (16 bytes).
/// \return  1 on success (exact match of tag value), 0 otherwise. 
 
 pub fn br_gcm_check_tag ( ctx : * mut br_gcm_context , tag : * const :: std :: os :: raw :: c_void , ) -> u32 ; 
} extern "C" {
 
 /// \brief Compute GCM authentication tag (with truncation).
///
/// This function is similar to `br_gcm_get_tag()`, except that it allows
/// the tag to be truncated to a smaller length. The intended tag length
/// is provided as `len` (in bytes); it MUST be no more than 16, but
/// it may be smaller. Note that decreasing tag length mechanically makes
/// forgeries easier; NIST SP 800-38D specifies that the tag length shall
/// lie between 12 and 16 bytes (inclusive), but may be truncated down to
/// 4 or 8 bytes, for specific applications that can tolerate it. It must
/// also be noted that successful forgeries leak information on the
/// authentication key, making subsequent forgeries easier. Therefore,
/// tag truncation, and in particular truncation to sizes lower than 12
/// bytes, shall be envisioned only with great care.
///
/// The tag is written in the provided `tag` buffer. This call terminates
/// the GCM run: no data may be processed with that GCM context
/// afterwards, until `br_gcm_reset()` is called to initiate a new GCM
/// run.
///
/// The tag value must normally be sent along with the encrypted data.
/// When decrypting, the tag value must be recomputed and compared with
/// the received tag: if the two tag values differ, then either the tag
/// or the encrypted data was altered in transit. As an alternative to
/// this function, the `br_gcm_check_tag_trunc()` function can be used to
/// compute and check the tag value.
///
/// \param ctx   GCM context structure.
/// \param tag   destination buffer for the tag.
/// \param len   tag length (16 bytes or less). 
 
 pub fn br_gcm_get_tag_trunc ( ctx : * mut br_gcm_context , tag : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute and check GCM authentication tag (with truncation).
///
/// This function is an alternative to `br_gcm_get_tag_trunc()`, normally used
/// on the receiving end (i.e. when decrypting value). The tag value is
/// recomputed and compared with the provided tag value. If they match, 1
/// is returned; on mismatch, 0 is returned. A returned value of 0 means
/// that the data or the tag was altered in transit, normally leading to
/// wholesale rejection of the complete message.
///
/// Tag length MUST be 16 bytes or less. The normal GCM tag length is 16
/// bytes. See `br_check_tag_trunc()` for some discussion on the potential
/// perils of truncating authentication tags.
///
/// \param ctx   GCM context structure.
/// \param tag   tag value to compare with.
/// \param len   tag length (in bytes).
/// \return  1 on success (exact match of tag value), 0 otherwise. 
 
 pub fn br_gcm_check_tag_trunc ( ctx : * mut br_gcm_context , tag : * const :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 # [ link_name = "\u{1}br_gcm_vtable" ] 
 pub static mut  br_gcm_vtable  :  br_aead_class ;
} 
 /// \brief Context structure for EAX.
///
/// EAX is an AEAD mode that combines a block cipher in CTR mode with
/// CBC-MAC using the same block cipher and the same key, to provide
/// authenticated encryption:
///
/// - Any block cipher with 16-byte blocks can be used with EAX
/// (technically, other block sizes are defined as well, but this
/// is not implemented by these functions; shorter blocks also
/// imply numerous security issues).
///
/// - The nonce can have any length, as long as nonce values are
/// not reused (thus, if nonces are randomly selected, the nonce
/// size should be such that reuse probability is negligible).
///
/// - Additional authenticated data length is unlimited.
///
/// - Message length is unlimited.
///
/// - The authentication tag has length 16 bytes.
///
/// The EAX initialisation function receives as parameter an
/// _initialised_ block cipher implementation context, with the secret
/// key already set. A pointer to that context will be kept within the
/// EAX context structure. It is up to the caller to allocate and
/// initialise that block cipher context. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_eax_context { 
 /// \brief Pointer to vtable for this context. 
 pub vtable : * const br_aead_class , pub bctx : * mut * const br_block_ctrcbc_class , pub L2 : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub L4 : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub nonce : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub head : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub ctr : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub cbcmac : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub buf : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub ptr : usize , } # [ test ] fn bindgen_test_layout_br_eax_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_eax_context > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( br_eax_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_eax_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_eax_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . bctx as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( bctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . L2 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( L2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . L4 as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( L4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . nonce as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( nonce ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . head as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( head ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . ctr as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( ctr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . cbcmac as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( cbcmac ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . buf as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_context > ( ) ) ) . ptr as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_context ) , "::" , stringify ! ( ptr ) ) ) ; } 
 /// \brief EAX captured state.
///
/// Some internal values computed by EAX may be captured at various
/// points, and reused for another EAX run with the same secret key,
/// for lower per-message overhead. Captured values do not depend on
/// the nonce. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_eax_state { pub st : [ [ :: std :: os :: raw :: c_uchar ; 16usize ] ; 3usize ] , } # [ test ] fn bindgen_test_layout_br_eax_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_eax_state > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( br_eax_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_eax_state > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( br_eax_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_eax_state > ( ) ) ) . st as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_eax_state ) , "::" , stringify ! ( st ) ) ) ; } extern "C" {
 
 /// \brief Initialize an EAX context.
///
/// A block cipher implementation, with its initialised context
/// structure, is provided. The block cipher MUST use 16-byte blocks in
/// CTR + CBC-MAC mode, and its secret key MUST have been already set in
/// the provided context. The parameters are linked in the EAX context.
///
/// After this function has been called, the `br_eax_reset()` function must
/// be called, to provide the nonce for EAX computation.
///
/// \param ctx    EAX context structure.
/// \param bctx   block cipher context (already initialised with secret key). 
 
 pub fn br_eax_init ( ctx : * mut br_eax_context , bctx : * mut * const br_block_ctrcbc_class , ) ; 
} extern "C" {
 
 /// \brief Capture pre-AAD state.
///
/// This function precomputes key-dependent data, and stores it in the
/// provided `st` structure. This structure should then be used with
/// `br_eax_reset_pre_aad()`, or updated with `br_eax_get_aad_mac()`
/// and then used with `br_eax_reset_post_aad()`.
///
/// The EAX context structure is unmodified by this call.
///
/// \param ctx   EAX context structure.
/// \param st    recipient for captured state. 
 
 pub fn br_eax_capture ( ctx : * const br_eax_context , st : * mut br_eax_state , ) ; 
} extern "C" {
 
 /// \brief Reset an EAX context.
///
/// This function resets an already initialised EAX context for a new
/// computation run. Implementations and keys are conserved. This function
/// can be called at any time; it cancels any ongoing EAX computation that
/// uses the provided context structure.
///
/// It is critical to EAX security that nonce values are not repeated for
/// the same encryption key. Nonces can have arbitrary length. If nonces
/// are randomly generated, then a nonce length of at least 128 bits (16
/// bytes) is recommended, to make nonce reuse probability sufficiently
/// low.
///
/// \param ctx     EAX context structure.
/// \param nonce   EAX nonce to use.
/// \param len     EAX nonce length (in bytes). 
 
 pub fn br_eax_reset ( ctx : * mut br_eax_context , nonce : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Reset an EAX context with a pre-AAD captured state.
///
/// This function is an alternative to `br_eax_reset()`, that reuses a
/// previously captured state structure for lower per-message overhead.
/// The state should have been populated with `br_eax_capture_state()`
/// but not updated with `br_eax_get_aad_mac()`.
///
/// After this function is called, additional authenticated data MUST
/// be injected. At least one byte of additional authenticated data
/// MUST be provided with `br_eax_aad_inject()`; computation result will
/// be incorrect if `br_eax_flip()` is called right away.
///
/// After injection of the AAD and call to `br_eax_flip()`, at least
/// one message byte must be provided. Empty messages are not supported
/// with this reset mode.
///
/// \param ctx     EAX context structure.
/// \param st      pre-AAD captured state.
/// \param nonce   EAX nonce to use.
/// \param len     EAX nonce length (in bytes). 
 
 pub fn br_eax_reset_pre_aad ( ctx : * mut br_eax_context , st : * const br_eax_state , nonce : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Reset an EAX context with a post-AAD captured state.
///
/// This function is an alternative to `br_eax_reset()`, that reuses a
/// previously captured state structure for lower per-message overhead.
/// The state should have been populated with `br_eax_capture_state()`
/// and then updated with `br_eax_get_aad_mac()`.
///
/// After this function is called, message data MUST be injected. The
/// `br_eax_flip()` function MUST NOT be called. At least one byte of
/// message data MUST be provided with `br_eax_run()`; empty messages
/// are not supported with this reset mode.
///
/// \param ctx     EAX context structure.
/// \param st      post-AAD captured state.
/// \param nonce   EAX nonce to use.
/// \param len     EAX nonce length (in bytes). 
 
 pub fn br_eax_reset_post_aad ( ctx : * mut br_eax_context , st : * const br_eax_state , nonce : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Inject additional authenticated data into EAX.
///
/// The provided data is injected into a running EAX computation. Additional
/// data must be injected _before_ the call to `br_eax_flip()`.
/// Additional data can be injected in several chunks of arbitrary length;
/// the total amount of additional authenticated data is unlimited.
///
/// \param ctx    EAX context structure.
/// \param data   pointer to additional authenticated data.
/// \param len    length of additional authenticated data (in bytes). 
 
 pub fn br_eax_aad_inject ( ctx : * mut br_eax_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Finish injection of additional authenticated data into EAX.
///
/// This function MUST be called before beginning the actual encryption
/// or decryption (with `br_eax_run()`), even if no additional authenticated
/// data was injected. No additional authenticated data may be injected
/// after this function call.
///
/// \param ctx   EAX context structure. 
 
 pub fn br_eax_flip ( ctx : * mut br_eax_context , ) ; 
} extern "C" {
 
 /// \brief Encrypt or decrypt some data with EAX.
///
/// Data encryption or decryption can be done after `br_eax_flip()`
/// has been called on the context. If `encrypt` is non-zero, then the
/// provided data shall be plaintext, and it is encrypted in place.
/// Otherwise, the data shall be ciphertext, and it is decrypted in place.
///
/// Data may be provided in several chunks of arbitrary length.
///
/// \param ctx       EAX context structure.
/// \param encrypt   non-zero for encryption, zero for decryption.
/// \param data      data to encrypt or decrypt.
/// \param len       data length (in bytes). 
 
 pub fn br_eax_run ( ctx : * mut br_eax_context , encrypt : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute EAX authentication tag.
///
/// Compute the EAX authentication tag. The tag is a 16-byte value which
/// is written in the provided `tag` buffer. This call terminates the
/// EAX run: no data may be processed with that EAX context afterwards,
/// until `br_eax_reset()` is called to initiate a new EAX run.
///
/// The tag value must normally be sent along with the encrypted data.
/// When decrypting, the tag value must be recomputed and compared with
/// the received tag: if the two tag values differ, then either the tag
/// or the encrypted data was altered in transit. As an alternative to
/// this function, the `br_eax_check_tag()` function can be used to
/// compute and check the tag value.
///
/// \param ctx   EAX context structure.
/// \param tag   destination buffer for the tag (16 bytes). 
 
 pub fn br_eax_get_tag ( ctx : * mut br_eax_context , tag : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Compute and check EAX authentication tag.
///
/// This function is an alternative to `br_eax_get_tag()`, normally used
/// on the receiving end (i.e. when decrypting value). The tag value is
/// recomputed and compared with the provided tag value. If they match, 1
/// is returned; on mismatch, 0 is returned. A returned value of 0 means
/// that the data or the tag was altered in transit, normally leading to
/// wholesale rejection of the complete message.
///
/// \param ctx   EAX context structure.
/// \param tag   tag value to compare with (16 bytes).
/// \return  1 on success (exact match of tag value), 0 otherwise. 
 
 pub fn br_eax_check_tag ( ctx : * mut br_eax_context , tag : * const :: std :: os :: raw :: c_void , ) -> u32 ; 
} extern "C" {
 
 /// \brief Compute EAX authentication tag (with truncation).
///
/// This function is similar to `br_eax_get_tag()`, except that it allows
/// the tag to be truncated to a smaller length. The intended tag length
/// is provided as `len` (in bytes); it MUST be no more than 16, but
/// it may be smaller. Note that decreasing tag length mechanically makes
/// forgeries easier; NIST SP 800-38D specifies that the tag length shall
/// lie between 12 and 16 bytes (inclusive), but may be truncated down to
/// 4 or 8 bytes, for specific applications that can tolerate it. It must
/// also be noted that successful forgeries leak information on the
/// authentication key, making subsequent forgeries easier. Therefore,
/// tag truncation, and in particular truncation to sizes lower than 12
/// bytes, shall be envisioned only with great care.
///
/// The tag is written in the provided `tag` buffer. This call terminates
/// the EAX run: no data may be processed with that EAX context
/// afterwards, until `br_eax_reset()` is called to initiate a new EAX
/// run.
///
/// The tag value must normally be sent along with the encrypted data.
/// When decrypting, the tag value must be recomputed and compared with
/// the received tag: if the two tag values differ, then either the tag
/// or the encrypted data was altered in transit. As an alternative to
/// this function, the `br_eax_check_tag_trunc()` function can be used to
/// compute and check the tag value.
///
/// \param ctx   EAX context structure.
/// \param tag   destination buffer for the tag.
/// \param len   tag length (16 bytes or less). 
 
 pub fn br_eax_get_tag_trunc ( ctx : * mut br_eax_context , tag : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute and check EAX authentication tag (with truncation).
///
/// This function is an alternative to `br_eax_get_tag_trunc()`, normally used
/// on the receiving end (i.e. when decrypting value). The tag value is
/// recomputed and compared with the provided tag value. If they match, 1
/// is returned; on mismatch, 0 is returned. A returned value of 0 means
/// that the data or the tag was altered in transit, normally leading to
/// wholesale rejection of the complete message.
///
/// Tag length MUST be 16 bytes or less. The normal EAX tag length is 16
/// bytes. See `br_check_tag_trunc()` for some discussion on the potential
/// perils of truncating authentication tags.
///
/// \param ctx   EAX context structure.
/// \param tag   tag value to compare with.
/// \param len   tag length (in bytes).
/// \return  1 on success (exact match of tag value), 0 otherwise. 
 
 pub fn br_eax_check_tag_trunc ( ctx : * mut br_eax_context , tag : * const :: std :: os :: raw :: c_void , len : usize , ) -> u32 ; 
} extern "C" {
 # [ link_name = "\u{1}br_eax_vtable" ] 
 pub static mut  br_eax_vtable  :  br_aead_class ;
} 
 /// \brief Context structure for CCM.
///
/// CCM is an AEAD mode that combines a block cipher in CTR mode with
/// CBC-MAC using the same block cipher and the same key, to provide
/// authenticated encryption:
///
/// - Any block cipher with 16-byte blocks can be used with CCM
/// (technically, other block sizes are defined as well, but this
/// is not implemented by these functions; shorter blocks also
/// imply numerous security issues).
///
/// - The authentication tag length, and plaintext length, MUST be
/// known when starting processing data. Plaintext and ciphertext
/// can still be provided by chunks, but the total size must match
/// the value provided upon initialisation.
///
/// - The nonce length is constrained betwen 7 and 13 bytes (inclusive).
/// Furthermore, the plaintext length, when encoded, must fit over
/// 15-nonceLen bytes; thus, if the nonce has length 13 bytes, then
/// the plaintext length cannot exceed 65535 bytes.
///
/// - Additional authenticated data length is practically unlimited
/// (formal limit is at 2^64 bytes).
///
/// - The authentication tag has length 4 to 16 bytes (even values only).
///
/// The CCM initialisation function receives as parameter an
/// _initialised_ block cipher implementation context, with the secret
/// key already set. A pointer to that context will be kept within the
/// CCM context structure. It is up to the caller to allocate and
/// initialise that block cipher context. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ccm_context { pub bctx : * mut * const br_block_ctrcbc_class , pub ctr : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub cbcmac : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub tagmask : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub buf : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub ptr : usize , pub tag_len : usize , } # [ test ] fn bindgen_test_layout_br_ccm_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ccm_context > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( br_ccm_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ccm_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ccm_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ccm_context > ( ) ) ) . bctx as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ccm_context ) , "::" , stringify ! ( bctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ccm_context > ( ) ) ) . ctr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ccm_context ) , "::" , stringify ! ( ctr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ccm_context > ( ) ) ) . cbcmac as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ccm_context ) , "::" , stringify ! ( cbcmac ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ccm_context > ( ) ) ) . tagmask as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_ccm_context ) , "::" , stringify ! ( tagmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ccm_context > ( ) ) ) . buf as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( br_ccm_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ccm_context > ( ) ) ) . ptr as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_ccm_context ) , "::" , stringify ! ( ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ccm_context > ( ) ) ) . tag_len as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_ccm_context ) , "::" , stringify ! ( tag_len ) ) ) ; } extern "C" {
 
 /// \brief Initialize a CCM context.
///
/// A block cipher implementation, with its initialised context
/// structure, is provided. The block cipher MUST use 16-byte blocks in
/// CTR + CBC-MAC mode, and its secret key MUST have been already set in
/// the provided context. The parameters are linked in the CCM context.
///
/// After this function has been called, the `br_ccm_reset()` function must
/// be called, to provide the nonce for CCM computation.
///
/// \param ctx    CCM context structure.
/// \param bctx   block cipher context (already initialised with secret key). 
 
 pub fn br_ccm_init ( ctx : * mut br_ccm_context , bctx : * mut * const br_block_ctrcbc_class , ) ; 
} extern "C" {
 
 /// \brief Reset a CCM context.
///
/// This function resets an already initialised CCM context for a new
/// computation run. Implementations and keys are conserved. This function
/// can be called at any time; it cancels any ongoing CCM computation that
/// uses the provided context structure.
///
/// The `aad_len` parameter contains the total length, in bytes, of the
/// additional authenticated data. It may be zero. That length MUST be
/// exact.
///
/// The `data_len` parameter contains the total length, in bytes, of the
/// data that will be injected (plaintext or ciphertext). That length MUST
/// be exact. Moreover, that length MUST be less than 2^(8*(15-nonce_len)).
///
/// The nonce length (`nonce_len`), in bytes, must be in the 7..13 range
/// (inclusive).
///
/// The tag length (`tag_len`), in bytes, must be in the 4..16 range, and
/// be an even integer. Short tags mechanically allow for higher forgery
/// probabilities; hence, tag sizes smaller than 12 bytes shall be used only
/// with care.
///
/// It is critical to CCM security that nonce values are not repeated for
/// the same encryption key. Random generation of nonces is not generally
/// recommended, due to the relatively small maximum nonce value.
///
/// Returned value is 1 on success, 0 on error. An error is reported if
/// the tag or nonce length is out of range, or if the
/// plaintext/ciphertext length cannot be encoded with the specified
/// nonce length.
///
/// \param ctx         CCM context structure.
/// \param nonce       CCM nonce to use.
/// \param nonce_len   CCM nonce length (in bytes, 7 to 13).
/// \param aad_len     additional authenticated data length (in bytes).
/// \param data_len    plaintext/ciphertext length (in bytes).
/// \param tag_len     tag length (in bytes).
/// \return  1 on success, 0 on error. 
 
 pub fn br_ccm_reset ( ctx : * mut br_ccm_context , nonce : * const :: std :: os :: raw :: c_void , nonce_len : usize , aad_len : u64 , data_len : u64 , tag_len : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Inject additional authenticated data into CCM.
///
/// The provided data is injected into a running CCM computation. Additional
/// data must be injected _before_ the call to `br_ccm_flip()`.
/// Additional data can be injected in several chunks of arbitrary length,
/// but the total amount MUST exactly match the value which was provided
/// to `br_ccm_reset()`.
///
/// \param ctx    CCM context structure.
/// \param data   pointer to additional authenticated data.
/// \param len    length of additional authenticated data (in bytes). 
 
 pub fn br_ccm_aad_inject ( ctx : * mut br_ccm_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Finish injection of additional authenticated data into CCM.
///
/// This function MUST be called before beginning the actual encryption
/// or decryption (with `br_ccm_run()`), even if no additional authenticated
/// data was injected. No additional authenticated data may be injected
/// after this function call.
///
/// \param ctx   CCM context structure. 
 
 pub fn br_ccm_flip ( ctx : * mut br_ccm_context , ) ; 
} extern "C" {
 
 /// \brief Encrypt or decrypt some data with CCM.
///
/// Data encryption or decryption can be done after `br_ccm_flip()`
/// has been called on the context. If `encrypt` is non-zero, then the
/// provided data shall be plaintext, and it is encrypted in place.
/// Otherwise, the data shall be ciphertext, and it is decrypted in place.
///
/// Data may be provided in several chunks of arbitrary length, provided
/// that the total length exactly matches the length provided to the
/// `br_ccm_reset()` call.
///
/// \param ctx       CCM context structure.
/// \param encrypt   non-zero for encryption, zero for decryption.
/// \param data      data to encrypt or decrypt.
/// \param len       data length (in bytes). 
 
 pub fn br_ccm_run ( ctx : * mut br_ccm_context , encrypt : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Compute CCM authentication tag.
///
/// Compute the CCM authentication tag. This call terminates the CCM
/// run: all data must have been injected with `br_ccm_run()` (in zero,
/// one or more successive calls). After this function has been called,
/// no more data can br processed; a `br_ccm_reset()` call is required
/// to start a new message.
///
/// The tag length was provided upon context initialisation (last call
/// to `br_ccm_reset()`); it is returned by this function.
///
/// The tag value must normally be sent along with the encrypted data.
/// When decrypting, the tag value must be recomputed and compared with
/// the received tag: if the two tag values differ, then either the tag
/// or the encrypted data was altered in transit. As an alternative to
/// this function, the `br_ccm_check_tag()` function can be used to
/// compute and check the tag value.
///
/// \param ctx   CCM context structure.
/// \param tag   destination buffer for the tag (up to 16 bytes).
/// \return  the tag length (in bytes). 
 
 pub fn br_ccm_get_tag ( ctx : * mut br_ccm_context , tag : * mut :: std :: os :: raw :: c_void , ) -> usize ; 
} extern "C" {
 
 /// \brief Compute and check CCM authentication tag.
///
/// This function is an alternative to `br_ccm_get_tag()`, normally used
/// on the receiving end (i.e. when decrypting value). The tag value is
/// recomputed and compared with the provided tag value. If they match, 1
/// is returned; on mismatch, 0 is returned. A returned value of 0 means
/// that the data or the tag was altered in transit, normally leading to
/// wholesale rejection of the complete message.
///
/// \param ctx   CCM context structure.
/// \param tag   tag value to compare with (up to 16 bytes).
/// \return  1 on success (exact match of tag value), 0 otherwise. 
 
 pub fn br_ccm_check_tag ( ctx : * mut br_ccm_context , tag : * const :: std :: os :: raw :: c_void , ) -> u32 ; 
} 
 /// \brief RSA public key.
///
/// The structure references the modulus and the public exponent. Both
/// integers use unsigned big-endian representation; extra leading bytes
/// of value 0 are allowed. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_rsa_public_key { 
 /// \brief Modulus. 
 pub n : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief Modulus length (in bytes). 
 pub nlen : usize , 
 /// \brief Public exponent. 
 pub e : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief Public exponent length (in bytes). 
 pub elen : usize , } # [ test ] fn bindgen_test_layout_br_rsa_public_key ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_rsa_public_key > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_rsa_public_key ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_rsa_public_key > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_rsa_public_key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_public_key > ( ) ) ) . n as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_public_key ) , "::" , stringify ! ( n ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_public_key > ( ) ) ) . nlen as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_public_key ) , "::" , stringify ! ( nlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_public_key > ( ) ) ) . e as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_public_key ) , "::" , stringify ! ( e ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_public_key > ( ) ) ) . elen as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_public_key ) , "::" , stringify ! ( elen ) ) ) ; } 
 /// \brief RSA private key.
///
/// The structure references the primvate factors, reduced private
/// exponents, and CRT coefficient. It also contains the bit length of
/// the modulus. The big integers use unsigned big-endian representation;
/// extra leading bytes of value 0 are allowed. However, the modulus bit
/// length (`n_bitlen`) MUST be exact. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_rsa_private_key { 
 /// \brief Modulus bit length (in bits, exact value). 
 pub n_bitlen : u32 , 
 /// \brief First prime factor. 
 pub p : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief First prime factor length (in bytes). 
 pub plen : usize , 
 /// \brief Second prime factor. 
 pub q : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief Second prime factor length (in bytes). 
 pub qlen : usize , 
 /// \brief First reduced private exponent. 
 pub dp : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief First reduced private exponent length (in bytes). 
 pub dplen : usize , 
 /// \brief Second reduced private exponent. 
 pub dq : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief Second reduced private exponent length (in bytes). 
 pub dqlen : usize , 
 /// \brief CRT coefficient. 
 pub iq : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief CRT coefficient length (in bytes). 
 pub iqlen : usize , } # [ test ] fn bindgen_test_layout_br_rsa_private_key ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_rsa_private_key > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( br_rsa_private_key ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_rsa_private_key > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_rsa_private_key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . n_bitlen as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( n_bitlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . p as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( p ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . plen as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( plen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . q as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( q ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . qlen as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( qlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . dp as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . dplen as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( dplen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . dq as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( dq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . dqlen as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( dqlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . iq as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( iq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_rsa_private_key > ( ) ) ) . iqlen as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_rsa_private_key ) , "::" , stringify ! ( iqlen ) ) ) ; } 
 /// \brief Type for a RSA public key engine.
///
/// The public key engine performs the modular exponentiation of the
/// provided value with the public exponent. The value is modified in
/// place.
///
/// The value length (`xlen`) is verified to have _exactly_ the same
/// length as the modulus (actual modulus length, without extra leading
/// zeros in the modulus representation in memory). If the length does
/// not match, then this function returns 0 and `x[]` is unmodified.
///
/// It `xlen` is correct, then `x[]` is modified. Returned value is 1
/// on success, 0 on error. Error conditions include an oversized `x[]`
/// (the array has the same length as the modulus, but the numerical value
/// is not lower than the modulus) and an invalid modulus (e.g. an even
/// integer). If an error is reported, then the new contents of `x[]` are
/// unspecified.
///
/// \param x      operand to exponentiate.
/// \param xlen   length of the operand (in bytes).
/// \param pk     RSA public key.
/// \return  1 on success, 0 on error. 
 pub type br_rsa_public = :: std :: option :: Option < unsafe extern "C" fn ( x : * mut :: std :: os :: raw :: c_uchar , xlen : usize , pk : * const br_rsa_public_key ) -> u32 > ; 
 /// \brief Type for a RSA signature verification engine (PKCS#1 v1.5).
///
/// Parameters are:
///
/// - The signature itself. The provided array is NOT modified.
///
/// - The encoded OID for the hash function. The provided array must begin
/// with a single byte that contains the length of the OID value (in
/// bytes), followed by exactly that many bytes. This parameter may
/// also be `NULL`, in which case the raw hash value should be used
/// with the PKCS#1 v1.5 "type 1" padding (as used in SSL/TLS up
/// to TLS-1.1, with a 36-byte hash value).
///
/// - The hash output length, in bytes.
///
/// - The public key.
///
/// - An output buffer for the hash value. The caller must still compare
/// it with the hash of the data over which the signature is computed.
///
/// **Constraints:**
///
/// - Hash length MUST be no more than 64 bytes.
///
/// - OID value length MUST be no more than 32 bytes (i.e. `hash_oid[0]`
/// must have a value in the 0..32 range, inclusive).
///
/// This function verifies that the signature length (`xlen`) matches the
/// modulus length (this function returns 0 on mismatch). If the modulus
/// size exceeds the maximum supported RSA size, then the function also
/// returns 0.
///
/// Returned value is 1 on success, 0 on error.
///
/// Implementations of this type need not be constant-time.
///
/// \param x          signature buffer.
/// \param xlen       signature length (in bytes).
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash_len   expected hash value length (in bytes).
/// \param pk         RSA public key.
/// \param hash_out   output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 pub type br_rsa_pkcs1_vrfy = :: std :: option :: Option < unsafe extern "C" fn ( x : * const :: std :: os :: raw :: c_uchar , xlen : usize , hash_oid : * const :: std :: os :: raw :: c_uchar , hash_len : usize , pk : * const br_rsa_public_key , hash_out : * mut :: std :: os :: raw :: c_uchar ) -> u32 > ; 
 /// \brief Type for a RSA private key engine.
///
/// The `x[]` buffer is modified in place, and its length is inferred from
/// the modulus length (`x[]` is assumed to have a length of
/// `(sk->n_bitlen+7)/8` bytes).
///
/// Returned value is 1 on success, 0 on error.
///
/// \param x    operand to exponentiate.
/// \param sk   RSA private key.
/// \return  1 on success, 0 on error. 
 pub type br_rsa_private = :: std :: option :: Option < unsafe extern "C" fn ( x : * mut :: std :: os :: raw :: c_uchar , sk : * const br_rsa_private_key ) -> u32 > ; 
 /// \brief Type for a RSA signature generation engine (PKCS#1 v1.5).
///
/// Parameters are:
///
/// - The encoded OID for the hash function. The provided array must begin
/// with a single byte that contains the length of the OID value (in
/// bytes), followed by exactly that many bytes. This parameter may
/// also be `NULL`, in which case the raw hash value should be used
/// with the PKCS#1 v1.5 "type 1" padding (as used in SSL/TLS up
/// to TLS-1.1, with a 36-byte hash value).
///
/// - The hash value computes over the data to sign (its length is
/// expressed in bytes).
///
/// - The RSA private key.
///
/// - The output buffer, that receives the signature.
///
/// Returned value is 1 on success, 0 on error. Error conditions include
/// a too small modulus for the provided hash OID and value, or some
/// invalid key parameters. The signature length is exactly
/// `(sk->n_bitlen+7)/8` bytes.
///
/// This function is expected to be constant-time with regards to the
/// private key bytes (lengths of the modulus and the individual factors
/// may leak, though) and to the hashed data.
///
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash       hash value.
/// \param hash_len   hash value length (in bytes).
/// \param sk         RSA private key.
/// \param x          output buffer for the signature value.
/// \return  1 on success, 0 on error. 
 pub type br_rsa_pkcs1_sign = :: std :: option :: Option < unsafe extern "C" fn ( hash_oid : * const :: std :: os :: raw :: c_uchar , hash : * const :: std :: os :: raw :: c_uchar , hash_len : usize , sk : * const br_rsa_private_key , x : * mut :: std :: os :: raw :: c_uchar ) -> u32 > ; extern "C" {
 
 /// \brief RSA public key engine "i32".
///
/// \see br_rsa_public
///
/// \param x      operand to exponentiate.
/// \param xlen   length of the operand (in bytes).
/// \param pk     RSA public key.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i32_public ( x : * mut :: std :: os :: raw :: c_uchar , xlen : usize , pk : * const br_rsa_public_key , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA signature verification engine "i32".
///
/// \see br_rsa_pkcs1_vrfy
///
/// \param x          signature buffer.
/// \param xlen       signature length (in bytes).
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash_len   expected hash value length (in bytes).
/// \param pk         RSA public key.
/// \param hash_out   output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i32_pkcs1_vrfy ( x : * const :: std :: os :: raw :: c_uchar , xlen : usize , hash_oid : * const :: std :: os :: raw :: c_uchar , hash_len : usize , pk : * const br_rsa_public_key , hash_out : * mut :: std :: os :: raw :: c_uchar , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA private key engine "i32".
///
/// \see br_rsa_private
///
/// \param x    operand to exponentiate.
/// \param sk   RSA private key.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i32_private ( x : * mut :: std :: os :: raw :: c_uchar , sk : * const br_rsa_private_key , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA signature generation engine "i32".
///
/// \see br_rsa_pkcs1_sign
///
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash       hash value.
/// \param hash_len   hash value length (in bytes).
/// \param sk         RSA private key.
/// \param x          output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i32_pkcs1_sign ( hash_oid : * const :: std :: os :: raw :: c_uchar , hash : * const :: std :: os :: raw :: c_uchar , hash_len : usize , sk : * const br_rsa_private_key , x : * mut :: std :: os :: raw :: c_uchar , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA public key engine "i31".
///
/// \see br_rsa_public
///
/// \param x      operand to exponentiate.
/// \param xlen   length of the operand (in bytes).
/// \param pk     RSA public key.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i31_public ( x : * mut :: std :: os :: raw :: c_uchar , xlen : usize , pk : * const br_rsa_public_key , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA signature verification engine "i31".
///
/// \see br_rsa_pkcs1_vrfy
///
/// \param x          signature buffer.
/// \param xlen       signature length (in bytes).
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash_len   expected hash value length (in bytes).
/// \param pk         RSA public key.
/// \param hash_out   output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i31_pkcs1_vrfy ( x : * const :: std :: os :: raw :: c_uchar , xlen : usize , hash_oid : * const :: std :: os :: raw :: c_uchar , hash_len : usize , pk : * const br_rsa_public_key , hash_out : * mut :: std :: os :: raw :: c_uchar , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA private key engine "i31".
///
/// \see br_rsa_private
///
/// \param x    operand to exponentiate.
/// \param sk   RSA private key.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i31_private ( x : * mut :: std :: os :: raw :: c_uchar , sk : * const br_rsa_private_key , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA signature generation engine "i31".
///
/// \see br_rsa_pkcs1_sign
///
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash       hash value.
/// \param hash_len   hash value length (in bytes).
/// \param sk         RSA private key.
/// \param x          output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i31_pkcs1_sign ( hash_oid : * const :: std :: os :: raw :: c_uchar , hash : * const :: std :: os :: raw :: c_uchar , hash_len : usize , sk : * const br_rsa_private_key , x : * mut :: std :: os :: raw :: c_uchar , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA public key engine "i62".
///
/// This function is defined only on architecture that offer a 64x64->128
/// opcode. Use `br_rsa_i62_public_get()` to dynamically obtain a pointer
/// to that functiom.
///
/// \see br_rsa_public
///
/// \param x      operand to exponentiate.
/// \param xlen   length of the operand (in bytes).
/// \param pk     RSA public key.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i62_public ( x : * mut :: std :: os :: raw :: c_uchar , xlen : usize , pk : * const br_rsa_public_key , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA signature verification engine "i62".
///
/// This function is defined only on architecture that offer a 64x64->128
/// opcode. Use `br_rsa_i62_pkcs1_vrfy_get()` to dynamically obtain a pointer
/// to that functiom.
///
/// \see br_rsa_pkcs1_vrfy
///
/// \param x          signature buffer.
/// \param xlen       signature length (in bytes).
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash_len   expected hash value length (in bytes).
/// \param pk         RSA public key.
/// \param hash_out   output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i62_pkcs1_vrfy ( x : * const :: std :: os :: raw :: c_uchar , xlen : usize , hash_oid : * const :: std :: os :: raw :: c_uchar , hash_len : usize , pk : * const br_rsa_public_key , hash_out : * mut :: std :: os :: raw :: c_uchar , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA private key engine "i62".
///
/// This function is defined only on architecture that offer a 64x64->128
/// opcode. Use `br_rsa_i62_private_get()` to dynamically obtain a pointer
/// to that functiom.
///
/// \see br_rsa_private
///
/// \param x    operand to exponentiate.
/// \param sk   RSA private key.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i62_private ( x : * mut :: std :: os :: raw :: c_uchar , sk : * const br_rsa_private_key , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA signature generation engine "i62".
///
/// This function is defined only on architecture that offer a 64x64->128
/// opcode. Use `br_rsa_i62_pkcs1_sign_get()` to dynamically obtain a pointer
/// to that functiom.
///
/// \see br_rsa_pkcs1_sign
///
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash       hash value.
/// \param hash_len   hash value length (in bytes).
/// \param sk         RSA private key.
/// \param x          output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i62_pkcs1_sign ( hash_oid : * const :: std :: os :: raw :: c_uchar , hash : * const :: std :: os :: raw :: c_uchar , hash_len : usize , sk : * const br_rsa_private_key , x : * mut :: std :: os :: raw :: c_uchar , ) -> u32 ; 
} extern "C" {
 
 /// \brief Get the RSA "i62" implementation (public key operations),
/// if available.
///
/// \return  the implementation, or 0. 
 
 pub fn br_rsa_i62_public_get ( ) -> br_rsa_public ; 
} extern "C" {
 
 /// \brief Get the RSA "i62" implementation (PKCS#1 signature verification),
/// if available.
///
/// \return  the implementation, or 0. 
 
 pub fn br_rsa_i62_pkcs1_vrfy_get ( ) -> br_rsa_pkcs1_vrfy ; 
} extern "C" {
 
 /// \brief Get the RSA "i62" implementation (private key operations),
/// if available.
///
/// \return  the implementation, or 0. 
 
 pub fn br_rsa_i62_private_get ( ) -> br_rsa_private ; 
} extern "C" {
 
 /// \brief Get the RSA "i62" implementation (PKCS#1 signature generation),
/// if available.
///
/// \return  the implementation, or 0. 
 
 pub fn br_rsa_i62_pkcs1_sign_get ( ) -> br_rsa_pkcs1_sign ; 
} extern "C" {
 
 /// \brief RSA public key engine "i15".
///
/// \see br_rsa_public
///
/// \param x      operand to exponentiate.
/// \param xlen   length of the operand (in bytes).
/// \param pk     RSA public key.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i15_public ( x : * mut :: std :: os :: raw :: c_uchar , xlen : usize , pk : * const br_rsa_public_key , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA signature verification engine "i15".
///
/// \see br_rsa_pkcs1_vrfy
///
/// \param x          signature buffer.
/// \param xlen       signature length (in bytes).
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash_len   expected hash value length (in bytes).
/// \param pk         RSA public key.
/// \param hash_out   output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i15_pkcs1_vrfy ( x : * const :: std :: os :: raw :: c_uchar , xlen : usize , hash_oid : * const :: std :: os :: raw :: c_uchar , hash_len : usize , pk : * const br_rsa_public_key , hash_out : * mut :: std :: os :: raw :: c_uchar , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA private key engine "i15".
///
/// \see br_rsa_private
///
/// \param x    operand to exponentiate.
/// \param sk   RSA private key.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i15_private ( x : * mut :: std :: os :: raw :: c_uchar , sk : * const br_rsa_private_key , ) -> u32 ; 
} extern "C" {
 
 /// \brief RSA signature generation engine "i15".
///
/// \see br_rsa_pkcs1_sign
///
/// \param hash_oid   encoded hash algorithm OID (or `NULL`).
/// \param hash       hash value.
/// \param hash_len   hash value length (in bytes).
/// \param sk         RSA private key.
/// \param x          output buffer for the hash value.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_i15_pkcs1_sign ( hash_oid : * const :: std :: os :: raw :: c_uchar , hash : * const :: std :: os :: raw :: c_uchar , hash_len : usize , sk : * const br_rsa_private_key , x : * mut :: std :: os :: raw :: c_uchar , ) -> u32 ; 
} extern "C" {
 
 /// \brief Get "default" RSA implementation (public-key operations).
///
/// This returns the preferred implementation of RSA (public-key operations)
/// on the current system.
///
/// \return  the default implementation. 
 
 pub fn br_rsa_public_get_default ( ) -> br_rsa_public ; 
} extern "C" {
 
 /// \brief Get "default" RSA implementation (private-key operations).
///
/// This returns the preferred implementation of RSA (private-key operations)
/// on the current system.
///
/// \return  the default implementation. 
 
 pub fn br_rsa_private_get_default ( ) -> br_rsa_private ; 
} extern "C" {
 
 /// \brief Get "default" RSA implementation (PKCS#1 signature verification).
///
/// This returns the preferred implementation of RSA (signature verification)
/// on the current system.
///
/// \return  the default implementation. 
 
 pub fn br_rsa_pkcs1_vrfy_get_default ( ) -> br_rsa_pkcs1_vrfy ; 
} extern "C" {
 
 /// \brief Get "default" RSA implementation (PKCS#1 signature generation).
///
/// This returns the preferred implementation of RSA (signature generation)
/// on the current system.
///
/// \return  the default implementation. 
 
 pub fn br_rsa_pkcs1_sign_get_default ( ) -> br_rsa_pkcs1_sign ; 
} extern "C" {
 
 /// \brief RSA decryption helper, for SSL/TLS.
///
/// This function performs the RSA decryption for a RSA-based key exchange
/// in a SSL/TLS server. The provided RSA engine is used. The `data`
/// parameter points to the value to decrypt, of length `len` bytes. On
/// success, the 48-byte pre-master secret is copied into `data`, starting
/// at the first byte of that buffer; on error, the contents of `data`
/// become indeterminate.
///
/// This function first checks that the provided value length (`len`) is
/// not lower than 59 bytes, and matches the RSA modulus length; if neither
/// of this property is met, then this function returns 0 and the buffer
/// is unmodified.
///
/// Otherwise, decryption and then padding verification are performed, both
/// in constant-time. A decryption error, or a bad padding, or an
/// incorrect decrypted value length are reported with a returned value of
/// 0; on success, 1 is returned. The caller (SSL server engine) is supposed
/// to proceed with a random pre-master secret in case of error.
///
/// \param core   RSA private key engine.
/// \param sk     RSA private key.
/// \param data   input/output buffer.
/// \param len    length (in bytes) of the data to decrypt.
/// \return  1 on success, 0 on error. 
 
 pub fn br_rsa_ssl_decrypt ( core : br_rsa_private , sk : * const br_rsa_private_key , data : * mut :: std :: os :: raw :: c_uchar , len : usize , ) -> u32 ; 
} 
 /// \brief Structure for an EC public key. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ec_public_key { 
 /// \brief Identifier for the curve used by this key. 
 pub curve : :: std :: os :: raw :: c_int , 
 /// \brief Public curve point (uncompressed format). 
 pub q : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief Length of public curve point (in bytes). 
 pub qlen : usize , } # [ test ] fn bindgen_test_layout_br_ec_public_key ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ec_public_key > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_ec_public_key ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ec_public_key > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ec_public_key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_public_key > ( ) ) ) . curve as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_public_key ) , "::" , stringify ! ( curve ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_public_key > ( ) ) ) . q as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_public_key ) , "::" , stringify ! ( q ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_public_key > ( ) ) ) . qlen as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_public_key ) , "::" , stringify ! ( qlen ) ) ) ; } 
 /// \brief Structure for an EC private key.
///
/// The private key is an integer modulo the curve subgroup order. The
/// encoding below tolerates extra leading zeros. In general, it is
/// recommended that the private key has the same length as the curve
/// subgroup order. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ec_private_key { 
 /// \brief Identifier for the curve used by this key. 
 pub curve : :: std :: os :: raw :: c_int , 
 /// \brief Private key (integer, unsigned big-endian encoding). 
 pub x : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief Private key length (in bytes). 
 pub xlen : usize , } # [ test ] fn bindgen_test_layout_br_ec_private_key ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ec_private_key > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_ec_private_key ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ec_private_key > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ec_private_key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_private_key > ( ) ) ) . curve as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_private_key ) , "::" , stringify ! ( curve ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_private_key > ( ) ) ) . x as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_private_key ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_private_key > ( ) ) ) . xlen as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_private_key ) , "::" , stringify ! ( xlen ) ) ) ; } 
 /// \brief Type for an EC implementation. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ec_impl { 
 /// \brief Supported curves.
    ///
    /// This word is a bitfield: bit `x` is set if the curve of ID `x`
    /// is supported. E.g. an implementation supporting both NIST P-256
    /// (secp256r1, ID 23) and NIST P-384 (secp384r1, ID 24) will have
    /// value `0x01800000` in this field. 
 pub supported_curves : u32 , 
 /// \brief Get the conventional generator.
    ///
    /// This function returns the conventional generator (encoded
    /// curve point) for the specified curve. This function MUST NOT
    /// be called if the curve is not supported.
    ///
    /// \param curve   curve identifier.
    /// \param len     receiver for the encoded generator length (in bytes).
    /// \return  the encoded generator. 
 pub generator : :: std :: option :: Option < unsafe extern "C" fn ( curve : :: std :: os :: raw :: c_int , len : * mut usize ) -> * const :: std :: os :: raw :: c_uchar > , 
 /// \brief Get the subgroup order.
    ///
    /// This function returns the order of the subgroup generated by
    /// the conventional generator, for the specified curve. Unsigned
    /// big-endian encoding is used. This function MUST NOT be called
    /// if the curve is not supported.
    ///
    /// \param curve   curve identifier.
    /// \param len     receiver for the encoded order length (in bytes).
    /// \return  the encoded order. 
 pub order : :: std :: option :: Option < unsafe extern "C" fn ( curve : :: std :: os :: raw :: c_int , len : * mut usize ) -> * const :: std :: os :: raw :: c_uchar > , 
 /// \brief Get the offset and length for the X coordinate.
    ///
    /// This function returns the offset and length (in bytes) of
    /// the X coordinate in an encoded non-zero point.
    ///
    /// \param curve   curve identifier.
    /// \param len     receiver for the X coordinate length (in bytes).
    /// \return  the offset for the X coordinate (in bytes). 
 pub xoff : :: std :: option :: Option < unsafe extern "C" fn ( curve : :: std :: os :: raw :: c_int , len : * mut usize ) -> usize > , 
 /// \brief Multiply a curve point by an integer.
    ///
    /// The source point is provided in array `G` (of size `Glen` bytes);
    /// the multiplication result is written over it. The multiplier
    /// `x` (of size `xlen` bytes) uses unsigned big-endian encoding.
    ///
    /// Rules:
    ///
    /// - The specified curve MUST be supported.
    ///
    /// - The source point must be a valid point on the relevant curve
    /// subgroup (and not the "point at infinity" either). If this is
    /// not the case, then this function returns an error (0).
    ///
    /// - The multiplier integer MUST be non-zero and less than the
    /// curve subgroup order. If this property does not hold, then
    /// the result is indeterminate and an error code is not
    /// guaranteed.
    ///
    /// Returned value is 1 on success, 0 on error. On error, the
    /// contents of `G` are indeterminate.
    ///
    /// \param G       point to multiply.
    /// \param Glen    length of the encoded point (in bytes).
    /// \param x       multiplier (unsigned big-endian).
    /// \param xlen    multiplier length (in bytes).
    /// \param curve   curve identifier.
    /// \return  1 on success, 0 on error. 
 pub mul : :: std :: option :: Option < unsafe extern "C" fn ( G : * mut :: std :: os :: raw :: c_uchar , Glen : usize , x : * const :: std :: os :: raw :: c_uchar , xlen : usize , curve : :: std :: os :: raw :: c_int ) -> u32 > , 
 /// \brief Multiply the generator by an integer.
    ///
    /// The multiplier MUST be non-zero and less than the curve
    /// subgroup order. Results are indeterminate if this property
    /// does not hold.
    ///
    /// \param R       output buffer for the point.
    /// \param x       multiplier (unsigned big-endian).
    /// \param xlen    multiplier length (in bytes).
    /// \param curve   curve identifier.
    /// \return  encoded result point length (in bytes). 
 pub mulgen : :: std :: option :: Option < unsafe extern "C" fn ( R : * mut :: std :: os :: raw :: c_uchar , x : * const :: std :: os :: raw :: c_uchar , xlen : usize , curve : :: std :: os :: raw :: c_int ) -> usize > , 
 /// \brief Multiply two points by two integers and add the
    /// results.
    ///
    /// The point `x*A + y*B` is computed and written back in the `A`
    /// array.
    ///
    /// Rules:
    ///
    /// - The specified curve MUST be supported.
    ///
    /// - The source points (`A` and `B`)  must be valid points on
    /// the relevant curve subgroup (and not the "point at
    /// infinity" either). If this is not the case, then this
    /// function returns an error (0).
    ///
    /// - If the `B` pointer is `NULL`, then the conventional
    /// subgroup generator is used. With some implementations,
    /// this may be faster than providing a pointer to the
    /// generator.
    ///
    /// - The multiplier integers (`x` and `y`) MUST be non-zero
    /// and less than the curve subgroup order. If either integer
    /// is zero, then an error is reported, but if one of them is
    /// not lower than the subgroup order, then the result is
    /// indeterminate and an error code is not guaranteed.
    ///
    /// - If the final result is the point at infinity, then an
    /// error is returned.
    ///
    /// Returned value is 1 on success, 0 on error. On error, the
    /// contents of `A` are indeterminate.
    ///
    /// \param A       first point to multiply.
    /// \param B       second point to multiply (`NULL` for the generator).
    /// \param len     common length of the encoded points (in bytes).
    /// \param x       multiplier for `A` (unsigned big-endian).
    /// \param xlen    length of multiplier for `A` (in bytes).
    /// \param y       multiplier for `A` (unsigned big-endian).
    /// \param ylen    length of multiplier for `A` (in bytes).
    /// \param curve   curve identifier.
    /// \return  1 on success, 0 on error. 
 pub muladd : :: std :: option :: Option < unsafe extern "C" fn ( A : * mut :: std :: os :: raw :: c_uchar , B : * const :: std :: os :: raw :: c_uchar , len : usize , x : * const :: std :: os :: raw :: c_uchar , xlen : usize , y : * const :: std :: os :: raw :: c_uchar , ylen : usize , curve : :: std :: os :: raw :: c_int ) -> u32 > , } # [ test ] fn bindgen_test_layout_br_ec_impl ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ec_impl > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( br_ec_impl ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ec_impl > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ec_impl ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_impl > ( ) ) ) . supported_curves as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_impl ) , "::" , stringify ! ( supported_curves ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_impl > ( ) ) ) . generator as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_impl ) , "::" , stringify ! ( generator ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_impl > ( ) ) ) . order as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_impl ) , "::" , stringify ! ( order ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_impl > ( ) ) ) . xoff as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_impl ) , "::" , stringify ! ( xoff ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_impl > ( ) ) ) . mul as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_impl ) , "::" , stringify ! ( mul ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_impl > ( ) ) ) . mulgen as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_impl ) , "::" , stringify ! ( mulgen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ec_impl > ( ) ) ) . muladd as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_ec_impl ) , "::" , stringify ! ( muladd ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_ec_prime_i31" ] 
 pub static mut  br_ec_prime_i31  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_prime_i15" ] 
 pub static mut  br_ec_prime_i15  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_p256_m15" ] 
 pub static mut  br_ec_p256_m15  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_p256_m31" ] 
 pub static mut  br_ec_p256_m31  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_c25519_i15" ] 
 pub static mut  br_ec_c25519_i15  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_c25519_i31" ] 
 pub static mut  br_ec_c25519_i31  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_c25519_m15" ] 
 pub static mut  br_ec_c25519_m15  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_c25519_m31" ] 
 pub static mut  br_ec_c25519_m31  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_all_m15" ] 
 pub static mut  br_ec_all_m15  :  br_ec_impl ;
} extern "C" {
 # [ link_name = "\u{1}br_ec_all_m31" ] 
 pub static mut  br_ec_all_m31  :  br_ec_impl ;
} extern "C" {
 
 /// \brief Get the "default" EC implementation for the current system.
///
/// This returns a pointer to the preferred implementation on the
/// current system.
///
/// \return  the default EC implementation. 
 
 pub fn br_ec_get_default ( ) -> * const br_ec_impl ; 
} extern "C" {
 
 /// \brief Convert a signature from "raw" to "asn1".
///
/// Conversion is done "in place" and the new length is returned.
/// Conversion may enlarge the signature, but by no more than 9 bytes at
/// most. On error, 0 is returned (error conditions include an odd raw
/// signature length, or an oversized integer).
///
/// \param sig       signature to convert.
/// \param sig_len   signature length (in bytes).
/// \return  the new signature length, or 0 on error. 
 
 pub fn br_ecdsa_raw_to_asn1 ( sig : * mut :: std :: os :: raw :: c_void , sig_len : usize , ) -> usize ; 
} extern "C" {
 
 /// \brief Convert a signature from "asn1" to "raw".
///
/// Conversion is done "in place" and the new length is returned.
/// Conversion may enlarge the signature, but the new signature length
/// will be less than twice the source length at most. On error, 0 is
/// returned (error conditions include an invalid ASN.1 structure or an
/// oversized integer).
///
/// \param sig       signature to convert.
/// \param sig_len   signature length (in bytes).
/// \return  the new signature length, or 0 on error. 
 
 pub fn br_ecdsa_asn1_to_raw ( sig : * mut :: std :: os :: raw :: c_void , sig_len : usize , ) -> usize ; 
} 
 /// \brief Type for an ECDSA signer function.
///
/// A pointer to the EC implementation is provided. The hash value is
/// assumed to have the length inferred from the designated hash function
/// class.
///
/// Signature is written in the buffer pointed to by `sig`, and the length
/// (in bytes) is returned. On error, nothing is written in the buffer,
/// and 0 is returned. This function returns 0 if the specified curve is
/// not supported by the provided EC implementation.
///
/// The signature format is either "raw" or "asn1", depending on the
/// implementation; maximum length is predictable from the implemented
/// curve:
///
/// | curve      | raw | asn1 |
/// | :--------- | --: | ---: |
/// | NIST P-256 |  64 |   72 |
/// | NIST P-384 |  96 |  104 |
/// | NIST P-521 | 132 |  139 |
///
/// \param impl         EC implementation to use.
/// \param hf           hash function used to process the data.
/// \param hash_value   signed data (hashed).
/// \param sk           EC private key.
/// \param sig          destination buffer.
/// \return  the signature length (in bytes), or 0 on error. 
 pub type br_ecdsa_sign = :: std :: option :: Option < unsafe extern "C" fn ( impl_ : * const br_ec_impl , hf : * const br_hash_class , hash_value : * const :: std :: os :: raw :: c_void , sk : * const br_ec_private_key , sig : * mut :: std :: os :: raw :: c_void ) -> usize > ; 
 /// \brief Type for an ECDSA signature verification function.
///
/// A pointer to the EC implementation is provided. The hashed value,
/// computed over the purportedly signed data, is also provided with
/// its length.
///
/// The signature format is either "raw" or "asn1", depending on the
/// implementation.
///
/// Returned value is 1 on success (valid signature), 0 on error. This
/// function returns 0 if the specified curve is not supported by the
/// provided EC implementation.
///
/// \param impl       EC implementation to use.
/// \param hash       signed data (hashed).
/// \param hash_len   hash value length (in bytes).
/// \param pk         EC public key.
/// \param sig        signature.
/// \param sig_len    signature length (in bytes).
/// \return  1 on success, 0 on error. 
 pub type br_ecdsa_vrfy = :: std :: option :: Option < unsafe extern "C" fn ( impl_ : * const br_ec_impl , hash : * const :: std :: os :: raw :: c_void , hash_len : usize , pk : * const br_ec_public_key , sig : * const :: std :: os :: raw :: c_void , sig_len : usize ) -> u32 > ; extern "C" {
 
 /// \brief ECDSA signature generator, "i31" implementation, "asn1" format.
///
/// \see br_ecdsa_sign()
///
/// \param impl         EC implementation to use.
/// \param hf           hash function used to process the data.
/// \param hash_value   signed data (hashed).
/// \param sk           EC private key.
/// \param sig          destination buffer.
/// \return  the signature length (in bytes), or 0 on error. 
 
 pub fn br_ecdsa_i31_sign_asn1 ( impl_ : * const br_ec_impl , hf : * const br_hash_class , hash_value : * const :: std :: os :: raw :: c_void , sk : * const br_ec_private_key , sig : * mut :: std :: os :: raw :: c_void , ) -> usize ; 
} extern "C" {
 
 /// \brief ECDSA signature generator, "i31" implementation, "raw" format.
///
/// \see br_ecdsa_sign()
///
/// \param impl         EC implementation to use.
/// \param hf           hash function used to process the data.
/// \param hash_value   signed data (hashed).
/// \param sk           EC private key.
/// \param sig          destination buffer.
/// \return  the signature length (in bytes), or 0 on error. 
 
 pub fn br_ecdsa_i31_sign_raw ( impl_ : * const br_ec_impl , hf : * const br_hash_class , hash_value : * const :: std :: os :: raw :: c_void , sk : * const br_ec_private_key , sig : * mut :: std :: os :: raw :: c_void , ) -> usize ; 
} extern "C" {
 
 /// \brief ECDSA signature verifier, "i31" implementation, "asn1" format.
///
/// \see br_ecdsa_vrfy()
///
/// \param impl       EC implementation to use.
/// \param hash       signed data (hashed).
/// \param hash_len   hash value length (in bytes).
/// \param pk         EC public key.
/// \param sig        signature.
/// \param sig_len    signature length (in bytes).
/// \return  1 on success, 0 on error. 
 
 pub fn br_ecdsa_i31_vrfy_asn1 ( impl_ : * const br_ec_impl , hash : * const :: std :: os :: raw :: c_void , hash_len : usize , pk : * const br_ec_public_key , sig : * const :: std :: os :: raw :: c_void , sig_len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief ECDSA signature verifier, "i31" implementation, "raw" format.
///
/// \see br_ecdsa_vrfy()
///
/// \param impl       EC implementation to use.
/// \param hash       signed data (hashed).
/// \param hash_len   hash value length (in bytes).
/// \param pk         EC public key.
/// \param sig        signature.
/// \param sig_len    signature length (in bytes).
/// \return  1 on success, 0 on error. 
 
 pub fn br_ecdsa_i31_vrfy_raw ( impl_ : * const br_ec_impl , hash : * const :: std :: os :: raw :: c_void , hash_len : usize , pk : * const br_ec_public_key , sig : * const :: std :: os :: raw :: c_void , sig_len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief ECDSA signature generator, "i15" implementation, "asn1" format.
///
/// \see br_ecdsa_sign()
///
/// \param impl         EC implementation to use.
/// \param hf           hash function used to process the data.
/// \param hash_value   signed data (hashed).
/// \param sk           EC private key.
/// \param sig          destination buffer.
/// \return  the signature length (in bytes), or 0 on error. 
 
 pub fn br_ecdsa_i15_sign_asn1 ( impl_ : * const br_ec_impl , hf : * const br_hash_class , hash_value : * const :: std :: os :: raw :: c_void , sk : * const br_ec_private_key , sig : * mut :: std :: os :: raw :: c_void , ) -> usize ; 
} extern "C" {
 
 /// \brief ECDSA signature generator, "i15" implementation, "raw" format.
///
/// \see br_ecdsa_sign()
///
/// \param impl         EC implementation to use.
/// \param hf           hash function used to process the data.
/// \param hash_value   signed data (hashed).
/// \param sk           EC private key.
/// \param sig          destination buffer.
/// \return  the signature length (in bytes), or 0 on error. 
 
 pub fn br_ecdsa_i15_sign_raw ( impl_ : * const br_ec_impl , hf : * const br_hash_class , hash_value : * const :: std :: os :: raw :: c_void , sk : * const br_ec_private_key , sig : * mut :: std :: os :: raw :: c_void , ) -> usize ; 
} extern "C" {
 
 /// \brief ECDSA signature verifier, "i15" implementation, "asn1" format.
///
/// \see br_ecdsa_vrfy()
///
/// \param impl       EC implementation to use.
/// \param hash       signed data (hashed).
/// \param hash_len   hash value length (in bytes).
/// \param pk         EC public key.
/// \param sig        signature.
/// \param sig_len    signature length (in bytes).
/// \return  1 on success, 0 on error. 
 
 pub fn br_ecdsa_i15_vrfy_asn1 ( impl_ : * const br_ec_impl , hash : * const :: std :: os :: raw :: c_void , hash_len : usize , pk : * const br_ec_public_key , sig : * const :: std :: os :: raw :: c_void , sig_len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief ECDSA signature verifier, "i15" implementation, "raw" format.
///
/// \see br_ecdsa_vrfy()
///
/// \param impl       EC implementation to use.
/// \param hash       signed data (hashed).
/// \param hash_len   hash value length (in bytes).
/// \param pk         EC public key.
/// \param sig        signature.
/// \param sig_len    signature length (in bytes).
/// \return  1 on success, 0 on error. 
 
 pub fn br_ecdsa_i15_vrfy_raw ( impl_ : * const br_ec_impl , hash : * const :: std :: os :: raw :: c_void , hash_len : usize , pk : * const br_ec_public_key , sig : * const :: std :: os :: raw :: c_void , sig_len : usize , ) -> u32 ; 
} extern "C" {
 
 /// \brief Get "default" ECDSA implementation (signer, asn1 format).
///
/// This returns the preferred implementation of ECDSA signature generation
/// ("asn1" output format) on the current system.
///
/// \return  the default implementation. 
 
 pub fn br_ecdsa_sign_asn1_get_default ( ) -> br_ecdsa_sign ; 
} extern "C" {
 
 /// \brief Get "default" ECDSA implementation (signer, raw format).
///
/// This returns the preferred implementation of ECDSA signature generation
/// ("raw" output format) on the current system.
///
/// \return  the default implementation. 
 
 pub fn br_ecdsa_sign_raw_get_default ( ) -> br_ecdsa_sign ; 
} extern "C" {
 
 /// \brief Get "default" ECDSA implementation (verifier, asn1 format).
///
/// This returns the preferred implementation of ECDSA signature verification
/// ("asn1" output format) on the current system.
///
/// \return  the default implementation. 
 
 pub fn br_ecdsa_vrfy_asn1_get_default ( ) -> br_ecdsa_vrfy ; 
} extern "C" {
 
 /// \brief Get "default" ECDSA implementation (verifier, raw format).
///
/// This returns the preferred implementation of ECDSA signature verification
/// ("raw" output format) on the current system.
///
/// \return  the default implementation. 
 
 pub fn br_ecdsa_vrfy_raw_get_default ( ) -> br_ecdsa_vrfy ; 
} 
 /// \brief Aggregate structure for public keys. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_x509_pkey { 
 /// \brief Key type: `BR_KEYTYPE_RSA` or `BR_KEYTYPE_EC` 
 pub key_type : :: std :: os :: raw :: c_uchar , pub key : br_x509_pkey__bindgen_ty_1 , } 
 /// \brief Actual public key. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_x509_pkey__bindgen_ty_1 { 
 /// \brief RSA public key. 
 pub rsa : br_rsa_public_key , 
 /// \brief EC public key. 
 pub ec : br_ec_public_key , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_br_x509_pkey__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_pkey__bindgen_ty_1 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_x509_pkey__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_pkey__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_pkey__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_pkey__bindgen_ty_1 > ( ) ) ) . rsa as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_pkey__bindgen_ty_1 ) , "::" , stringify ! ( rsa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_pkey__bindgen_ty_1 > ( ) ) ) . ec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_pkey__bindgen_ty_1 ) , "::" , stringify ! ( ec ) ) ) ; } # [ test ] fn bindgen_test_layout_br_x509_pkey ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_pkey > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( br_x509_pkey ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_pkey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_pkey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_pkey > ( ) ) ) . key_type as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_pkey ) , "::" , stringify ! ( key_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_pkey > ( ) ) ) . key as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_pkey ) , "::" , stringify ! ( key ) ) ) ; } 
 /// \brief Distinguished Name (X.500) structure.
///
/// The DN is DER-encoded. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_x500_name { 
 /// \brief Encoded DN data. 
 pub data : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief Encoded DN length (in bytes). 
 pub len : usize , } # [ test ] fn bindgen_test_layout_br_x500_name ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x500_name > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( br_x500_name ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x500_name > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x500_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x500_name > ( ) ) ) . data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x500_name ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x500_name > ( ) ) ) . len as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_x500_name ) , "::" , stringify ! ( len ) ) ) ; } 
 /// \brief Trust anchor structure. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_x509_trust_anchor { 
 /// \brief Encoded DN (X.500 name). 
 pub dn : br_x500_name , 
 /// \brief Anchor flags (e.g. `BR_X509_TA_CA`). 
 pub flags : :: std :: os :: raw :: c_uint , 
 /// \brief Anchor public key. 
 pub pkey : br_x509_pkey , } # [ test ] fn bindgen_test_layout_br_x509_trust_anchor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_trust_anchor > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( br_x509_trust_anchor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_trust_anchor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_trust_anchor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_trust_anchor > ( ) ) ) . dn as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_trust_anchor ) , "::" , stringify ! ( dn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_trust_anchor > ( ) ) ) . flags as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_trust_anchor ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_trust_anchor > ( ) ) ) . pkey as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_trust_anchor ) , "::" , stringify ! ( pkey ) ) ) ; } 
 /// \brief Class type for an X.509 engine.
///
/// A certificate chain validation uses a caller-allocated context, which
/// contains the running state for that validation. Methods are called
/// in due order:
///
/// - `start_chain()` is called at the start of the validation.
/// - Certificates are processed one by one, in SSL order (end-entity
/// comes first). For each certificate, the following methods are
/// called:
///
/// - `start_cert()` at the beginning of the certificate.
/// - `append()` is called zero, one or more times, to provide
/// the certificate (possibly in chunks).
/// - `end_cert()` at the end of the certificate.
///
/// - `end_chain()` is called when the last certificate in the chain
/// was processed.
/// - `get_pkey()` is called after chain processing, if the chain
/// validation was succesfull.
///
/// A context structure may be reused; the `start_chain()` method shall
/// ensure (re)initialisation. 
 pub type br_x509_class = br_x509_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_x509_class_ { 
 /// \brief X.509 context size, in bytes. 
 pub context_size : usize , 
 /// \brief Start a new chain.
    ///
    /// This method shall set the vtable (first field) of the context
    /// structure.
    ///
    /// The `server_name`, if not `NULL`, will be considered as a
    /// fully qualified domain name, to be matched against the `dNSName`
    /// elements of the end-entity certificate's SAN extension (if there
    /// is no SAN, then the Common Name from the subjectDN will be used).
    /// If `server_name` is `NULL` then no such matching is performed.
    ///
    /// \param ctx           validation context.
    /// \param server_name   server name to match (or `NULL`). 
 pub start_chain : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_x509_class , server_name : * const :: std :: os :: raw :: c_char ) > , 
 /// \brief Start a new certificate.
    ///
    /// \param ctx      validation context.
    /// \param length   new certificate length (in bytes). 
 pub start_cert : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_x509_class , length : u32 ) > , 
 /// \brief Receive some bytes for the current certificate.
    ///
    /// This function may be called several times in succession for
    /// a given certificate. The caller guarantees that for each
    /// call, `len` is not zero, and the sum of all chunk lengths
    /// for a certificate matches the total certificate length which
    /// was provided in the previous `start_cert()` call.
    ///
    /// If the new certificate is empty (no byte at all) then this
    /// function won't be called at all.
    ///
    /// \param ctx   validation context.
    /// \param buf   certificate data chunk.
    /// \param len   certificate data chunk length (in bytes). 
 pub append : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_x509_class , buf : * const :: std :: os :: raw :: c_uchar , len : usize ) > , 
 /// \brief Finish the current certificate.
    ///
    /// This function is called when the end of the current certificate
    /// is reached.
    ///
    /// \param ctx   validation context. 
 pub end_cert : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_x509_class ) > , 
 /// \brief Finish the chain.
    ///
    /// This function is called at the end of the chain. It shall
    /// return either 0 if the validation was successful, or a
    /// non-zero error code. The `BR_ERR_X509_*` constants are
    /// error codes, though other values may be possible.
    ///
    /// \param ctx   validation context.
    /// \return  0 on success, or a non-zero error code. 
 pub end_chain : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_x509_class ) -> :: std :: os :: raw :: c_uint > , 
 /// \brief Get the resulting end-entity public key.
    ///
    /// The decoded public key is returned. The returned pointer
    /// may be valid only as long as the context structure is
    /// unmodified, i.e. it may cease to be valid if the context
    /// is released or reused.
    ///
    /// This function _may_ return `NULL` if the validation failed.
    /// However, returning a public key does not mean that the
    /// validation was wholly successful; some engines may return
    /// a decoded public key even if the chain did not end on a
    /// trusted anchor.
    ///
    /// If validation succeeded and `usage` is not `NULL`, then
    /// `*usage` is filled with a combination of `BR_KEYTYPE_SIGN`
    /// and/or `BR_KEYTYPE_KEYX` that specifies the validated key
    /// usage types. It is the caller's responsibility to check
    /// that value against the intended use of the public key.
    ///
    /// \param ctx   validation context.
    /// \return  the end-entity public key, or `NULL`. 
 pub get_pkey : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_x509_class , usages : * mut :: std :: os :: raw :: c_uint ) -> * const br_x509_pkey > , } # [ test ] fn bindgen_test_layout_br_x509_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_class_ > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( br_x509_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_class_ > ( ) ) ) . start_chain as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_class_ ) , "::" , stringify ! ( start_chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_class_ > ( ) ) ) . start_cert as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_class_ ) , "::" , stringify ! ( start_cert ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_class_ > ( ) ) ) . append as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_class_ ) , "::" , stringify ! ( append ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_class_ > ( ) ) ) . end_cert as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_class_ ) , "::" , stringify ! ( end_cert ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_class_ > ( ) ) ) . end_chain as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_class_ ) , "::" , stringify ! ( end_chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_class_ > ( ) ) ) . get_pkey as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_class_ ) , "::" , stringify ! ( get_pkey ) ) ) ; } 
 /// \brief The "known key" X.509 engine structure.
///
/// The structure contents are opaque (they shall not be accessed directly),
/// except for the first field (the vtable).
///
/// The "known key" engine returns an externally configured public key,
/// and totally ignores the certificate contents. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_x509_knownkey_context { 
 /// \brief Reference to the context vtable. 
 pub vtable : * const br_x509_class , pub pkey : br_x509_pkey , pub usages : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_br_x509_knownkey_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_knownkey_context > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( br_x509_knownkey_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_knownkey_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_knownkey_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_knownkey_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_knownkey_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_knownkey_context > ( ) ) ) . pkey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_knownkey_context ) , "::" , stringify ! ( pkey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_knownkey_context > ( ) ) ) . usages as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_knownkey_context ) , "::" , stringify ! ( usages ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_x509_knownkey_vtable" ] 
 pub static mut  br_x509_knownkey_vtable  :  br_x509_class ;
} extern "C" {
 
 /// \brief Initialize a "known key" X.509 engine with a known RSA public key.
///
/// The `usages` parameter indicates the allowed key usages for that key
/// (`BR_KEYTYPE_KEYX` and/or `BR_KEYTYPE_SIGN`).
///
/// The provided pointers are linked in, not copied, so they must remain
/// valid while the public key may be in usage.
///
/// \param ctx      context to initialise.
/// \param pk       known public key.
/// \param usages   allowed key usages. 
 
 pub fn br_x509_knownkey_init_rsa ( ctx : * mut br_x509_knownkey_context , pk : * const br_rsa_public_key , usages : :: std :: os :: raw :: c_uint , ) ; 
} extern "C" {
 
 /// \brief Initialize a "known key" X.509 engine with a known EC public key.
///
/// The `usages` parameter indicates the allowed key usages for that key
/// (`BR_KEYTYPE_KEYX` and/or `BR_KEYTYPE_SIGN`).
///
/// The provided pointers are linked in, not copied, so they must remain
/// valid while the public key may be in usage.
///
/// \param ctx      context to initialise.
/// \param pk       known public key.
/// \param usages   allowed key usages. 
 
 pub fn br_x509_knownkey_init_ec ( ctx : * mut br_x509_knownkey_context , pk : * const br_ec_public_key , usages : :: std :: os :: raw :: c_uint , ) ; 
} 
 /// \brief Type for receiving a name element.
///
/// An array of such structures can be provided to the X.509 decoding
/// engines. If the specified elements are found in the certificate
/// subject DN or the SAN extension, then the name contents are copied
/// as zero-terminated strings into the buffer.
///
/// The decoder converts TeletexString and BMPString to UTF8String, and
/// ensures that the resulting string is zero-terminated. If the string
/// does not fit in the provided buffer, then the copy is aborted and an
/// error is reported. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_name_element { 
 /// \brief Element OID.
    ///
    /// For X.500 name elements (to be extracted from the subject DN),
    /// this is the encoded OID for the requested name element; the
    /// first byte shall contain the length of the DER-encoded OID
    /// value, followed by the OID value (for instance, OID 2.5.4.3,
    /// for id-at-commonName, will be `03 55 04 03`). This is
    /// equivalent to full DER encoding with the length but without
    /// the tag.
    ///
    /// For SAN name elements, the first byte (`oid[0]`) has value 0,
    /// followed by another byte that matches the expected GeneralName
    /// tag. Allowed second byte values are then:
    ///
    /// - 1: `rfc822Name`
    ///
    /// - 2: `dNSName`
    ///
    /// - 6: `uniformResourceIdentifier`
    ///
    /// - 0: `otherName`
    ///
    /// If first and second byte are 0, then this is a SAN element of
    /// type `otherName`; the `oid[]` array should then contain, right
    /// after the two bytes of value 0, an encoded OID (with the same
    /// conventions as for X.500 name elements). If a match is found
    /// for that OID, then the corresponding name element will be
    /// extracted, as long as it is a supported string type. 
 pub oid : * const :: std :: os :: raw :: c_uchar , 
 /// \brief Destination buffer. 
 pub buf : * mut :: std :: os :: raw :: c_char , 
 /// \brief Length (in bytes) of the destination buffer.
    ///
    /// The buffer MUST NOT be smaller than 1 byte. 
 pub len : usize , 
 /// \brief Decoding status.
    ///
    /// Status is 0 if the name element was not found, 1 if it was
    /// found and decoded, or -1 on error. Error conditions include
    /// an unrecognised encoding, an invalid encoding, or a string
    /// too large for the destination buffer. 
 pub status : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_br_name_element ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_name_element > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_name_element ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_name_element > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_name_element ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_name_element > ( ) ) ) . oid as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_name_element ) , "::" , stringify ! ( oid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_name_element > ( ) ) ) . buf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_name_element ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_name_element > ( ) ) ) . len as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_name_element ) , "::" , stringify ! ( len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_name_element > ( ) ) ) . status as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_name_element ) , "::" , stringify ! ( status ) ) ) ; } 
 /// \brief The "minimal" X.509 engine structure.
///
/// The structure contents are opaque (they shall not be accessed directly),
/// except for the first field (the vtable).
///
/// The "minimal" engine performs a rudimentary but serviceable X.509 path
/// validation. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_x509_minimal_context { pub vtable : * const br_x509_class , pub pkey : br_x509_pkey , pub cpu : br_x509_minimal_context__bindgen_ty_1 , pub dp_stack : [ u32 ; 32usize ] , pub rp_stack : [ u32 ; 32usize ] , pub err : :: std :: os :: raw :: c_int , pub server_name : * const :: std :: os :: raw :: c_char , pub key_usages : :: std :: os :: raw :: c_uchar , pub days : u32 , pub seconds : u32 , pub cert_length : u32 , pub num_certs : u32 , pub hbuf : * const :: std :: os :: raw :: c_uchar , pub hlen : usize , pub pad : [ :: std :: os :: raw :: c_uchar ; 256usize ] , pub ee_pkey_data : [ :: std :: os :: raw :: c_uchar ; 520usize ] , pub pkey_data : [ :: std :: os :: raw :: c_uchar ; 520usize ] , pub cert_signer_key_type : :: std :: os :: raw :: c_uchar , pub cert_sig_hash_oid : u16 , pub cert_sig_hash_len : :: std :: os :: raw :: c_uchar , pub cert_sig : [ :: std :: os :: raw :: c_uchar ; 512usize ] , pub cert_sig_len : u16 , pub min_rsa_size : i16 , pub trust_anchors : * const br_x509_trust_anchor , pub trust_anchors_num : usize , pub do_mhash : :: std :: os :: raw :: c_uchar , pub mhash : br_multihash_context , pub tbs_hash : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub do_dn_hash : :: std :: os :: raw :: c_uchar , pub dn_hash_impl : * const br_hash_class , pub dn_hash : br_hash_compat_context , pub current_dn_hash : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub next_dn_hash : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub saved_dn_hash : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub name_elts : * mut br_name_element , pub num_name_elts : usize , pub irsa : br_rsa_pkcs1_vrfy , pub iecdsa : br_ecdsa_vrfy , pub iec : * const br_ec_impl , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_x509_minimal_context__bindgen_ty_1 { pub dp : * mut u32 , pub rp : * mut u32 , pub ip : * const :: std :: os :: raw :: c_uchar , } # [ test ] fn bindgen_test_layout_br_x509_minimal_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_minimal_context__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_x509_minimal_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_minimal_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_minimal_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context__bindgen_ty_1 > ( ) ) ) . dp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context__bindgen_ty_1 ) , "::" , stringify ! ( dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context__bindgen_ty_1 > ( ) ) ) . rp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context__bindgen_ty_1 ) , "::" , stringify ! ( rp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context__bindgen_ty_1 > ( ) ) ) . ip as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context__bindgen_ty_1 ) , "::" , stringify ! ( ip ) ) ) ; } # [ test ] fn bindgen_test_layout_br_x509_minimal_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_minimal_context > ( ) , 3168usize , concat ! ( "Size of: " , stringify ! ( br_x509_minimal_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_minimal_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_minimal_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . pkey as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( pkey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . cpu as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( cpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . dp_stack as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( dp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . rp_stack as * const _ as usize } , 200usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( rp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . err as * const _ as usize } , 328usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . server_name as * const _ as usize } , 336usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( server_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . key_usages as * const _ as usize } , 344usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( key_usages ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . days as * const _ as usize } , 348usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( days ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . seconds as * const _ as usize } , 352usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( seconds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . cert_length as * const _ as usize } , 356usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( cert_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . num_certs as * const _ as usize } , 360usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( num_certs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . hbuf as * const _ as usize } , 368usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( hbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . hlen as * const _ as usize } , 376usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( hlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . pad as * const _ as usize } , 384usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( pad ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . ee_pkey_data as * const _ as usize } , 640usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( ee_pkey_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . pkey_data as * const _ as usize } , 1160usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( pkey_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . cert_signer_key_type as * const _ as usize } , 1680usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( cert_signer_key_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . cert_sig_hash_oid as * const _ as usize } , 1682usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( cert_sig_hash_oid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . cert_sig_hash_len as * const _ as usize } , 1684usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( cert_sig_hash_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . cert_sig as * const _ as usize } , 1685usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( cert_sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . cert_sig_len as * const _ as usize } , 2198usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( cert_sig_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . min_rsa_size as * const _ as usize } , 2200usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( min_rsa_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . trust_anchors as * const _ as usize } , 2208usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( trust_anchors ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . trust_anchors_num as * const _ as usize } , 2216usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( trust_anchors_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . do_mhash as * const _ as usize } , 2224usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( do_mhash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . mhash as * const _ as usize } , 2232usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( mhash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . tbs_hash as * const _ as usize } , 2648usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( tbs_hash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . do_dn_hash as * const _ as usize } , 2712usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( do_dn_hash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . dn_hash_impl as * const _ as usize } , 2720usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( dn_hash_impl ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . dn_hash as * const _ as usize } , 2728usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( dn_hash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . current_dn_hash as * const _ as usize } , 2936usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( current_dn_hash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . next_dn_hash as * const _ as usize } , 3000usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( next_dn_hash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . saved_dn_hash as * const _ as usize } , 3064usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( saved_dn_hash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . name_elts as * const _ as usize } , 3128usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( name_elts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . num_name_elts as * const _ as usize } , 3136usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( num_name_elts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . irsa as * const _ as usize } , 3144usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( irsa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . iecdsa as * const _ as usize } , 3152usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( iecdsa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_minimal_context > ( ) ) ) . iec as * const _ as usize } , 3160usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_minimal_context ) , "::" , stringify ! ( iec ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_x509_minimal_vtable" ] 
 pub static mut  br_x509_minimal_vtable  :  br_x509_class ;
} extern "C" {
 
 /// \brief Initialise a "minimal" X.509 engine.
///
/// The `dn_hash_impl` parameter shall be a hash function internally used
/// to match X.500 names (subject/issuer DN, and anchor names). Any standard
/// hash function may be used, but a collision-resistant hash function is
/// advised.
///
/// After initialization, some implementations for signature verification
/// (hash functions and signature algorithms) MUST be added.
///
/// \param ctx                 context to initialise.
/// \param dn_hash_impl        hash function for DN comparisons.
/// \param trust_anchors       trust anchors.
/// \param trust_anchors_num   number of trust anchors. 
 
 pub fn br_x509_minimal_init ( ctx : * mut br_x509_minimal_context , dn_hash_impl : * const br_hash_class , trust_anchors : * const br_x509_trust_anchor , trust_anchors_num : usize , ) ; 
} extern "C" {
 
 /// \brief Initialise a "minimal" X.509 engine with default algorithms.
///
/// This function performs the same job as `br_x509_minimal_init()`, but
/// also sets implementations for RSA, ECDSA, and the standard hash
/// functions.
///
/// \param ctx                 context to initialise.
/// \param trust_anchors       trust anchors.
/// \param trust_anchors_num   number of trust anchors. 
 
 pub fn br_x509_minimal_init_full ( ctx : * mut br_x509_minimal_context , trust_anchors : * const br_x509_trust_anchor , trust_anchors_num : usize , ) ; 
} 
 /// \brief X.509 decoder context.
///
/// This structure is _not_ for X.509 validation, but for extracting
/// names and public keys from encoded certificates. Intended usage is
/// to use (self-signed) certificates as trust anchors.
///
/// Contents are opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_x509_decoder_context { pub pkey : br_x509_pkey , pub cpu : br_x509_decoder_context__bindgen_ty_1 , pub dp_stack : [ u32 ; 32usize ] , pub rp_stack : [ u32 ; 32usize ] , pub err : :: std :: os :: raw :: c_int , pub pad : [ :: std :: os :: raw :: c_uchar ; 256usize ] , pub decoded : :: std :: os :: raw :: c_uchar , pub notbefore_days : u32 , pub notbefore_seconds : u32 , pub notafter_days : u32 , pub notafter_seconds : u32 , pub isCA : :: std :: os :: raw :: c_uchar , pub copy_dn : :: std :: os :: raw :: c_uchar , pub append_dn_ctx : * mut :: std :: os :: raw :: c_void , pub append_dn : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , buf : * const :: std :: os :: raw :: c_void , len : usize ) > , pub hbuf : * const :: std :: os :: raw :: c_uchar , pub hlen : usize , pub pkey_data : [ :: std :: os :: raw :: c_uchar ; 520usize ] , pub signer_key_type : :: std :: os :: raw :: c_uchar , pub signer_hash_id : :: std :: os :: raw :: c_uchar , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_x509_decoder_context__bindgen_ty_1 { pub dp : * mut u32 , pub rp : * mut u32 , pub ip : * const :: std :: os :: raw :: c_uchar , } # [ test ] fn bindgen_test_layout_br_x509_decoder_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_decoder_context__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_x509_decoder_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_decoder_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_decoder_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context__bindgen_ty_1 > ( ) ) ) . dp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context__bindgen_ty_1 ) , "::" , stringify ! ( dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context__bindgen_ty_1 > ( ) ) ) . rp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context__bindgen_ty_1 ) , "::" , stringify ! ( rp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context__bindgen_ty_1 > ( ) ) ) . ip as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context__bindgen_ty_1 ) , "::" , stringify ! ( ip ) ) ) ; } # [ test ] fn bindgen_test_layout_br_x509_decoder_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_decoder_context > ( ) , 1168usize , concat ! ( "Size of: " , stringify ! ( br_x509_decoder_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_decoder_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_decoder_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . pkey as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( pkey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . cpu as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( cpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . dp_stack as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( dp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . rp_stack as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( rp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . err as * const _ as usize } , 320usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . pad as * const _ as usize } , 324usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( pad ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . decoded as * const _ as usize } , 580usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( decoded ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . notbefore_days as * const _ as usize } , 584usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( notbefore_days ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . notbefore_seconds as * const _ as usize } , 588usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( notbefore_seconds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . notafter_days as * const _ as usize } , 592usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( notafter_days ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . notafter_seconds as * const _ as usize } , 596usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( notafter_seconds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . isCA as * const _ as usize } , 600usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( isCA ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . copy_dn as * const _ as usize } , 601usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( copy_dn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . append_dn_ctx as * const _ as usize } , 608usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( append_dn_ctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . append_dn as * const _ as usize } , 616usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( append_dn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . hbuf as * const _ as usize } , 624usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( hbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . hlen as * const _ as usize } , 632usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( hlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . pkey_data as * const _ as usize } , 640usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( pkey_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . signer_key_type as * const _ as usize } , 1160usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( signer_key_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_decoder_context > ( ) ) ) . signer_hash_id as * const _ as usize } , 1161usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_decoder_context ) , "::" , stringify ! ( signer_hash_id ) ) ) ; } extern "C" {
 
 /// \brief Initialise an X.509 decoder context for processing a new
/// certificate.
///
/// The `append_dn()` callback (with opaque context `append_dn_ctx`)
/// will be invoked to receive, chunk by chunk, the certificate's
/// subject DN. If `append_dn` is `0` then the subject DN will be
/// ignored.
///
/// \param ctx             X.509 decoder context to initialise.
/// \param append_dn       DN receiver callback (or `0`).
/// \param append_dn_ctx   context for the DN receiver callback. 
 
 pub fn br_x509_decoder_init ( ctx : * mut br_x509_decoder_context , append_dn : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , buf : * const :: std :: os :: raw :: c_void , len : usize ) > , append_dn_ctx : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Push some certificate bytes into a decoder context.
///
/// If `len` is non-zero, then that many bytes are pushed, from address
/// `data`, into the provided decoder context.
///
/// \param ctx    X.509 decoder context.
/// \param data   certificate data chunk.
/// \param len    certificate data chunk length (in bytes). 
 
 pub fn br_x509_decoder_push ( ctx : * mut br_x509_decoder_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} 
 /// \brief Type for an X.509 certificate (DER-encoded). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_x509_certificate { 
 /// \brief The DER-encoded certificate data. 
 pub data : * mut :: std :: os :: raw :: c_uchar , 
 /// \brief The DER-encoded certificate length (in bytes). 
 pub data_len : usize , } # [ test ] fn bindgen_test_layout_br_x509_certificate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_x509_certificate > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( br_x509_certificate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_x509_certificate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_x509_certificate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_certificate > ( ) ) ) . data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_certificate ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_x509_certificate > ( ) ) ) . data_len as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_x509_certificate ) , "::" , stringify ! ( data_len ) ) ) ; } 
 /// \brief Private key decoder context.
///
/// The private key decoder recognises RSA and EC private keys, either in
/// their raw, DER-encoded format, or wrapped in an unencrypted PKCS#8
/// archive (again DER-encoded).
///
/// Structure contents are opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_skey_decoder_context { pub key : br_skey_decoder_context__bindgen_ty_1 , pub cpu : br_skey_decoder_context__bindgen_ty_2 , pub dp_stack : [ u32 ; 32usize ] , pub rp_stack : [ u32 ; 32usize ] , pub err : :: std :: os :: raw :: c_int , pub hbuf : * const :: std :: os :: raw :: c_uchar , pub hlen : usize , pub pad : [ :: std :: os :: raw :: c_uchar ; 256usize ] , pub key_type : :: std :: os :: raw :: c_uchar , pub key_data : [ :: std :: os :: raw :: c_uchar ; 1536usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_skey_decoder_context__bindgen_ty_1 { pub rsa : br_rsa_private_key , pub ec : br_ec_private_key , _bindgen_union_align : [ u64 ; 11usize ] , } # [ test ] fn bindgen_test_layout_br_skey_decoder_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_skey_decoder_context__bindgen_ty_1 > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( br_skey_decoder_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_skey_decoder_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_skey_decoder_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context__bindgen_ty_1 > ( ) ) ) . rsa as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context__bindgen_ty_1 ) , "::" , stringify ! ( rsa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context__bindgen_ty_1 > ( ) ) ) . ec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context__bindgen_ty_1 ) , "::" , stringify ! ( ec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_skey_decoder_context__bindgen_ty_2 { pub dp : * mut u32 , pub rp : * mut u32 , pub ip : * const :: std :: os :: raw :: c_uchar , } # [ test ] fn bindgen_test_layout_br_skey_decoder_context__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_skey_decoder_context__bindgen_ty_2 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_skey_decoder_context__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_skey_decoder_context__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_skey_decoder_context__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context__bindgen_ty_2 > ( ) ) ) . dp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context__bindgen_ty_2 ) , "::" , stringify ! ( dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context__bindgen_ty_2 > ( ) ) ) . rp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context__bindgen_ty_2 ) , "::" , stringify ! ( rp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context__bindgen_ty_2 > ( ) ) ) . ip as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context__bindgen_ty_2 ) , "::" , stringify ! ( ip ) ) ) ; } # [ test ] fn bindgen_test_layout_br_skey_decoder_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_skey_decoder_context > ( ) , 2192usize , concat ! ( "Size of: " , stringify ! ( br_skey_decoder_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_skey_decoder_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_skey_decoder_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . key as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . cpu as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( cpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . dp_stack as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( dp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . rp_stack as * const _ as usize } , 240usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( rp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . err as * const _ as usize } , 368usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . hbuf as * const _ as usize } , 376usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( hbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . hlen as * const _ as usize } , 384usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( hlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . pad as * const _ as usize } , 392usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( pad ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . key_type as * const _ as usize } , 648usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( key_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_skey_decoder_context > ( ) ) ) . key_data as * const _ as usize } , 649usize , concat ! ( "Offset of field: " , stringify ! ( br_skey_decoder_context ) , "::" , stringify ! ( key_data ) ) ) ; } extern "C" {
 
 /// \brief Initialise a private key decoder context.
///
/// \param ctx   key decoder context to initialise. 
 
 pub fn br_skey_decoder_init ( ctx : * mut br_skey_decoder_context , ) ; 
} extern "C" {
 
 /// \brief Push some data bytes into a private key decoder context.
///
/// If `len` is non-zero, then that many data bytes, starting at address
/// `data`, are pushed into the decoder.
///
/// \param ctx    key decoder context.
/// \param data   private key data chunk.
/// \param len    private key data chunk length (in bytes). 
 
 pub fn br_skey_decoder_push ( ctx : * mut br_skey_decoder_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} 
 /// \brief Decryption engine for SSL.
///
/// When processing incoming records, the SSL engine will use a decryption
/// engine that uses a specific context structure, and has a set of
/// methods (a vtable) that follows this template.
///
/// The decryption engine is responsible for applying decryption, verifying
/// MAC, and keeping track of the record sequence number. 
 pub type br_sslrec_in_class = br_sslrec_in_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_in_class_ { 
 /// \brief Context size (in bytes). 
 pub context_size : usize , 
 /// \brief Test validity of the incoming record length.
    ///
    /// This function returns 1 if the announced length for an
    /// incoming record is valid, 0 otherwise,
    ///
    /// \param ctx          decryption engine context.
    /// \param record_len   incoming record length.
    /// \return  1 of a valid length, 0 otherwise. 
 pub check_length : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_sslrec_in_class , record_len : usize ) -> :: std :: os :: raw :: c_int > , 
 /// \brief Decrypt the incoming record.
    ///
    /// This function may assume that the record length is valid
    /// (it has been previously tested with `check_length()`).
    /// Decryption is done in place; `*len` is updated with the
    /// cleartext length, and the address of the first plaintext
    /// byte is returned. If the record is correct but empty, then
    /// `*len` is set to 0 and a non-`NULL` pointer is returned.
    ///
    /// On decryption/MAC error, `NULL` is returned.
    ///
    /// \param ctx           decryption engine context.
    /// \param record_type   record type (23 for application data, etc).
    /// \param version       record version.
    /// \param payload       address of encrypted payload.
    /// \param len           pointer to payload length (updated).
    /// \return  pointer to plaintext, or `NULL` on error. 
 pub decrypt : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_sslrec_in_class , record_type : :: std :: os :: raw :: c_int , version : :: std :: os :: raw :: c_uint , payload : * mut :: std :: os :: raw :: c_void , len : * mut usize ) -> * mut :: std :: os :: raw :: c_uchar > , } # [ test ] fn bindgen_test_layout_br_sslrec_in_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_in_class_ > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_in_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_in_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_in_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_class_ > ( ) ) ) . check_length as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_class_ ) , "::" , stringify ! ( check_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_class_ > ( ) ) ) . decrypt as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_class_ ) , "::" , stringify ! ( decrypt ) ) ) ; } 
 /// \brief Encryption engine for SSL.
///
/// When building outgoing records, the SSL engine will use an encryption
/// engine that uses a specific context structure, and has a set of
/// methods (a vtable) that follows this template.
///
/// The encryption engine is responsible for applying encryption and MAC,
/// and keeping track of the record sequence number. 
 pub type br_sslrec_out_class = br_sslrec_out_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_out_class_ { 
 /// \brief Context size (in bytes). 
 pub context_size : usize , 
 /// \brief Compute maximum plaintext sizes and offsets.
    ///
    /// When this function is called, the `*start` and `*end`
    /// values contain offsets designating the free area in the
    /// outgoing buffer for plaintext data; that free area is
    /// preceded by a 5-byte space which will receive the record
    /// header.
    ///
    /// The `max_plaintext()` function is responsible for adjusting
    /// both `*start` and `*end` to make room for any record-specific
    /// header, MAC, padding, and possible split.
    ///
    /// \param ctx     encryption engine context.
    /// \param start   pointer to start of plaintext offset (updated).
    /// \param end     pointer to start of plaintext offset (updated). 
 pub max_plaintext : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * const * const br_sslrec_out_class , start : * mut usize , end : * mut usize ) > , 
 /// \brief Perform record encryption.
    ///
    /// This function encrypts the record. The plaintext address and
    /// length are provided. Returned value is the start of the
    /// encrypted record (or sequence of records, if a split was
    /// performed), _including_ the 5-byte header, and `*len` is
    /// adjusted to the total size of the record(s), there again
    /// including the header(s).
    ///
    /// \param ctx           decryption engine context.
    /// \param record_type   record type (23 for application data, etc).
    /// \param version       record version.
    /// \param plaintext     address of plaintext.
    /// \param len           pointer to plaintext length (updated).
    /// \return  pointer to start of built record. 
 pub encrypt : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_sslrec_out_class , record_type : :: std :: os :: raw :: c_int , version : :: std :: os :: raw :: c_uint , plaintext : * mut :: std :: os :: raw :: c_void , len : * mut usize ) -> * mut :: std :: os :: raw :: c_uchar > , } # [ test ] fn bindgen_test_layout_br_sslrec_out_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_out_class_ > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_out_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_out_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_out_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_class_ > ( ) ) ) . max_plaintext as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_class_ ) , "::" , stringify ! ( max_plaintext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_class_ > ( ) ) ) . encrypt as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_class_ ) , "::" , stringify ! ( encrypt ) ) ) ; } 
 /// \brief Context for a no-encryption engine.
///
/// The no-encryption engine processes outgoing records during the initial
/// handshake, before encryption is applied. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_out_clear_context { 
 /// \brief No-encryption engine vtable. 
 pub vtable : * const br_sslrec_out_class , } # [ test ] fn bindgen_test_layout_br_sslrec_out_clear_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_out_clear_context > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_out_clear_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_out_clear_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_out_clear_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_clear_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_clear_context ) , "::" , stringify ! ( vtable ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_sslrec_out_clear_vtable" ] 
 pub static mut  br_sslrec_out_clear_vtable  :  br_sslrec_out_class ;
} 
 /// \brief Record decryption engine class, for CBC mode.
///
/// This class type extends the decryption engine class with an
/// initialisation method that receives the parameters needed
/// for CBC processing: block cipher implementation, block cipher key,
/// HMAC parameters (hash function, key, MAC length), and IV. If the
/// IV is `NULL`, then a per-record IV will be used (TLS 1.1+). 
 pub type br_sslrec_in_cbc_class = br_sslrec_in_cbc_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_in_cbc_class_ { 
 /// \brief Superclass, as first vtable field. 
 pub inner : br_sslrec_in_class , 
 /// \brief Engine initialisation method.
    ///
    /// This method sets the vtable field in the context.
    ///
    /// \param ctx           context to initialise.
    /// \param bc_impl       block cipher implementation (CBC decryption).
    /// \param bc_key        block cipher key.
    /// \param bc_key_len    block cipher key length (in bytes).
    /// \param dig_impl      hash function for HMAC.
    /// \param mac_key       HMAC key.
    /// \param mac_key_len   HMAC key length (in bytes).
    /// \param mac_out_len   HMAC output length (in bytes).
    /// \param iv            initial IV (or `NULL`). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_sslrec_in_cbc_class , bc_impl : * const br_block_cbcdec_class , bc_key : * const :: std :: os :: raw :: c_void , bc_key_len : usize , dig_impl : * const br_hash_class , mac_key : * const :: std :: os :: raw :: c_void , mac_key_len : usize , mac_out_len : usize , iv : * const :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_br_sslrec_in_cbc_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_in_cbc_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_in_cbc_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_in_cbc_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_in_cbc_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_class_ > ( ) ) ) . inner as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_class_ ) , "::" , stringify ! ( inner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_class_ > ( ) ) ) . init as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_class_ ) , "::" , stringify ! ( init ) ) ) ; } 
 /// \brief Record encryption engine class, for CBC mode.
///
/// This class type extends the encryption engine class with an
/// initialisation method that receives the parameters needed
/// for CBC processing: block cipher implementation, block cipher key,
/// HMAC parameters (hash function, key, MAC length), and IV. If the
/// IV is `NULL`, then a per-record IV will be used (TLS 1.1+). 
 pub type br_sslrec_out_cbc_class = br_sslrec_out_cbc_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_out_cbc_class_ { 
 /// \brief Superclass, as first vtable field. 
 pub inner : br_sslrec_out_class , 
 /// \brief Engine initialisation method.
    ///
    /// This method sets the vtable field in the context.
    ///
    /// \param ctx           context to initialise.
    /// \param bc_impl       block cipher implementation (CBC encryption).
    /// \param bc_key        block cipher key.
    /// \param bc_key_len    block cipher key length (in bytes).
    /// \param dig_impl      hash function for HMAC.
    /// \param mac_key       HMAC key.
    /// \param mac_key_len   HMAC key length (in bytes).
    /// \param mac_out_len   HMAC output length (in bytes).
    /// \param iv            initial IV (or `NULL`). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_sslrec_out_cbc_class , bc_impl : * const br_block_cbcenc_class , bc_key : * const :: std :: os :: raw :: c_void , bc_key_len : usize , dig_impl : * const br_hash_class , mac_key : * const :: std :: os :: raw :: c_void , mac_key_len : usize , mac_out_len : usize , iv : * const :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_br_sslrec_out_cbc_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_out_cbc_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_out_cbc_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_out_cbc_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_out_cbc_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_class_ > ( ) ) ) . inner as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_class_ ) , "::" , stringify ! ( inner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_class_ > ( ) ) ) . init as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_class_ ) , "::" , stringify ! ( init ) ) ) ; } 
 /// \brief Context structure for decrypting incoming records with
/// CBC + HMAC.
///
/// The first field points to the vtable. The other fields are opaque
/// and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_sslrec_in_cbc_context { 
 /// \brief Pointer to vtable. 
 pub vtable : * const br_sslrec_in_cbc_class , pub seq : u64 , pub bc : br_sslrec_in_cbc_context__bindgen_ty_1 , pub mac : br_hmac_key_context , pub mac_len : usize , pub iv : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub explicit_IV : :: std :: os :: raw :: c_int , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_sslrec_in_cbc_context__bindgen_ty_1 { pub vtable : * const br_block_cbcdec_class , pub aes : br_aes_gen_cbcdec_keys , pub des : br_des_gen_cbcdec_keys , _bindgen_union_align : [ u64 ; 50usize ] , } # [ test ] fn bindgen_test_layout_br_sslrec_in_cbc_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_in_cbc_context__bindgen_ty_1 > ( ) , 400usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_in_cbc_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_in_cbc_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_in_cbc_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context__bindgen_ty_1 > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context__bindgen_ty_1 ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context__bindgen_ty_1 > ( ) ) ) . aes as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context__bindgen_ty_1 ) , "::" , stringify ! ( aes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context__bindgen_ty_1 > ( ) ) ) . des as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context__bindgen_ty_1 ) , "::" , stringify ! ( des ) ) ) ; } # [ test ] fn bindgen_test_layout_br_sslrec_in_cbc_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_in_cbc_context > ( ) , 584usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_in_cbc_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_in_cbc_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_in_cbc_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context > ( ) ) ) . seq as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context ) , "::" , stringify ! ( seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context > ( ) ) ) . bc as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context ) , "::" , stringify ! ( bc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context > ( ) ) ) . mac as * const _ as usize } , 416usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context ) , "::" , stringify ! ( mac ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context > ( ) ) ) . mac_len as * const _ as usize } , 552usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context ) , "::" , stringify ! ( mac_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context > ( ) ) ) . iv as * const _ as usize } , 560usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context ) , "::" , stringify ! ( iv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_cbc_context > ( ) ) ) . explicit_IV as * const _ as usize } , 576usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_cbc_context ) , "::" , stringify ! ( explicit_IV ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_sslrec_in_cbc_vtable" ] 
 pub static mut  br_sslrec_in_cbc_vtable  :  br_sslrec_in_cbc_class ;
} 
 /// \brief Context structure for encrypting outgoing records with
/// CBC + HMAC.
///
/// The first field points to the vtable. The other fields are opaque
/// and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_sslrec_out_cbc_context { 
 /// \brief Pointer to vtable. 
 pub vtable : * const br_sslrec_out_cbc_class , pub seq : u64 , pub bc : br_sslrec_out_cbc_context__bindgen_ty_1 , pub mac : br_hmac_key_context , pub mac_len : usize , pub iv : [ :: std :: os :: raw :: c_uchar ; 16usize ] , pub explicit_IV : :: std :: os :: raw :: c_int , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_sslrec_out_cbc_context__bindgen_ty_1 { pub vtable : * const br_block_cbcenc_class , pub aes : br_aes_gen_cbcenc_keys , pub des : br_des_gen_cbcenc_keys , _bindgen_union_align : [ u64 ; 50usize ] , } # [ test ] fn bindgen_test_layout_br_sslrec_out_cbc_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_out_cbc_context__bindgen_ty_1 > ( ) , 400usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_out_cbc_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_out_cbc_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_out_cbc_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context__bindgen_ty_1 > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context__bindgen_ty_1 ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context__bindgen_ty_1 > ( ) ) ) . aes as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context__bindgen_ty_1 ) , "::" , stringify ! ( aes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context__bindgen_ty_1 > ( ) ) ) . des as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context__bindgen_ty_1 ) , "::" , stringify ! ( des ) ) ) ; } # [ test ] fn bindgen_test_layout_br_sslrec_out_cbc_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_out_cbc_context > ( ) , 584usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_out_cbc_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_out_cbc_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_out_cbc_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context > ( ) ) ) . seq as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context ) , "::" , stringify ! ( seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context > ( ) ) ) . bc as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context ) , "::" , stringify ! ( bc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context > ( ) ) ) . mac as * const _ as usize } , 416usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context ) , "::" , stringify ! ( mac ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context > ( ) ) ) . mac_len as * const _ as usize } , 552usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context ) , "::" , stringify ! ( mac_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context > ( ) ) ) . iv as * const _ as usize } , 560usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context ) , "::" , stringify ! ( iv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_cbc_context > ( ) ) ) . explicit_IV as * const _ as usize } , 576usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_cbc_context ) , "::" , stringify ! ( explicit_IV ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_sslrec_out_cbc_vtable" ] 
 pub static mut  br_sslrec_out_cbc_vtable  :  br_sslrec_out_cbc_class ;
} 
 /// \brief Record decryption engine class, for GCM mode.
///
/// This class type extends the decryption engine class with an
/// initialisation method that receives the parameters needed
/// for GCM processing: block cipher implementation, block cipher key,
/// GHASH implementation, and 4-byte IV. 
 pub type br_sslrec_in_gcm_class = br_sslrec_in_gcm_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_in_gcm_class_ { 
 /// \brief Superclass, as first vtable field. 
 pub inner : br_sslrec_in_class , 
 /// \brief Engine initialisation method.
    ///
    /// This method sets the vtable field in the context.
    ///
    /// \param ctx           context to initialise.
    /// \param bc_impl       block cipher implementation (CTR).
    /// \param key           block cipher key.
    /// \param key_len       block cipher key length (in bytes).
    /// \param gh_impl       GHASH implementation.
    /// \param iv            static IV (4 bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_sslrec_in_gcm_class , bc_impl : * const br_block_ctr_class , key : * const :: std :: os :: raw :: c_void , key_len : usize , gh_impl : br_ghash , iv : * const :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_br_sslrec_in_gcm_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_in_gcm_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_in_gcm_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_in_gcm_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_in_gcm_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_gcm_class_ > ( ) ) ) . inner as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_gcm_class_ ) , "::" , stringify ! ( inner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_gcm_class_ > ( ) ) ) . init as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_gcm_class_ ) , "::" , stringify ! ( init ) ) ) ; } 
 /// \brief Record encryption engine class, for GCM mode.
///
/// This class type extends the encryption engine class with an
/// initialisation method that receives the parameters needed
/// for GCM processing: block cipher implementation, block cipher key,
/// GHASH implementation, and 4-byte IV. 
 pub type br_sslrec_out_gcm_class = br_sslrec_out_gcm_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_out_gcm_class_ { 
 /// \brief Superclass, as first vtable field. 
 pub inner : br_sslrec_out_class , 
 /// \brief Engine initialisation method.
    ///
    /// This method sets the vtable field in the context.
    ///
    /// \param ctx           context to initialise.
    /// \param bc_impl       block cipher implementation (CTR).
    /// \param key           block cipher key.
    /// \param key_len       block cipher key length (in bytes).
    /// \param gh_impl       GHASH implementation.
    /// \param iv            static IV (4 bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_sslrec_out_gcm_class , bc_impl : * const br_block_ctr_class , key : * const :: std :: os :: raw :: c_void , key_len : usize , gh_impl : br_ghash , iv : * const :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_br_sslrec_out_gcm_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_out_gcm_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_out_gcm_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_out_gcm_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_out_gcm_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_gcm_class_ > ( ) ) ) . inner as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_gcm_class_ ) , "::" , stringify ! ( inner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_gcm_class_ > ( ) ) ) . init as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_gcm_class_ ) , "::" , stringify ! ( init ) ) ) ; } 
 /// \brief Context structure for processing records with GCM.
///
/// The same context structure is used for encrypting and decrypting.
///
/// The first field points to the vtable. The other fields are opaque
/// and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_sslrec_gcm_context { pub vtable : br_sslrec_gcm_context__bindgen_ty_1 , pub seq : u64 , pub bc : br_sslrec_gcm_context__bindgen_ty_2 , pub gh : br_ghash , pub iv : [ :: std :: os :: raw :: c_uchar ; 4usize ] , pub h : [ :: std :: os :: raw :: c_uchar ; 16usize ] , } 
 /// \brief Pointer to vtable. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_sslrec_gcm_context__bindgen_ty_1 { pub gen : * const :: std :: os :: raw :: c_void , pub in_ : * const br_sslrec_in_gcm_class , pub out : * const br_sslrec_out_gcm_class , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_br_sslrec_gcm_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_gcm_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_gcm_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context__bindgen_ty_1 > ( ) ) ) . gen as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_1 ) , "::" , stringify ! ( gen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context__bindgen_ty_1 > ( ) ) ) . in_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_1 ) , "::" , stringify ! ( in_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context__bindgen_ty_1 > ( ) ) ) . out as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_1 ) , "::" , stringify ! ( out ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_sslrec_gcm_context__bindgen_ty_2 { pub vtable : * const br_block_ctr_class , pub aes : br_aes_gen_ctr_keys , _bindgen_union_align : [ u64 ; 32usize ] , } # [ test ] fn bindgen_test_layout_br_sslrec_gcm_context__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_gcm_context__bindgen_ty_2 > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_gcm_context__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context__bindgen_ty_2 > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_2 ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context__bindgen_ty_2 > ( ) ) ) . aes as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context__bindgen_ty_2 ) , "::" , stringify ! ( aes ) ) ) ; } # [ test ] fn bindgen_test_layout_br_sslrec_gcm_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_gcm_context > ( ) , 304usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_gcm_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_gcm_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_gcm_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context > ( ) ) ) . seq as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context ) , "::" , stringify ! ( seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context > ( ) ) ) . bc as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context ) , "::" , stringify ! ( bc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context > ( ) ) ) . gh as * const _ as usize } , 272usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context ) , "::" , stringify ! ( gh ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context > ( ) ) ) . iv as * const _ as usize } , 280usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context ) , "::" , stringify ! ( iv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_gcm_context > ( ) ) ) . h as * const _ as usize } , 284usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_gcm_context ) , "::" , stringify ! ( h ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_sslrec_in_gcm_vtable" ] 
 pub static mut  br_sslrec_in_gcm_vtable  :  br_sslrec_in_gcm_class ;
} extern "C" {
 # [ link_name = "\u{1}br_sslrec_out_gcm_vtable" ] 
 pub static mut  br_sslrec_out_gcm_vtable  :  br_sslrec_out_gcm_class ;
} 
 /// \brief Record decryption engine class, for ChaCha20+Poly1305.
///
/// This class type extends the decryption engine class with an
/// initialisation method that receives the parameters needed
/// for ChaCha20+Poly1305 processing: ChaCha20 implementation,
/// Poly1305 implementation, key, and 12-byte IV. 
 pub type br_sslrec_in_chapol_class = br_sslrec_in_chapol_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_in_chapol_class_ { 
 /// \brief Superclass, as first vtable field. 
 pub inner : br_sslrec_in_class , 
 /// \brief Engine initialisation method.
    ///
    /// This method sets the vtable field in the context.
    ///
    /// \param ctx           context to initialise.
    /// \param ichacha       ChaCha20 implementation.
    /// \param ipoly         Poly1305 implementation.
    /// \param key           secret key (32 bytes).
    /// \param iv            static IV (12 bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_sslrec_in_chapol_class , ichacha : br_chacha20_run , ipoly : br_poly1305_run , key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_br_sslrec_in_chapol_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_in_chapol_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_in_chapol_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_in_chapol_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_in_chapol_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_chapol_class_ > ( ) ) ) . inner as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_chapol_class_ ) , "::" , stringify ! ( inner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_in_chapol_class_ > ( ) ) ) . init as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_in_chapol_class_ ) , "::" , stringify ! ( init ) ) ) ; } 
 /// \brief Record encryption engine class, for ChaCha20+Poly1305.
///
/// This class type extends the encryption engine class with an
/// initialisation method that receives the parameters needed
/// for ChaCha20+Poly1305 processing: ChaCha20 implementation,
/// Poly1305 implementation, key, and 12-byte IV. 
 pub type br_sslrec_out_chapol_class = br_sslrec_out_chapol_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslrec_out_chapol_class_ { 
 /// \brief Superclass, as first vtable field. 
 pub inner : br_sslrec_out_class , 
 /// \brief Engine initialisation method.
    ///
    /// This method sets the vtable field in the context.
    ///
    /// \param ctx           context to initialise.
    /// \param ichacha       ChaCha20 implementation.
    /// \param ipoly         Poly1305 implementation.
    /// \param key           secret key (32 bytes).
    /// \param iv            static IV (12 bytes). 
 pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_sslrec_out_chapol_class , ichacha : br_chacha20_run , ipoly : br_poly1305_run , key : * const :: std :: os :: raw :: c_void , iv : * const :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_br_sslrec_out_chapol_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_out_chapol_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_out_chapol_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_out_chapol_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_out_chapol_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_chapol_class_ > ( ) ) ) . inner as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_chapol_class_ ) , "::" , stringify ! ( inner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_out_chapol_class_ > ( ) ) ) . init as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_out_chapol_class_ ) , "::" , stringify ! ( init ) ) ) ; } 
 /// \brief Context structure for processing records with ChaCha20+Poly1305.
///
/// The same context structure is used for encrypting and decrypting.
///
/// The first field points to the vtable. The other fields are opaque
/// and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_sslrec_chapol_context { pub vtable : br_sslrec_chapol_context__bindgen_ty_1 , pub seq : u64 , pub key : [ :: std :: os :: raw :: c_uchar ; 32usize ] , pub iv : [ :: std :: os :: raw :: c_uchar ; 12usize ] , pub ichacha : br_chacha20_run , pub ipoly : br_poly1305_run , } 
 /// \brief Pointer to vtable. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_sslrec_chapol_context__bindgen_ty_1 { pub gen : * const :: std :: os :: raw :: c_void , pub in_ : * const br_sslrec_in_chapol_class , pub out : * const br_sslrec_out_chapol_class , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_br_sslrec_chapol_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_chapol_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_chapol_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_chapol_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_chapol_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context__bindgen_ty_1 > ( ) ) ) . gen as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context__bindgen_ty_1 ) , "::" , stringify ! ( gen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context__bindgen_ty_1 > ( ) ) ) . in_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context__bindgen_ty_1 ) , "::" , stringify ! ( in_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context__bindgen_ty_1 > ( ) ) ) . out as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context__bindgen_ty_1 ) , "::" , stringify ! ( out ) ) ) ; } # [ test ] fn bindgen_test_layout_br_sslrec_chapol_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslrec_chapol_context > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( br_sslrec_chapol_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslrec_chapol_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslrec_chapol_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context > ( ) ) ) . seq as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context ) , "::" , stringify ! ( seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context > ( ) ) ) . key as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context ) , "::" , stringify ! ( key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context > ( ) ) ) . iv as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context ) , "::" , stringify ! ( iv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context > ( ) ) ) . ichacha as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context ) , "::" , stringify ! ( ichacha ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslrec_chapol_context > ( ) ) ) . ipoly as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_sslrec_chapol_context ) , "::" , stringify ! ( ipoly ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}br_sslrec_in_chapol_vtable" ] 
 pub static mut  br_sslrec_in_chapol_vtable  :  br_sslrec_in_chapol_class ;
} extern "C" {
 # [ link_name = "\u{1}br_sslrec_out_chapol_vtable" ] 
 pub static mut  br_sslrec_out_chapol_vtable  :  br_sslrec_out_chapol_class ;
} 
 /// \brief Type for session parameters, to be saved for session resumption. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_ssl_session_parameters { 
 /// \brief Session ID buffer. 
 pub session_id : [ :: std :: os :: raw :: c_uchar ; 32usize ] , 
 /// \brief Session ID length (in bytes, at most 32). 
 pub session_id_len : :: std :: os :: raw :: c_uchar , 
 /// \brief Protocol version. 
 pub version : u16 , 
 /// \brief Cipher suite. 
 pub cipher_suite : u16 , 
 /// \brief Master secret. 
 pub master_secret : [ :: std :: os :: raw :: c_uchar ; 48usize ] , } # [ test ] fn bindgen_test_layout_br_ssl_session_parameters ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_session_parameters > ( ) , 86usize , concat ! ( "Size of: " , stringify ! ( br_ssl_session_parameters ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_session_parameters > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_session_parameters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_parameters > ( ) ) ) . session_id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_parameters ) , "::" , stringify ! ( session_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_parameters > ( ) ) ) . session_id_len as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_parameters ) , "::" , stringify ! ( session_id_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_parameters > ( ) ) ) . version as * const _ as usize } , 34usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_parameters ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_parameters > ( ) ) ) . cipher_suite as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_parameters ) , "::" , stringify ! ( cipher_suite ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_parameters > ( ) ) ) . master_secret as * const _ as usize } , 38usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_parameters ) , "::" , stringify ! ( master_secret ) ) ) ; } 
 /// \brief Context structure for SSL engine.
///
/// This strucuture is common to the client and server; both the client
/// context (`br_ssl_client_context`) and the server context
/// (`br_ssl_server_context`) include a `br_ssl_engine_context` as their
/// first field.
///
/// The engine context manages records, including alerts, closures, and
/// transitions to new encryption/MAC algorithms. Processing of handshake
/// records is delegated to externally provided code. This structure
/// should not be used directly.
///
/// Structure contents are opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_ssl_engine_context { pub err : :: std :: os :: raw :: c_int , pub ibuf : * mut :: std :: os :: raw :: c_uchar , pub obuf : * mut :: std :: os :: raw :: c_uchar , pub ibuf_len : usize , pub obuf_len : usize , pub max_frag_len : u16 , pub log_max_frag_len : :: std :: os :: raw :: c_uchar , pub peer_log_max_frag_len : :: std :: os :: raw :: c_uchar , pub ixa : usize , pub ixb : usize , pub ixc : usize , pub oxa : usize , pub oxb : usize , pub oxc : usize , pub iomode : :: std :: os :: raw :: c_uchar , pub incrypt : :: std :: os :: raw :: c_uchar , pub shutdown_recv : :: std :: os :: raw :: c_uchar , pub record_type_in : :: std :: os :: raw :: c_uchar , pub record_type_out : :: std :: os :: raw :: c_uchar , pub version_in : u16 , pub version_out : u16 , pub in_ : br_ssl_engine_context__bindgen_ty_1 , pub out : br_ssl_engine_context__bindgen_ty_2 , pub application_data : :: std :: os :: raw :: c_uchar , pub rng : br_hmac_drbg_context , pub rng_init_done : :: std :: os :: raw :: c_int , pub rng_os_rand_done : :: std :: os :: raw :: c_int , pub version_min : u16 , pub version_max : u16 , pub suites_buf : [ u16 ; 40usize ] , pub suites_num : :: std :: os :: raw :: c_uchar , pub server_name : [ :: std :: os :: raw :: c_char ; 256usize ] , pub client_random : [ :: std :: os :: raw :: c_uchar ; 32usize ] , pub server_random : [ :: std :: os :: raw :: c_uchar ; 32usize ] , pub session : br_ssl_session_parameters , pub ecdhe_curve : :: std :: os :: raw :: c_uchar , pub ecdhe_point : [ :: std :: os :: raw :: c_uchar ; 133usize ] , pub ecdhe_point_len : :: std :: os :: raw :: c_uchar , pub reneg : :: std :: os :: raw :: c_uchar , pub saved_finished : [ :: std :: os :: raw :: c_uchar ; 24usize ] , pub flags : u32 , pub cpu : br_ssl_engine_context__bindgen_ty_3 , pub dp_stack : [ u32 ; 32usize ] , pub rp_stack : [ u32 ; 32usize ] , pub pad : [ :: std :: os :: raw :: c_uchar ; 512usize ] , pub hbuf_in : * mut :: std :: os :: raw :: c_uchar , pub hbuf_out : * mut :: std :: os :: raw :: c_uchar , pub saved_hbuf_out : * mut :: std :: os :: raw :: c_uchar , pub hlen_in : usize , pub hlen_out : usize , pub hsrun : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) > , pub action : :: std :: os :: raw :: c_uchar , pub alert : :: std :: os :: raw :: c_uchar , pub close_received : :: std :: os :: raw :: c_uchar , pub mhash : br_multihash_context , pub x509ctx : * mut * const br_x509_class , pub chain : * const br_x509_certificate , pub chain_len : usize , pub cert_cur : * const :: std :: os :: raw :: c_uchar , pub cert_len : usize , pub protocol_names : * mut * const :: std :: os :: raw :: c_char , pub protocol_names_num : u16 , pub selected_protocol : u16 , pub prf10 : br_tls_prf_impl , pub prf_sha256 : br_tls_prf_impl , pub prf_sha384 : br_tls_prf_impl , pub iaes_cbcenc : * const br_block_cbcenc_class , pub iaes_cbcdec : * const br_block_cbcdec_class , pub iaes_ctr : * const br_block_ctr_class , pub ides_cbcenc : * const br_block_cbcenc_class , pub ides_cbcdec : * const br_block_cbcdec_class , pub ighash : br_ghash , pub ichacha : br_chacha20_run , pub ipoly : br_poly1305_run , pub icbc_in : * const br_sslrec_in_cbc_class , pub icbc_out : * const br_sslrec_out_cbc_class , pub igcm_in : * const br_sslrec_in_gcm_class , pub igcm_out : * const br_sslrec_out_gcm_class , pub ichapol_in : * const br_sslrec_in_chapol_class , pub ichapol_out : * const br_sslrec_out_chapol_class , pub iec : * const br_ec_impl , pub irsavrfy : br_rsa_pkcs1_vrfy , pub iecdsa : br_ecdsa_vrfy , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_ssl_engine_context__bindgen_ty_1 { pub vtable : * const br_sslrec_in_class , pub cbc : br_sslrec_in_cbc_context , pub gcm : br_sslrec_gcm_context , pub chapol : br_sslrec_chapol_context , _bindgen_union_align : [ u64 ; 73usize ] , } # [ test ] fn bindgen_test_layout_br_ssl_engine_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_engine_context__bindgen_ty_1 > ( ) , 584usize , concat ! ( "Size of: " , stringify ! ( br_ssl_engine_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_engine_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_engine_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_1 > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_1 ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_1 > ( ) ) ) . cbc as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_1 ) , "::" , stringify ! ( cbc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_1 > ( ) ) ) . gcm as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_1 ) , "::" , stringify ! ( gcm ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_1 > ( ) ) ) . chapol as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_1 ) , "::" , stringify ! ( chapol ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_ssl_engine_context__bindgen_ty_2 { pub vtable : * const br_sslrec_out_class , pub clear : br_sslrec_out_clear_context , pub cbc : br_sslrec_out_cbc_context , pub gcm : br_sslrec_gcm_context , pub chapol : br_sslrec_chapol_context , _bindgen_union_align : [ u64 ; 73usize ] , } # [ test ] fn bindgen_test_layout_br_ssl_engine_context__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_engine_context__bindgen_ty_2 > ( ) , 584usize , concat ! ( "Size of: " , stringify ! ( br_ssl_engine_context__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_engine_context__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_engine_context__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_2 > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_2 ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_2 > ( ) ) ) . clear as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_2 ) , "::" , stringify ! ( clear ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_2 > ( ) ) ) . cbc as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_2 ) , "::" , stringify ! ( cbc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_2 > ( ) ) ) . gcm as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_2 ) , "::" , stringify ! ( gcm ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_2 > ( ) ) ) . chapol as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_2 ) , "::" , stringify ! ( chapol ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_engine_context__bindgen_ty_3 { pub dp : * mut u32 , pub rp : * mut u32 , pub ip : * const :: std :: os :: raw :: c_uchar , } # [ test ] fn bindgen_test_layout_br_ssl_engine_context__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_engine_context__bindgen_ty_3 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_ssl_engine_context__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_engine_context__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_engine_context__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_3 > ( ) ) ) . dp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_3 ) , "::" , stringify ! ( dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_3 > ( ) ) ) . rp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_3 ) , "::" , stringify ! ( rp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context__bindgen_ty_3 > ( ) ) ) . ip as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context__bindgen_ty_3 ) , "::" , stringify ! ( ip ) ) ) ; } # [ test ] fn bindgen_test_layout_br_ssl_engine_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_engine_context > ( ) , 3576usize , concat ! ( "Size of: " , stringify ! ( br_ssl_engine_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_engine_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_engine_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . err as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ibuf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ibuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . obuf as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( obuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ibuf_len as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ibuf_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . obuf_len as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( obuf_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . max_frag_len as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( max_frag_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . log_max_frag_len as * const _ as usize } , 42usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( log_max_frag_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . peer_log_max_frag_len as * const _ as usize } , 43usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( peer_log_max_frag_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ixa as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ixa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ixb as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ixb ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ixc as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ixc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . oxa as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( oxa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . oxb as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( oxb ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . oxc as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( oxc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . iomode as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( iomode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . incrypt as * const _ as usize } , 97usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( incrypt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . shutdown_recv as * const _ as usize } , 98usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( shutdown_recv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . record_type_in as * const _ as usize } , 99usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( record_type_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . record_type_out as * const _ as usize } , 100usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( record_type_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . version_in as * const _ as usize } , 102usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( version_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . version_out as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( version_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . in_ as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( in_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . out as * const _ as usize } , 696usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . application_data as * const _ as usize } , 1280usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( application_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . rng as * const _ as usize } , 1288usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( rng ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . rng_init_done as * const _ as usize } , 1432usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( rng_init_done ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . rng_os_rand_done as * const _ as usize } , 1436usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( rng_os_rand_done ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . version_min as * const _ as usize } , 1440usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( version_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . version_max as * const _ as usize } , 1442usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( version_max ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . suites_buf as * const _ as usize } , 1444usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( suites_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . suites_num as * const _ as usize } , 1524usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( suites_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . server_name as * const _ as usize } , 1525usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( server_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . client_random as * const _ as usize } , 1781usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( client_random ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . server_random as * const _ as usize } , 1813usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( server_random ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . session as * const _ as usize } , 1846usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( session ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ecdhe_curve as * const _ as usize } , 1932usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ecdhe_curve ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ecdhe_point as * const _ as usize } , 1933usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ecdhe_point ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ecdhe_point_len as * const _ as usize } , 2066usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ecdhe_point_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . reneg as * const _ as usize } , 2067usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( reneg ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . saved_finished as * const _ as usize } , 2068usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( saved_finished ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . flags as * const _ as usize } , 2092usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . cpu as * const _ as usize } , 2096usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( cpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . dp_stack as * const _ as usize } , 2120usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( dp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . rp_stack as * const _ as usize } , 2248usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( rp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . pad as * const _ as usize } , 2376usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( pad ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . hbuf_in as * const _ as usize } , 2888usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( hbuf_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . hbuf_out as * const _ as usize } , 2896usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( hbuf_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . saved_hbuf_out as * const _ as usize } , 2904usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( saved_hbuf_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . hlen_in as * const _ as usize } , 2912usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( hlen_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . hlen_out as * const _ as usize } , 2920usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( hlen_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . hsrun as * const _ as usize } , 2928usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( hsrun ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . action as * const _ as usize } , 2936usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( action ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . alert as * const _ as usize } , 2937usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( alert ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . close_received as * const _ as usize } , 2938usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( close_received ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . mhash as * const _ as usize } , 2944usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( mhash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . x509ctx as * const _ as usize } , 3360usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( x509ctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . chain as * const _ as usize } , 3368usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . chain_len as * const _ as usize } , 3376usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( chain_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . cert_cur as * const _ as usize } , 3384usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( cert_cur ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . cert_len as * const _ as usize } , 3392usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( cert_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . protocol_names as * const _ as usize } , 3400usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( protocol_names ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . protocol_names_num as * const _ as usize } , 3408usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( protocol_names_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . selected_protocol as * const _ as usize } , 3410usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( selected_protocol ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . prf10 as * const _ as usize } , 3416usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( prf10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . prf_sha256 as * const _ as usize } , 3424usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( prf_sha256 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . prf_sha384 as * const _ as usize } , 3432usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( prf_sha384 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . iaes_cbcenc as * const _ as usize } , 3440usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( iaes_cbcenc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . iaes_cbcdec as * const _ as usize } , 3448usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( iaes_cbcdec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . iaes_ctr as * const _ as usize } , 3456usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( iaes_ctr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ides_cbcenc as * const _ as usize } , 3464usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ides_cbcenc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ides_cbcdec as * const _ as usize } , 3472usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ides_cbcdec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ighash as * const _ as usize } , 3480usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ighash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ichacha as * const _ as usize } , 3488usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ichacha ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ipoly as * const _ as usize } , 3496usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ipoly ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . icbc_in as * const _ as usize } , 3504usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( icbc_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . icbc_out as * const _ as usize } , 3512usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( icbc_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . igcm_in as * const _ as usize } , 3520usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( igcm_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . igcm_out as * const _ as usize } , 3528usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( igcm_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ichapol_in as * const _ as usize } , 3536usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ichapol_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . ichapol_out as * const _ as usize } , 3544usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( ichapol_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . iec as * const _ as usize } , 3552usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( iec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . irsavrfy as * const _ as usize } , 3560usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( irsavrfy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_engine_context > ( ) ) ) . iecdsa as * const _ as usize } , 3568usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_engine_context ) , "::" , stringify ! ( iecdsa ) ) ) ; } extern "C" {
 
 /// \brief Set the list of cipher suites advertised by this context.
///
/// The provided array is copied into the context. It is the caller
/// responsibility to ensure that all provided suites will be supported
/// by the context. The engine context has enough room to receive _all_
/// suites supported by the implementation. The provided array MUST NOT
/// contain duplicates.
///
/// If the engine is for a client, the "signaling" pseudo-cipher suite
/// `TLS_FALLBACK_SCSV` can be added at the end of the list, if the
/// calling application is performing a voluntary downgrade (voluntary
/// downgrades are not recommended, but if such a downgrade is done, then
/// adding the fallback pseudo-suite is a good idea).
///
/// \param cc           SSL engine context.
/// \param suites       cipher suites.
/// \param suites_num   number of cipher suites. 
 
 pub fn br_ssl_engine_set_suites ( cc : * mut br_ssl_engine_context , suites : * const u16 , suites_num : usize , ) ; 
} extern "C" {
 
 /// \brief Set the "default" AES/CBC implementations.
///
/// This function configures in the engine the AES implementations that
/// should provide best runtime performance on the local system, while
/// still being safe (in particular, constant-time). It also sets the
/// handlers for CBC records.
///
/// \param cc   SSL engine context. 
 
 pub fn br_ssl_engine_set_default_aes_cbc ( cc : * mut br_ssl_engine_context , ) ; 
} extern "C" {
 
 /// \brief Set the "default" implementations for AES/GCM (AES/CTR + GHASH).
///
/// This function configures in the engine the AES/CTR and GHASH
/// implementation that should provide best runtime performance on the local
/// system, while still being safe (in particular, constant-time). It also
/// sets the handlers for GCM records.
///
/// \param cc   SSL engine context. 
 
 pub fn br_ssl_engine_set_default_aes_gcm ( cc : * mut br_ssl_engine_context , ) ; 
} extern "C" {
 
 /// \brief Set the "default" DES/CBC implementations.
///
/// This function configures in the engine the DES implementations that
/// should provide best runtime performance on the local system, while
/// still being safe (in particular, constant-time). It also sets the
/// handlers for CBC records.
///
/// \param cc   SSL engine context. 
 
 pub fn br_ssl_engine_set_default_des_cbc ( cc : * mut br_ssl_engine_context , ) ; 
} extern "C" {
 
 /// \brief Set the "default" ChaCha20 and Poly1305 implementations.
///
/// This function configures in the engine the ChaCha20 and Poly1305
/// implementations that should provide best runtime performance on the
/// local system, while still being safe (in particular, constant-time).
/// It also sets the handlers for ChaCha20+Poly1305 records.
///
/// \param cc   SSL engine context. 
 
 pub fn br_ssl_engine_set_default_chapol ( cc : * mut br_ssl_engine_context , ) ; 
} extern "C" {
 
 /// \brief Set the "default" EC implementation.
///
/// This function sets the elliptic curve implementation for ECDH and
/// ECDHE cipher suites, and for ECDSA support. It selects the fastest
/// implementation on the current system.
///
/// \param cc   SSL engine context. 
 
 pub fn br_ssl_engine_set_default_ec ( cc : * mut br_ssl_engine_context , ) ; 
} extern "C" {
 
 /// \brief Set the "default" RSA implementation (signature verification).
///
/// This function sets the RSA implementation (signature verification)
/// to the fastest implementation available on the current platform.
///
/// \param cc   SSL engine context. 
 
 pub fn br_ssl_engine_set_default_rsavrfy ( cc : * mut br_ssl_engine_context , ) ; 
} extern "C" {
 
 /// \brief Set the "default" ECDSA implementation (signature verification).
///
/// This function sets the ECDSA implementation (signature verification)
/// to the fastest implementation available on the current platform. This
/// call also sets the elliptic curve implementation itself, there again
/// to the fastest EC implementation available.
///
/// \param cc   SSL engine context. 
 
 pub fn br_ssl_engine_set_default_ecdsa ( cc : * mut br_ssl_engine_context , ) ; 
} extern "C" {
 
 /// \brief Set the I/O buffer for the SSL engine.
///
/// Once this call has been made, `br_ssl_client_reset()` or
/// `br_ssl_server_reset()` MUST be called before using the context.
///
/// The provided buffer will be used as long as the engine context is
/// used. The caller is responsible for keeping it available.
///
/// If `bidi` is 0, then the engine will operate in half-duplex mode
/// (it won't be able to send data while there is unprocessed incoming
/// data in the buffer, and it won't be able to receive data while there
/// is unsent data in the buffer). The optimal buffer size in half-duplex
/// mode is `BR_SSL_BUFSIZE_MONO`; if the buffer is larger, then extra
/// bytes are ignored. If the buffer is smaller, then this limits the
/// capacity of the engine to support all allowed record sizes.
///
/// If `bidi` is 1, then the engine will split the buffer into two
/// parts, for separate handling of outgoing and incoming data. This
/// enables full-duplex processing, but requires more RAM. The optimal
/// buffer size in full-duplex mode is `BR_SSL_BUFSIZE_BIDI`; if the
/// buffer is larger, then extra bytes are ignored. If the buffer is
/// smaller, then the split will favour the incoming part, so that
/// interoperability is maximised.
///
/// \param cc          SSL engine context
/// \param iobuf       I/O buffer.
/// \param iobuf_len   I/O buffer length (in bytes).
/// \param bidi        non-zero for full-duplex mode. 
 
 pub fn br_ssl_engine_set_buffer ( cc : * mut br_ssl_engine_context , iobuf : * mut :: std :: os :: raw :: c_void , iobuf_len : usize , bidi : :: std :: os :: raw :: c_int , ) ; 
} extern "C" {
 
 /// \brief Set the I/O buffers for the SSL engine.
///
/// Once this call has been made, `br_ssl_client_reset()` or
/// `br_ssl_server_reset()` MUST be called before using the context.
///
/// This function is similar to `br_ssl_engine_set_buffer()`, except
/// that it enforces full-duplex mode, and the two I/O buffers are
/// provided as separate chunks.
///
/// The macros `BR_SSL_BUFSIZE_INPUT` and `BR_SSL_BUFSIZE_OUTPUT`
/// evaluate to the optimal (maximum) sizes for the input and output
/// buffer, respectively.
///
/// \param cc         SSL engine context
/// \param ibuf       input buffer.
/// \param ibuf_len   input buffer length (in bytes).
/// \param obuf       output buffer.
/// \param obuf_len   output buffer length (in bytes). 
 
 pub fn br_ssl_engine_set_buffers_bidi ( cc : * mut br_ssl_engine_context , ibuf : * mut :: std :: os :: raw :: c_void , ibuf_len : usize , obuf : * mut :: std :: os :: raw :: c_void , obuf_len : usize , ) ; 
} extern "C" {
 
 /// \brief Inject some "initial entropy" in the context.
///
/// This entropy will be added to what can be obtained from the
/// underlying operating system, if that OS is supported.
///
/// This function may be called several times; all injected entropy chunks
/// are cumulatively mixed.
///
/// If entropy gathering from the OS is supported and compiled in, then this
/// step is optional. Otherwise, it is mandatory to inject randomness, and
/// the caller MUST take care to push (as one or several successive calls)
/// enough entropy to achieve cryptographic resistance (at least 80 bits,
/// preferably 128 or more). The engine will report an error if no entropy
/// was provided and none can be obtained from the OS.
///
/// Take care that this function cannot assess the cryptographic quality of
/// the provided bytes.
///
/// In all generality, "entropy" must here be considered to mean "that
/// which the attacker cannot predict". If your OS/architecture does not
/// have a suitable source of randomness, then you can make do with the
/// combination of a large enough secret value (possibly a copy of an
/// asymmetric private key that you also store on the system) AND a
/// non-repeating value (e.g. current time, provided that the local clock
/// cannot be reset or altered by the attacker).
///
/// \param cc     SSL engine context.
/// \param data   extra entropy to inject.
/// \param len    length of the extra data (in bytes). 
 
 pub fn br_ssl_engine_inject_entropy ( cc : * mut br_ssl_engine_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) ; 
} extern "C" {
 
 /// \brief Get the current engine state.
///
/// An SSL engine (client or server) has, at any time, a state which is
/// the combination of zero, one or more of these flags:
///
/// - `BR_SSL_CLOSED`
///
/// Engine is finished, no more I/O (until next reset).
///
/// - `BR_SSL_SENDREC`
///
/// Engine has some bytes to send to the peer.
///
/// - `BR_SSL_RECVREC`
///
/// Engine expects some bytes from the peer.
///
/// - `BR_SSL_SENDAPP`
///
/// Engine may receive application data to send (or flush).
///
/// - `BR_SSL_RECVAPP`
///
/// Engine has obtained some application data from the peer,
/// that should be read by the caller.
///
/// If no flag at all is set (state value is 0), then the engine is not
/// fully initialised yet.
///
/// The `BR_SSL_CLOSED` flag is exclusive; when it is set, no other flag
/// is set. To distinguish between a normal closure and an error, use
/// `br_ssl_engine_last_error()`.
///
/// Generally speaking, `BR_SSL_SENDREC` and `BR_SSL_SENDAPP` are mutually
/// exclusive: the input buffer, at any point, either accumulates
/// plaintext data, or contains an assembled record that is being sent.
/// Similarly, `BR_SSL_RECVREC` and `BR_SSL_RECVAPP` are mutually exclusive.
/// This may change in a future library version.
///
/// \param cc   SSL engine context.
/// \return  the current engine state. 
 
 pub fn br_ssl_engine_current_state ( cc : * const br_ssl_engine_context , ) -> :: std :: os :: raw :: c_uint ; 
} extern "C" {
 
 /// \brief Get buffer for application data to send.
///
/// If the engine is ready to accept application data to send to the
/// peer, then this call returns a pointer to the buffer where such
/// data shall be written, and its length is written in `*len`.
/// Otherwise, `*len` is set to 0 and `NULL` is returned.
///
/// \param cc    SSL engine context.
/// \param len   receives the application data output buffer length, or 0.
/// \return  the application data output buffer, or `NULL`. 
 
 pub fn br_ssl_engine_sendapp_buf ( cc : * const br_ssl_engine_context , len : * mut usize , ) -> * mut :: std :: os :: raw :: c_uchar ; 
} extern "C" {
 
 /// \brief Inform the engine of some new application data.
///
/// After writing `len` bytes in the buffer returned by
/// `br_ssl_engine_sendapp_buf()`, the application shall call this
/// function to trigger any relevant processing. The `len` parameter
/// MUST NOT be 0, and MUST NOT exceed the value obtained in the
/// `br_ssl_engine_sendapp_buf()` call.
///
/// \param cc    SSL engine context.
/// \param len   number of bytes pushed (not zero). 
 
 pub fn br_ssl_engine_sendapp_ack ( cc : * mut br_ssl_engine_context , len : usize , ) ; 
} extern "C" {
 
 /// \brief Get buffer for received application data.
///
/// If the engine has received application data from the peer, hen this
/// call returns a pointer to the buffer from where such data shall be
/// read, and its length is written in `*len`. Otherwise, `*len` is set
/// to 0 and `NULL` is returned.
///
/// \param cc    SSL engine context.
/// \param len   receives the application data input buffer length, or 0.
/// \return  the application data input buffer, or `NULL`. 
 
 pub fn br_ssl_engine_recvapp_buf ( cc : * const br_ssl_engine_context , len : * mut usize , ) -> * mut :: std :: os :: raw :: c_uchar ; 
} extern "C" {
 
 /// \brief Acknowledge some received application data.
///
/// After reading `len` bytes from the buffer returned by
/// `br_ssl_engine_recvapp_buf()`, the application shall call this
/// function to trigger any relevant processing. The `len` parameter
/// MUST NOT be 0, and MUST NOT exceed the value obtained in the
/// `br_ssl_engine_recvapp_buf()` call.
///
/// \param cc    SSL engine context.
/// \param len   number of bytes read (not zero). 
 
 pub fn br_ssl_engine_recvapp_ack ( cc : * mut br_ssl_engine_context , len : usize , ) ; 
} extern "C" {
 
 /// \brief Get buffer for record data to send.
///
/// If the engine has prepared some records to send to the peer, then this
/// call returns a pointer to the buffer from where such data shall be
/// read, and its length is written in `*len`. Otherwise, `*len` is set
/// to 0 and `NULL` is returned.
///
/// \param cc    SSL engine context.
/// \param len   receives the record data output buffer length, or 0.
/// \return  the record data output buffer, or `NULL`. 
 
 pub fn br_ssl_engine_sendrec_buf ( cc : * const br_ssl_engine_context , len : * mut usize , ) -> * mut :: std :: os :: raw :: c_uchar ; 
} extern "C" {
 
 /// \brief Acknowledge some sent record data.
///
/// After reading `len` bytes from the buffer returned by
/// `br_ssl_engine_sendrec_buf()`, the application shall call this
/// function to trigger any relevant processing. The `len` parameter
/// MUST NOT be 0, and MUST NOT exceed the value obtained in the
/// `br_ssl_engine_sendrec_buf()` call.
///
/// \param cc    SSL engine context.
/// \param len   number of bytes read (not zero). 
 
 pub fn br_ssl_engine_sendrec_ack ( cc : * mut br_ssl_engine_context , len : usize , ) ; 
} extern "C" {
 
 /// \brief Get buffer for incoming records.
///
/// If the engine is ready to accept records from the peer, then this
/// call returns a pointer to the buffer where such data shall be
/// written, and its length is written in `*len`. Otherwise, `*len` is
/// set to 0 and `NULL` is returned.
///
/// \param cc    SSL engine context.
/// \param len   receives the record data input buffer length, or 0.
/// \return  the record data input buffer, or `NULL`. 
 
 pub fn br_ssl_engine_recvrec_buf ( cc : * const br_ssl_engine_context , len : * mut usize , ) -> * mut :: std :: os :: raw :: c_uchar ; 
} extern "C" {
 
 /// \brief Inform the engine of some new record data.
///
/// After writing `len` bytes in the buffer returned by
/// `br_ssl_engine_recvrec_buf()`, the application shall call this
/// function to trigger any relevant processing. The `len` parameter
/// MUST NOT be 0, and MUST NOT exceed the value obtained in the
/// `br_ssl_engine_recvrec_buf()` call.
///
/// \param cc    SSL engine context.
/// \param len   number of bytes pushed (not zero). 
 
 pub fn br_ssl_engine_recvrec_ack ( cc : * mut br_ssl_engine_context , len : usize , ) ; 
} extern "C" {
 
 /// \brief Flush buffered application data.
///
/// If some application data has been buffered in the engine, then wrap
/// it into a record and mark it for sending. If no application data has
/// been buffered but the engine would be ready to accept some, AND the
/// `force` parameter is non-zero, then an empty record is assembled and
/// marked for sending. In all other cases, this function does nothing.
///
/// Empty records are technically legal, but not all existing SSL/TLS
/// implementations support them. Empty records can be useful as a
/// transparent "keep-alive" mechanism to maintain some low-level
/// network activity.
///
/// \param cc      SSL engine context.
/// \param force   non-zero to force sending an empty record. 
 
 pub fn br_ssl_engine_flush ( cc : * mut br_ssl_engine_context , force : :: std :: os :: raw :: c_int , ) ; 
} extern "C" {
 
 /// \brief Initiate a closure.
///
/// If, at that point, the context is open and in ready state, then a
/// `close_notify` alert is assembled and marked for sending; this
/// triggers the closure protocol. Otherwise, no such alert is assembled.
///
/// \param cc   SSL engine context. 
 
 pub fn br_ssl_engine_close ( cc : * mut br_ssl_engine_context , ) ; 
} extern "C" {
 
 /// \brief Initiate a renegotiation.
///
/// If the engine is failed or closed, or if the peer is known not to
/// support secure renegotiation (RFC 5746), or if renegotiations have
/// been disabled with the `BR_OPT_NO_RENEGOTIATION` flag, or if there
/// is buffered incoming application data, then this function returns 0
/// and nothing else happens.
///
/// Otherwise, this function returns 1, and a renegotiation attempt is
/// triggered (if a handshake is already ongoing at that point, then
/// no new handshake is triggered).
///
/// \param cc   SSL engine context.
/// \return  1 on success, 0 on error. 
 
 pub fn br_ssl_engine_renegotiate ( cc : * mut br_ssl_engine_context , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Export key material from a connected SSL engine (RFC 5705).
///
/// This calls compute a secret key of arbitrary length from the master
/// secret of a connected SSL engine. If the provided context is not
/// currently in "application data" state (initial handshake is not
/// finished, another handshake is ongoing, or the connection failed or
/// was closed), then this function returns 0. Otherwise, a secret key of
/// length `len` bytes is computed and written in the buffer pointed to
/// by `dst`, and 1 is returned.
///
/// The computed key follows the specification described in RFC 5705.
/// That RFC includes two key computations, with and without a "context
/// value". If `context` is `NULL`, then the variant without context is
/// used; otherwise, the `context_len` bytes located at the address
/// pointed to by `context` are used in the computation. Note that it
/// is possible to have a "with context" key with a context length of
/// zero bytes, by setting `context` to a non-`NULL` value but
/// `context_len` to 0.
///
/// When context bytes are used, the context length MUST NOT exceed
/// 65535 bytes.
///
/// \param cc            SSL engine context.
/// \param dst           destination buffer for exported key.
/// \param len           exported key length (in bytes).
/// \param label         disambiguation label.
/// \param context       context value (or `NULL`).
/// \param context_len   context length (in bytes).
/// \return  1 on success, 0 on error. 
 
 pub fn br_ssl_key_export ( cc : * mut br_ssl_engine_context , dst : * mut :: std :: os :: raw :: c_void , len : usize , label : * const :: std :: os :: raw :: c_char , context : * const :: std :: os :: raw :: c_void , context_len : usize , ) -> :: std :: os :: raw :: c_int ; 
} pub type br_ssl_client_context = br_ssl_client_context_ ; 
 /// \brief Type for the client certificate, if requested by the server. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_client_certificate { 
 /// \brief Authentication type.
    ///
    /// This is either `BR_AUTH_RSA` (RSA signature), `BR_AUTH_ECDSA`
    /// (ECDSA signature), or `BR_AUTH_ECDH` (static ECDH key exchange). 
 pub auth_type : :: std :: os :: raw :: c_int , 
 /// \brief Hash function for computing the CertificateVerify.
    ///
    /// This is the symbolic identifier for the hash function that
    /// will be used to produce the hash of handshake messages, to
    /// be signed into the CertificateVerify. For full static ECDH
    /// (client and server certificates are both EC in the same
    /// curve, and static ECDH is used), this value is set to -1.
    ///
    /// Take care that with TLS 1.0 and 1.1, that value MUST match
    /// the protocol requirements: value must be 0 (MD5+SHA-1) for
    /// a RSA signature, or 2 (SHA-1) for an ECDSA signature. Only
    /// TLS 1.2 allows for other hash functions. 
 pub hash_id : :: std :: os :: raw :: c_int , 
 /// \brief Certificate chain to send to the server.
    ///
    /// This is an array of `br_x509_certificate` objects, each
    /// normally containing a DER-encoded certificate. The client
    /// code does not try to decode these elements. If there is no
    /// chain to send to the server, then this pointer shall be
    /// set to `NULL`. 
 pub chain : * const br_x509_certificate , 
 /// \brief Certificate chain length (number of certificates).
    ///
    /// If there is no chain to send to the server, then this value
    /// shall be set to 0. 
 pub chain_len : usize , } # [ test ] fn bindgen_test_layout_br_ssl_client_certificate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_client_certificate > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_ssl_client_certificate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_client_certificate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_client_certificate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate > ( ) ) ) . auth_type as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate ) , "::" , stringify ! ( auth_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate > ( ) ) ) . hash_id as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate ) , "::" , stringify ! ( hash_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate > ( ) ) ) . chain as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate ) , "::" , stringify ! ( chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate > ( ) ) ) . chain_len as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate ) , "::" , stringify ! ( chain_len ) ) ) ; } 
 /// \brief Class type for a certificate handler (client side).
///
/// A certificate handler selects a client certificate chain to send to
/// the server, upon explicit request from that server. It receives
/// the list of trust anchor DN from the server, and supported types
/// of certificates and signatures, and returns the chain to use. It
/// is also invoked to perform the corresponding private key operation
/// (a signature, or an ECDH computation).
///
/// The SSL client engine will first push the trust anchor DN with
/// `start_name_list()`, `start_name()`, `append_name()`, `end_name()`
/// and `end_name_list()`. Then it will call `choose()`, to select the
/// actual chain (and signature/hash algorithms). Finally, it will call
/// either `do_sign()` or `do_keyx()`, depending on the algorithm choices. 
 pub type br_ssl_client_certificate_class = br_ssl_client_certificate_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_client_certificate_class_ { 
 /// \brief Context size (in bytes). 
 pub context_size : usize , 
 /// \brief Begin reception of a list of trust anchor names. This
    /// is called while parsing the incoming CertificateRequest.
    ///
    /// \param pctx   certificate handler context. 
 pub start_name_list : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_client_certificate_class ) > , 
 /// \brief Begin reception of a new trust anchor name.
    ///
    /// The total encoded name length is provided; it is less than
    /// 65535 bytes.
    ///
    /// \param pctx   certificate handler context.
    /// \param len    encoded name length (in bytes). 
 pub start_name : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_client_certificate_class , len : usize ) > , 
 /// \brief Receive some more bytes for the current trust anchor name.
    ///
    /// The provided reference (`data`) points to a transient buffer
    /// they may be reused as soon as this function returns. The chunk
    /// length (`len`) is never zero.
    ///
    /// \param pctx   certificate handler context.
    /// \param data   anchor name chunk.
    /// \param len    anchor name chunk length (in bytes). 
 pub append_name : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_client_certificate_class , data : * const :: std :: os :: raw :: c_uchar , len : usize ) > , 
 /// \brief End current trust anchor name.
    ///
    /// This function is called when all the encoded anchor name data
    /// has been provided.
    ///
    /// \param pctx   certificate handler context. 
 pub end_name : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_client_certificate_class ) > , 
 /// \brief End list of trust anchor names.
    ///
    /// This function is called when all the anchor names in the
    /// CertificateRequest message have been obtained.
    ///
    /// \param pctx   certificate handler context. 
 pub end_name_list : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_client_certificate_class ) > , 
 /// \brief Select client certificate and algorithms.
    ///
    /// This callback function shall fill the provided `choices`
    /// structure with the selected algorithms and certificate chain.
    /// The `hash_id`, `chain` and `chain_len` fields must be set. If
    /// the client cannot or does not wish to send a certificate,
    /// then it shall set `chain` to `NULL` and `chain_len` to 0.
    ///
    /// The `auth_types` parameter describes the authentication types,
    /// signature algorithms and hash functions that are supported by
    /// both the client context and the server, and compatible with
    /// the current protocol version. This is a bit field with the
    /// following contents:
    ///
    /// - If RSA signatures with hash function x are supported, then
    /// bit x is set.
    ///
    /// - If ECDSA signatures with hash function x are supported,
    /// then bit 8+x is set.
    ///
    /// - If static ECDH is supported, with a RSA-signed certificate,
    /// then bit 16 is set.
    ///
    /// - If static ECDH is supported, with an ECDSA-signed certificate,
    /// then bit 17 is set.
    ///
    /// Notes:
    ///
    /// - When using TLS 1.0 or 1.1, the hash function for RSA
    /// signatures is always the special MD5+SHA-1 (id 0), and the
    /// hash function for ECDSA signatures is always SHA-1 (id 2).
    ///
    /// - When using TLS 1.2, the list of hash functions is trimmed
    /// down to include only hash functions that the client context
    /// can support. The actual server list can be obtained with
    /// `br_ssl_client_get_server_hashes()`; that list may be used
    /// to select the certificate chain to send to the server.
    ///
    /// \param pctx         certificate handler context.
    /// \param cc           SSL client context.
    /// \param auth_types   supported authentication types and algorithms.
    /// \param choices      destination structure for the policy choices. 
 pub choose : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_client_certificate_class , cc : * const br_ssl_client_context , auth_types : u32 , choices : * mut br_ssl_client_certificate ) > , 
 /// \brief Perform key exchange (client part).
    ///
    /// This callback is invoked in case of a full static ECDH key
    /// exchange:
    ///
    /// - the cipher suite uses `ECDH_RSA` or `ECDH_ECDSA`;
    ///
    /// - the server requests a client certificate;
    ///
    /// - the client has, and sends, a client certificate that
    /// uses an EC key in the same curve as the server's key,
    /// and chooses static ECDH (the `hash_id` field in the choice
    /// structure was set to -1).
    ///
    /// In that situation, this callback is invoked to compute the
    /// client-side ECDH: the provided `data` (of length `*len` bytes)
    /// is the server's public key point (as decoded from its
    /// certificate), and the client shall multiply that point with
    /// its own private key, and write back the X coordinate of the
    /// resulting point in the same buffer, starting at offset 0.
    /// The `*len` value shall be modified to designate the actual
    /// length of the X coordinate.
    ///
    /// The callback must uphold the following:
    ///
    /// - If the input array does not have the proper length for
    /// an encoded curve point, then an error (0) shall be reported.
    ///
    /// - If the input array has the proper length, then processing
    /// MUST be constant-time, even if the data is not a valid
    /// encoded point.
    ///
    /// - This callback MUST check that the input point is valid.
    ///
    /// Returned value is 1 on success, 0 on error.
    ///
    /// \param pctx   certificate handler context.
    /// \param data   server public key point.
    /// \param len    public key point length / X coordinate length.
    /// \return  1 on success, 0 on error. 
 pub do_keyx : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_client_certificate_class , data : * mut :: std :: os :: raw :: c_uchar , len : * mut usize ) -> u32 > , 
 /// \brief Perform a signature (client authentication).
    ///
    /// This callback is invoked when a client certificate was sent,
    /// and static ECDH is not used. It shall compute a signature,
    /// using the client's private key, over the provided hash value
    /// (which is the hash of all previous handshake messages).
    ///
    /// On input, the hash value to sign is in `data`, of size
    /// `hv_len`; the involved hash function is identified by
    /// `hash_id`. The signature shall be computed and written
    /// back into `data`; the total size of that buffer is `len`
    /// bytes.
    ///
    /// This callback shall verify that the signature length does not
    /// exceed `len` bytes, and abstain from writing the signature if
    /// it does not fit.
    ///
    /// For RSA signatures, the `hash_id` may be 0, in which case
    /// this is the special header-less signature specified in TLS 1.0
    /// and 1.1, with a 36-byte hash value. Otherwise, normal PKCS#1
    /// v1.5 signatures shall be computed.
    ///
    /// For ECDSA signatures, the signature value shall use the ASN.1
    /// based encoding.
    ///
    /// Returned value is the signature length (in bytes), or 0 on error.
    ///
    /// \param pctx      certificate handler context.
    /// \param hash_id   hash function identifier.
    /// \param hv_len    hash value length (in bytes).
    /// \param data      input/output buffer (hash value, then signature).
    /// \param len       total buffer length (in bytes).
    /// \return  signature length (in bytes) on success, or 0 on error. 
 pub do_sign : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_client_certificate_class , hash_id : :: std :: os :: raw :: c_int , hv_len : usize , data : * mut :: std :: os :: raw :: c_uchar , len : usize ) -> usize > , } # [ test ] fn bindgen_test_layout_br_ssl_client_certificate_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_client_certificate_class_ > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( br_ssl_client_certificate_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_client_certificate_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_client_certificate_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . start_name_list as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( start_name_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . start_name as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( start_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . append_name as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( append_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . end_name as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( end_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . end_name_list as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( end_name_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . choose as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( choose ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . do_keyx as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( do_keyx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_class_ > ( ) ) ) . do_sign as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_class_ ) , "::" , stringify ! ( do_sign ) ) ) ; } 
 /// \brief A single-chain RSA client certificate handler.
///
/// This handler uses a single certificate chain, with a RSA
/// signature. The list of trust anchor DN is ignored.
///
/// Apart from the first field (vtable pointer), its contents are
/// opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_client_certificate_rsa_context { 
 /// \brief Pointer to vtable. 
 pub vtable : * const br_ssl_client_certificate_class , pub chain : * const br_x509_certificate , pub chain_len : usize , pub sk : * const br_rsa_private_key , pub irsasign : br_rsa_pkcs1_sign , } # [ test ] fn bindgen_test_layout_br_ssl_client_certificate_rsa_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_client_certificate_rsa_context > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( br_ssl_client_certificate_rsa_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_client_certificate_rsa_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_client_certificate_rsa_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_rsa_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_rsa_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_rsa_context > ( ) ) ) . chain as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_rsa_context ) , "::" , stringify ! ( chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_rsa_context > ( ) ) ) . chain_len as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_rsa_context ) , "::" , stringify ! ( chain_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_rsa_context > ( ) ) ) . sk as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_rsa_context ) , "::" , stringify ! ( sk ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_rsa_context > ( ) ) ) . irsasign as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_rsa_context ) , "::" , stringify ! ( irsasign ) ) ) ; } 
 /// \brief A single-chain EC client certificate handler.
///
/// This handler uses a single certificate chain, with a RSA
/// signature. The list of trust anchor DN is ignored.
///
/// This handler may support both static ECDH, and ECDSA signatures
/// (either usage may be selectively disabled).
///
/// Apart from the first field (vtable pointer), its contents are
/// opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_client_certificate_ec_context { 
 /// \brief Pointer to vtable. 
 pub vtable : * const br_ssl_client_certificate_class , pub chain : * const br_x509_certificate , pub chain_len : usize , pub sk : * const br_ec_private_key , pub allowed_usages : :: std :: os :: raw :: c_uint , pub issuer_key_type : :: std :: os :: raw :: c_uint , pub mhash : * const br_multihash_context , pub iec : * const br_ec_impl , pub iecdsa : br_ecdsa_sign , } # [ test ] fn bindgen_test_layout_br_ssl_client_certificate_ec_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_client_certificate_ec_context > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( br_ssl_client_certificate_ec_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_client_certificate_ec_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_client_certificate_ec_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . chain as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . chain_len as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( chain_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . sk as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( sk ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . allowed_usages as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( allowed_usages ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . issuer_key_type as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( issuer_key_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . mhash as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( mhash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . iec as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( iec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_certificate_ec_context > ( ) ) ) . iecdsa as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_certificate_ec_context ) , "::" , stringify ! ( iecdsa ) ) ) ; } 
 /// \brief Context structure for a SSL client.
///
/// The first field (called `eng`) is the SSL engine; all functions that
/// work on a `br_ssl_engine_context` structure shall take as parameter
/// a pointer to that field. The other structure fields are opaque and
/// must not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_ssl_client_context_ { 
 /// \brief The encapsulated engine context. 
 pub eng : br_ssl_engine_context , pub min_clienthello_len : u16 , pub hashes : u32 , pub server_curve : :: std :: os :: raw :: c_int , pub client_auth_vtable : * mut * const br_ssl_client_certificate_class , pub auth_type : :: std :: os :: raw :: c_uchar , pub hash_id : :: std :: os :: raw :: c_uchar , pub client_auth : br_ssl_client_context___bindgen_ty_1 , pub irsapub : br_rsa_public , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_ssl_client_context___bindgen_ty_1 { pub vtable : * const br_ssl_client_certificate_class , pub single_rsa : br_ssl_client_certificate_rsa_context , pub single_ec : br_ssl_client_certificate_ec_context , _bindgen_union_align : [ u64 ; 8usize ] , } # [ test ] fn bindgen_test_layout_br_ssl_client_context___bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_client_context___bindgen_ty_1 > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( br_ssl_client_context___bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_client_context___bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_client_context___bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context___bindgen_ty_1 > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context___bindgen_ty_1 ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context___bindgen_ty_1 > ( ) ) ) . single_rsa as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context___bindgen_ty_1 ) , "::" , stringify ! ( single_rsa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context___bindgen_ty_1 > ( ) ) ) . single_ec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context___bindgen_ty_1 ) , "::" , stringify ! ( single_ec ) ) ) ; } # [ test ] fn bindgen_test_layout_br_ssl_client_context_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_client_context_ > ( ) , 3680usize , concat ! ( "Size of: " , stringify ! ( br_ssl_client_context_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_client_context_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_client_context_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . eng as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( eng ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . min_clienthello_len as * const _ as usize } , 3576usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( min_clienthello_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . hashes as * const _ as usize } , 3580usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( hashes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . server_curve as * const _ as usize } , 3584usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( server_curve ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . client_auth_vtable as * const _ as usize } , 3592usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( client_auth_vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . auth_type as * const _ as usize } , 3600usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( auth_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . hash_id as * const _ as usize } , 3601usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( hash_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . client_auth as * const _ as usize } , 3608usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( client_auth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_client_context_ > ( ) ) ) . irsapub as * const _ as usize } , 3672usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_client_context_ ) , "::" , stringify ! ( irsapub ) ) ) ; } extern "C" {
 
 /// \brief SSL client profile: full.
///
/// This function initialises the provided SSL client context with
/// all supported algorithms and cipher suites. It also initialises
/// a companion X.509 validation engine with all supported algorithms,
/// and the provided trust anchors; the X.509 engine will be used by
/// the client context to validate the server's certificate.
///
/// \param cc                  client context to initialise.
/// \param xc                  X.509 validation context to initialise.
/// \param trust_anchors       trust anchors to use.
/// \param trust_anchors_num   number of trust anchors. 
 
 pub fn br_ssl_client_init_full ( cc : * mut br_ssl_client_context , xc : * mut br_x509_minimal_context , trust_anchors : * const br_x509_trust_anchor , trust_anchors_num : usize , ) ; 
} extern "C" {
 
 /// \brief Clear the complete contents of a SSL client context.
///
/// Everything is cleared, including the reference to the configured buffer,
/// implementations, cipher suites and state. This is a preparatory step
/// to assembling a custom profile.
///
/// \param cc   client context to clear. 
 
 pub fn br_ssl_client_zero ( cc : * mut br_ssl_client_context , ) ; 
} extern "C" {
 
 /// \brief Set the "default" RSA implementation for public-key operations.
///
/// This sets the RSA implementation in the client context (for encrypting
/// the pre-master secret, in `TLS_RSA_*` cipher suites) to the fastest
/// available on the current platform.
///
/// \param cc   client context. 
 
 pub fn br_ssl_client_set_default_rsapub ( cc : * mut br_ssl_client_context , ) ; 
} extern "C" {
 
 /// \brief Prepare or reset a client context for a new connection.
///
/// The `server_name` parameter is used to fill the SNI extension; the
/// X.509 "minimal" engine will also match that name against the server
/// names included in the server's certificate. If the parameter is
/// `NULL` then no SNI extension will be sent, and the X.509 "minimal"
/// engine (if used for server certificate validation) will not check
/// presence of any specific name in the received certificate.
///
/// Therefore, setting the `server_name` to `NULL` shall be reserved
/// to cases where alternate or additional methods are used to ascertain
/// that the right server public key is used (e.g. a "known key" model).
///
/// If `resume_session` is non-zero and the context was previously used
/// then the session parameters may be reused (depending on whether the
/// server previously sent a non-empty session ID, and accepts the session
/// resumption). The session parameters for session resumption can also
/// be set explicitly with `br_ssl_engine_set_session_parameters()`.
///
/// On failure, the context is marked as failed, and this function
/// returns 0. A possible failure condition is when no initial entropy
/// was injected, and none could be obtained from the OS (either OS
/// randomness gathering is not supported, or it failed).
///
/// \param cc               client context.
/// \param server_name      target server name, or `NULL`.
/// \param resume_session   non-zero to try session resumption.
/// \return  0 on failure, 1 on success. 
 
 pub fn br_ssl_client_reset ( cc : * mut br_ssl_client_context , server_name : * const :: std :: os :: raw :: c_char , resume_session : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Set client certificate chain and key (single RSA case).
///
/// This function sets a client certificate chain, that the client will
/// send to the server whenever a client certificate is requested. This
/// certificate uses an RSA public key; the corresponding private key is
/// invoked for authentication. Trust anchor names sent by the server are
/// ignored.
///
/// The provided chain and private key are linked in the client context;
/// they must remain valid as long as they may be used, i.e. normally
/// for the duration of the connection, since they might be invoked
/// again upon renegotiations.
///
/// \param cc          SSL client context.
/// \param chain       client certificate chain (SSL order: EE comes first).
/// \param chain_len   client chain length (number of certificates).
/// \param sk          client private key.
/// \param irsasign    RSA signature implementation (PKCS#1 v1.5). 
 
 pub fn br_ssl_client_set_single_rsa ( cc : * mut br_ssl_client_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_rsa_private_key , irsasign : br_rsa_pkcs1_sign , ) ; 
} extern "C" {
 pub fn br_ssl_client_set_single_ec ( cc : * mut br_ssl_client_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_ec_private_key , allowed_usages : :: std :: os :: raw :: c_uint , cert_issuer_key_type : :: std :: os :: raw :: c_uint , iec : * const br_ec_impl , iecdsa : br_ecdsa_sign , ) ; 
} 
 /// \brief Type for a "translated cipher suite", as an array of two
/// 16-bit integers.
///
/// The first element is the cipher suite identifier (as used on the wire).
/// The second element is the concatenation of four 4-bit elements which
/// characterise the cipher suite contents. In most to least significant
/// order, these 4-bit elements are:
///
/// - Bits 12 to 15: key exchange + server key type
///
/// | val | symbolic constant        | suite type  | details                                          |
/// | :-- | :----------------------- | :---------- | :----------------------------------------------- |
/// |  0  | `BR_SSLKEYX_RSA`         | RSA         | RSA key exchange, key is RSA (encryption)        |
/// |  1  | `BR_SSLKEYX_ECDHE_RSA`   | ECDHE_RSA   | ECDHE key exchange, key is RSA (signature)       |
/// |  2  | `BR_SSLKEYX_ECDHE_ECDSA` | ECDHE_ECDSA | ECDHE key exchange, key is EC (signature)        |
/// |  3  | `BR_SSLKEYX_ECDH_RSA`    | ECDH_RSA    | Key is EC (key exchange), cert signed with RSA   |
/// |  4  | `BR_SSLKEYX_ECDH_ECDSA`  | ECDH_ECDSA  | Key is EC (key exchange), cert signed with ECDSA |
///
/// - Bits 8 to 11: symmetric encryption algorithm
///
/// | val | symbolic constant      | symmetric encryption | key strength (bits) |
/// | :-- | :--------------------- | :------------------- | :------------------ |
/// |  0  | `BR_SSLENC_3DES_CBC`   | 3DES/CBC             | 168                 |
/// |  1  | `BR_SSLENC_AES128_CBC` | AES-128/CBC          | 128                 |
/// |  2  | `BR_SSLENC_AES256_CBC` | AES-256/CBC          | 256                 |
/// |  3  | `BR_SSLENC_AES128_GCM` | AES-128/GCM          | 128                 |
/// |  4  | `BR_SSLENC_AES256_GCM` | AES-256/GCM          | 256                 |
/// |  5  | `BR_SSLENC_CHACHA20`   | ChaCha20/Poly1305    | 256                 |
///
/// - Bits 4 to 7: MAC algorithm
///
/// | val | symbolic constant  | MAC type     | details                               |
/// | :-- | :----------------- | :----------- | :------------------------------------ |
/// |  0  | `BR_SSLMAC_AEAD`   | AEAD         | No dedicated MAC (encryption is AEAD) |
/// |  2  | `BR_SSLMAC_SHA1`   | HMAC/SHA-1   | Value matches `br_sha1_ID`            |
/// |  4  | `BR_SSLMAC_SHA256` | HMAC/SHA-256 | Value matches `br_sha256_ID`          |
/// |  5  | `BR_SSLMAC_SHA384` | HMAC/SHA-384 | Value matches `br_sha384_ID`          |
///
/// - Bits 0 to 3: hash function for PRF when used with TLS-1.2
///
/// | val | symbolic constant  | hash function | details                              |
/// | :-- | :----------------- | :------------ | :----------------------------------- |
/// |  4  | `BR_SSLPRF_SHA256` | SHA-256       | Value matches `br_sha256_ID`         |
/// |  5  | `BR_SSLPRF_SHA384` | SHA-384       | Value matches `br_sha384_ID`         |
///
/// For instance, cipher suite `TLS_RSA_WITH_AES_128_GCM_SHA256` has
/// standard identifier 0x009C, and is translated to 0x0304, for, in
/// that order: RSA key exchange (0), AES-128/GCM (3), AEAD integrity (0),
/// SHA-256 in the TLS PRF (4). 
 pub type br_suite_translated = [ u16 ; 2usize ] ; pub type br_ssl_server_context = br_ssl_server_context_ ; 
 /// \brief Type for the server policy choices, taken after analysis of
/// the client message (ClientHello). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_server_choices { 
 /// \brief Cipher suite to use with that client. 
 pub cipher_suite : u16 , 
 /// \brief Hash function or algorithm for signing the ServerKeyExchange.
    ///
    /// This parameter is ignored for `TLS_RSA_*` and `TLS_ECDH_*`
    /// cipher suites; it is used only for `TLS_ECDHE_*` suites, in
    /// which the server _signs_ the ephemeral EC Diffie-Hellman
    /// parameters sent to the client.
    ///
    /// This identifier must be one of the following values:
    ///
    /// - `0xFF00 + id`, where `id` is a hash function identifier
    /// (0 for MD5+SHA-1, or 2 to 6 for one of the SHA functions);
    ///
    /// - a full 16-bit identifier, lower than `0xFF00`.
    ///
    /// If the first option is used, then the SSL engine will
    /// compute the hash of the data that is to be signed, with the
    /// designated hash function. The `do_sign()` method will be
    /// invoked with that hash value provided in the the `data`
    /// buffer.
    ///
    /// If the second option is used, then the SSL engine will NOT
    /// compute a hash on the data; instead, it will provide the
    /// to-be-signed data itself in `data`, i.e. the concatenation of
    /// the client random, server random, and encoded ECDH
    /// parameters. Furthermore, with TLS-1.2 and later, the 16-bit
    /// identifier will be used "as is" in the protocol, in the
    /// SignatureAndHashAlgorithm; for instance, `0x0401` stands for
    /// RSA PKCS#1 v1.5 signature (the `01`) with SHA-256 as hash
    /// function (the `04`).
    ///
    /// Take care that with TLS 1.0 and 1.1, the hash function is
    /// constrainted by the protocol: RSA signature must use
    /// MD5+SHA-1 (so use `0xFF00`), while ECDSA must use SHA-1
    /// (`0xFF02`). Since TLS 1.0 and 1.1 don't include a
    /// SignatureAndHashAlgorithm field in their ServerKeyExchange
    /// messages, any value below `0xFF00` will be usable to send the
    /// raw ServerKeyExchange data to the `do_sign()` callback, but
    /// that callback must still follow the protocol requirements
    /// when generating the signature. 
 pub algo_id : :: std :: os :: raw :: c_uint , 
 /// \brief Certificate chain to send to the client.
    ///
    /// This is an array of `br_x509_certificate` objects, each
    /// normally containing a DER-encoded certificate. The server
    /// code does not try to decode these elements. 
 pub chain : * const br_x509_certificate , 
 /// \brief Certificate chain length (number of certificates). 
 pub chain_len : usize , } # [ test ] fn bindgen_test_layout_br_ssl_server_choices ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_server_choices > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_ssl_server_choices ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_server_choices > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_server_choices ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_choices > ( ) ) ) . cipher_suite as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_choices ) , "::" , stringify ! ( cipher_suite ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_choices > ( ) ) ) . algo_id as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_choices ) , "::" , stringify ! ( algo_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_choices > ( ) ) ) . chain as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_choices ) , "::" , stringify ! ( chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_choices > ( ) ) ) . chain_len as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_choices ) , "::" , stringify ! ( chain_len ) ) ) ; } 
 /// \brief Class type for a policy handler (server side).
///
/// A policy handler selects the policy parameters for a connection
/// (cipher suite and other algorithms, and certificate chain to send to
/// the client); it also performs the server-side computations involving
/// its permanent private key.
///
/// The SSL server engine will invoke first `choose()`, once the
/// ClientHello message has been received, then either `do_keyx()`
/// `do_sign()`, depending on the cipher suite. 
 pub type br_ssl_server_policy_class = br_ssl_server_policy_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_server_policy_class_ { 
 /// \brief Context size (in bytes). 
 pub context_size : usize , 
 /// \brief Select algorithms and certificates for this connection.
    ///
    /// This callback function shall fill the provided `choices`
    /// structure with the policy choices for this connection. This
    /// entails selecting the cipher suite, hash function for signing
    /// the ServerKeyExchange (applicable only to ECDHE cipher suites),
    /// and certificate chain to send.
    ///
    /// The callback receives a pointer to the server context that
    /// contains the relevant data. In particular, the functions
    /// `br_ssl_server_get_client_suites()`,
    /// `br_ssl_server_get_client_hashes()` and
    /// `br_ssl_server_get_client_curves()` can be used to obtain
    /// the cipher suites, hash functions and elliptic curves
    /// supported by both the client and server, respectively. The
    /// `br_ssl_engine_get_version()` and `br_ssl_engine_get_server_name()`
    /// functions yield the protocol version and requested server name
    /// (SNI), respectively.
    ///
    /// This function may modify its context structure (`pctx`) in
    /// arbitrary ways to keep track of its own choices.
    ///
    /// This function shall return 1 if appropriate policy choices
    /// could be made, or 0 if this connection cannot be pursued.
    ///
    /// \param pctx      policy context.
    /// \param cc        SSL server context.
    /// \param choices   destination structure for the policy choices.
    /// \return  1 on success, 0 on error. 
 pub choose : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_server_policy_class , cc : * const br_ssl_server_context , choices : * mut br_ssl_server_choices ) -> :: std :: os :: raw :: c_int > , 
 /// \brief Perform key exchange (server part).
    ///
    /// This callback is invoked to perform the server-side cryptographic
    /// operation for a key exchange that is not ECDHE. This callback
    /// uses the private key.
    ///
    /// **For RSA key exchange**, the provided `data` (of length `*len`
    /// bytes) shall be decrypted with the server's private key, and
    /// the 48-byte premaster secret copied back to the first 48 bytes
    /// of `data`.
    ///
    /// - The caller makes sure that `*len` is at least 59 bytes.
    ///
    /// - This callback MUST check that the provided length matches
    /// that of the key modulus; it shall report an error otherwise.
    ///
    /// - If the length matches that of the RSA key modulus, then
    /// processing MUST be constant-time, even if decryption fails,
    /// or the padding is incorrect, or the plaintext message length
    /// is not exactly 48 bytes.
    ///
    /// - This callback needs not check the two first bytes of the
    /// obtained pre-master secret (the caller will do that).
    ///
    /// - If an error is reported (0), then what the callback put
    /// in the first 48 bytes of `data` is unimportant (the caller
    /// will use random bytes instead).
    ///
    /// **For ECDH key exchange**, the provided `data` (of length `*len`
    /// bytes) is the elliptic curve point from the client. The
    /// callback shall multiply it with its private key, and store
    /// the resulting X coordinate in `data`, starting at offset 0,
    /// and set `*len` to the length of the X coordinate.
    ///
    /// - If the input array does not have the proper length for
    /// an encoded curve point, then an error (0) shall be reported.
    ///
    /// - If the input array has the proper length, then processing
    /// MUST be constant-time, even if the data is not a valid
    /// encoded point.
    ///
    /// - This callback MUST check that the input point is valid.
    ///
    /// Returned value is 1 on success, 0 on error.
    ///
    /// \param pctx   policy context.
    /// \param data   key exchange data from the client.
    /// \param len    key exchange data length (in bytes).
    /// \return  1 on success, 0 on error. 
 pub do_keyx : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_server_policy_class , data : * mut :: std :: os :: raw :: c_uchar , len : * mut usize ) -> u32 > , 
 /// \brief Perform a signature (for a ServerKeyExchange message).
    ///
    /// This callback function is invoked for ECDHE cipher suites. On
    /// input, the hash value or message to sign is in `data`, of
    /// size `hv_len`; the involved hash function or algorithm is
    /// identified by `algo_id`. The signature shall be computed and
    /// written back into `data`; the total size of that buffer is
    /// `len` bytes.
    ///
    /// This callback shall verify that the signature length does not
    /// exceed `len` bytes, and abstain from writing the signature if
    /// it does not fit.
    ///
    /// The `algo_id` value matches that which was written in the
    /// `choices` structures by the `choose()` callback. This will be
    /// one of the following:
    ///
    /// - `0xFF00 + id` for a hash function identifier `id`. In
    /// that case, the `data` buffer contains a hash value
    /// already computed over the data that is to be signed,
    /// of length `hv_len`. The `id` may be 0 to designate the
    /// special MD5+SHA-1 concatenation (old-style RSA signing).
    ///
    /// - Another value, lower than `0xFF00`. The `data` buffer
    /// then contains the raw, non-hashed data to be signed
    /// (concatenation of the client and server randoms and
    /// ECDH parameters). The callback is responsible to apply
    /// any relevant hashing as part of the signing process.
    ///
    /// Returned value is the signature length (in bytes), or 0 on error.
    ///
    /// \param pctx      policy context.
    /// \param algo_id   hash function / algorithm identifier.
    /// \param data      input/output buffer (message/hash, then signature).
    /// \param hv_len    hash value or message length (in bytes).
    /// \param len       total buffer length (in bytes).
    /// \return  signature length (in bytes) on success, or 0 on error. 
 pub do_sign : :: std :: option :: Option < unsafe extern "C" fn ( pctx : * mut * const br_ssl_server_policy_class , algo_id : :: std :: os :: raw :: c_uint , data : * mut :: std :: os :: raw :: c_uchar , hv_len : usize , len : usize ) -> usize > , } # [ test ] fn bindgen_test_layout_br_ssl_server_policy_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_server_policy_class_ > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( br_ssl_server_policy_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_server_policy_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_server_policy_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_class_ > ( ) ) ) . choose as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_class_ ) , "::" , stringify ! ( choose ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_class_ > ( ) ) ) . do_keyx as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_class_ ) , "::" , stringify ! ( do_keyx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_class_ > ( ) ) ) . do_sign as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_class_ ) , "::" , stringify ! ( do_sign ) ) ) ; } 
 /// \brief A single-chain RSA policy handler.
///
/// This policy context uses a single certificate chain, and a RSA
/// private key. The context can be restricted to only signatures or
/// only key exchange.
///
/// Apart from the first field (vtable pointer), its contents are
/// opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_server_policy_rsa_context { 
 /// \brief Pointer to vtable. 
 pub vtable : * const br_ssl_server_policy_class , pub chain : * const br_x509_certificate , pub chain_len : usize , pub sk : * const br_rsa_private_key , pub allowed_usages : :: std :: os :: raw :: c_uint , pub irsacore : br_rsa_private , pub irsasign : br_rsa_pkcs1_sign , } # [ test ] fn bindgen_test_layout_br_ssl_server_policy_rsa_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_server_policy_rsa_context > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( br_ssl_server_policy_rsa_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_server_policy_rsa_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_server_policy_rsa_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_rsa_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_rsa_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_rsa_context > ( ) ) ) . chain as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_rsa_context ) , "::" , stringify ! ( chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_rsa_context > ( ) ) ) . chain_len as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_rsa_context ) , "::" , stringify ! ( chain_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_rsa_context > ( ) ) ) . sk as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_rsa_context ) , "::" , stringify ! ( sk ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_rsa_context > ( ) ) ) . allowed_usages as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_rsa_context ) , "::" , stringify ! ( allowed_usages ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_rsa_context > ( ) ) ) . irsacore as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_rsa_context ) , "::" , stringify ! ( irsacore ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_rsa_context > ( ) ) ) . irsasign as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_rsa_context ) , "::" , stringify ! ( irsasign ) ) ) ; } 
 /// \brief A single-chain EC policy handler.
///
/// This policy context uses a single certificate chain, and an EC
/// private key. The context can be restricted to only signatures or
/// only key exchange.
///
/// Due to how TLS is defined, this context must be made aware whether
/// the server certificate was itself signed with RSA or ECDSA. The code
/// does not try to decode the certificate to obtain that information.
///
/// Apart from the first field (vtable pointer), its contents are
/// opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_server_policy_ec_context { 
 /// \brief Pointer to vtable. 
 pub vtable : * const br_ssl_server_policy_class , pub chain : * const br_x509_certificate , pub chain_len : usize , pub sk : * const br_ec_private_key , pub allowed_usages : :: std :: os :: raw :: c_uint , pub cert_issuer_key_type : :: std :: os :: raw :: c_uint , pub mhash : * const br_multihash_context , pub iec : * const br_ec_impl , pub iecdsa : br_ecdsa_sign , } # [ test ] fn bindgen_test_layout_br_ssl_server_policy_ec_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_server_policy_ec_context > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( br_ssl_server_policy_ec_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_server_policy_ec_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_server_policy_ec_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . chain as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . chain_len as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( chain_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . sk as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( sk ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . allowed_usages as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( allowed_usages ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . cert_issuer_key_type as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( cert_issuer_key_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . mhash as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( mhash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . iec as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( iec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_policy_ec_context > ( ) ) ) . iecdsa as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_policy_ec_context ) , "::" , stringify ! ( iecdsa ) ) ) ; } 
 /// \brief Class type for a session parameter cache.
///
/// Session parameters are saved in the cache with `save()`, and
/// retrieved with `load()`. The cache implementation can apply any
/// storage and eviction strategy that it sees fit. The SSL server
/// context that performs the request is provided, so that its
/// functionalities may be used by the implementation (e.g. hash
/// functions or random number generation). 
 pub type br_ssl_session_cache_class = br_ssl_session_cache_class_ ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_session_cache_class_ { 
 /// \brief Context size (in bytes). 
 pub context_size : usize , 
 /// \brief Record a session.
    ///
    /// This callback should record the provided session parameters.
    /// The `params` structure is transient, so its contents shall
    /// be copied into the cache. The session ID has been randomly
    /// generated and always has length exactly 32 bytes.
    ///
    /// \param ctx          session cache context.
    /// \param server_ctx   SSL server context.
    /// \param params       session parameters to save. 
 pub save : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_ssl_session_cache_class , server_ctx : * mut br_ssl_server_context , params : * const br_ssl_session_parameters ) > , 
 /// \brief Lookup a session in the cache.
    ///
    /// The session ID to lookup is in `params` and always has length
    /// exactly 32 bytes. If the session parameters are found in the
    /// cache, then the parameters shall be copied into the `params`
    /// structure. Returned value is 1 on successful lookup, 0
    /// otherwise.
    ///
    /// \param ctx          session cache context.
    /// \param server_ctx   SSL server context.
    /// \param params       destination for session parameters.
    /// \return  1 if found, 0 otherwise. 
 pub load : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut * const br_ssl_session_cache_class , server_ctx : * mut br_ssl_server_context , params : * mut br_ssl_session_parameters ) -> :: std :: os :: raw :: c_int > , } # [ test ] fn bindgen_test_layout_br_ssl_session_cache_class_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_session_cache_class_ > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_ssl_session_cache_class_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_session_cache_class_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_session_cache_class_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_class_ > ( ) ) ) . context_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_class_ ) , "::" , stringify ! ( context_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_class_ > ( ) ) ) . save as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_class_ ) , "::" , stringify ! ( save ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_class_ > ( ) ) ) . load as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_class_ ) , "::" , stringify ! ( load ) ) ) ; } 
 /// \brief Context for a basic cache system.
///
/// The system stores session parameters in a buffer provided at
/// initialisation time. Each entry uses exactly 100 bytes, and
/// buffer sizes up to 4294967295 bytes are supported.
///
/// Entries are evicted with a LRU (Least Recently Used) policy. A
/// search tree is maintained to keep lookups fast even with large
/// caches.
///
/// Apart from the first field (vtable pointer), the structure
/// contents are opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_ssl_session_cache_lru { 
 /// \brief Pointer to vtable. 
 pub vtable : * const br_ssl_session_cache_class , pub store : * mut :: std :: os :: raw :: c_uchar , pub store_len : usize , pub store_ptr : usize , pub index_key : [ :: std :: os :: raw :: c_uchar ; 32usize ] , pub hash : * const br_hash_class , pub init_done : :: std :: os :: raw :: c_int , pub head : u32 , pub tail : u32 , pub root : u32 , } # [ test ] fn bindgen_test_layout_br_ssl_session_cache_lru ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_session_cache_lru > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( br_ssl_session_cache_lru ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_session_cache_lru > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_session_cache_lru ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . store as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( store ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . store_len as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( store_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . store_ptr as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( store_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . index_key as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( index_key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . hash as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( hash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . init_done as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( init_done ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . head as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( head ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . tail as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( tail ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_session_cache_lru > ( ) ) ) . root as * const _ as usize } , 84usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_session_cache_lru ) , "::" , stringify ! ( root ) ) ) ; } extern "C" {
 
 /// \brief Initialise a LRU session cache with the provided storage space.
///
/// The provided storage space must remain valid as long as the cache
/// is used. Arbitrary lengths are supported, up to 4294967295 bytes;
/// each entry uses up exactly 100 bytes.
///
/// \param cc          session cache context.
/// \param store       storage space for cached entries.
/// \param store_len   storage space length (in bytes). 
 
 pub fn br_ssl_session_cache_lru_init ( cc : * mut br_ssl_session_cache_lru , store : * mut :: std :: os :: raw :: c_uchar , store_len : usize , ) ; 
} extern "C" {
 
 /// \brief Forget an entry in an LRU session cache.
///
/// The session cache context must have been initialised. The entry
/// with the provided session ID (of exactly 32 bytes) is looked for
/// in the cache; if located, it is disabled.
///
/// \param cc   session cache context.
/// \param id   session ID to forget. 
 
 pub fn br_ssl_session_cache_lru_forget ( cc : * mut br_ssl_session_cache_lru , id : * const :: std :: os :: raw :: c_uchar , ) ; 
} 
 /// \brief Context structure for a SSL server.
///
/// The first field (called `eng`) is the SSL engine; all functions that
/// work on a `br_ssl_engine_context` structure shall take as parameter
/// a pointer to that field. The other structure fields are opaque and
/// must not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_ssl_server_context_ { 
 /// \brief The encapsulated engine context. 
 pub eng : br_ssl_engine_context , pub client_max_version : u16 , pub cache_vtable : * mut * const br_ssl_session_cache_class , pub client_suites : [ br_suite_translated ; 40usize ] , pub client_suites_num : :: std :: os :: raw :: c_uchar , pub hashes : u32 , pub curves : u32 , pub policy_vtable : * mut * const br_ssl_server_policy_class , pub sign_hash_id : u16 , pub chain_handler : br_ssl_server_context___bindgen_ty_1 , pub ecdhe_key : [ :: std :: os :: raw :: c_uchar ; 70usize ] , pub ecdhe_key_len : usize , pub ta_names : * const br_x500_name , pub tas : * const br_x509_trust_anchor , pub num_tas : usize , pub cur_dn_index : usize , pub cur_dn : * const :: std :: os :: raw :: c_uchar , pub cur_dn_len : usize , pub hash_CV : [ :: std :: os :: raw :: c_uchar ; 64usize ] , pub hash_CV_len : usize , pub hash_CV_id : :: std :: os :: raw :: c_int , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union br_ssl_server_context___bindgen_ty_1 { pub vtable : * const br_ssl_server_policy_class , pub single_rsa : br_ssl_server_policy_rsa_context , pub single_ec : br_ssl_server_policy_ec_context , _bindgen_union_align : [ u64 ; 8usize ] , } # [ test ] fn bindgen_test_layout_br_ssl_server_context___bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_server_context___bindgen_ty_1 > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( br_ssl_server_context___bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_server_context___bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_server_context___bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context___bindgen_ty_1 > ( ) ) ) . vtable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context___bindgen_ty_1 ) , "::" , stringify ! ( vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context___bindgen_ty_1 > ( ) ) ) . single_rsa as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context___bindgen_ty_1 ) , "::" , stringify ! ( single_rsa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context___bindgen_ty_1 > ( ) ) ) . single_ec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context___bindgen_ty_1 ) , "::" , stringify ! ( single_ec ) ) ) ; } # [ test ] fn bindgen_test_layout_br_ssl_server_context_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_ssl_server_context_ > ( ) , 4056usize , concat ! ( "Size of: " , stringify ! ( br_ssl_server_context_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_ssl_server_context_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_ssl_server_context_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . eng as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( eng ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . client_max_version as * const _ as usize } , 3576usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( client_max_version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . cache_vtable as * const _ as usize } , 3584usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( cache_vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . client_suites as * const _ as usize } , 3592usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( client_suites ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . client_suites_num as * const _ as usize } , 3752usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( client_suites_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . hashes as * const _ as usize } , 3756usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( hashes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . curves as * const _ as usize } , 3760usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( curves ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . policy_vtable as * const _ as usize } , 3768usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( policy_vtable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . sign_hash_id as * const _ as usize } , 3776usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( sign_hash_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . chain_handler as * const _ as usize } , 3784usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( chain_handler ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . ecdhe_key as * const _ as usize } , 3848usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( ecdhe_key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . ecdhe_key_len as * const _ as usize } , 3920usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( ecdhe_key_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . ta_names as * const _ as usize } , 3928usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( ta_names ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . tas as * const _ as usize } , 3936usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( tas ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . num_tas as * const _ as usize } , 3944usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( num_tas ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . cur_dn_index as * const _ as usize } , 3952usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( cur_dn_index ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . cur_dn as * const _ as usize } , 3960usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( cur_dn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . cur_dn_len as * const _ as usize } , 3968usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( cur_dn_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . hash_CV as * const _ as usize } , 3976usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( hash_CV ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . hash_CV_len as * const _ as usize } , 4040usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( hash_CV_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_ssl_server_context_ > ( ) ) ) . hash_CV_id as * const _ as usize } , 4048usize , concat ! ( "Offset of field: " , stringify ! ( br_ssl_server_context_ ) , "::" , stringify ! ( hash_CV_id ) ) ) ; } extern "C" {
 
 /// \brief SSL server profile: full_rsa.
///
/// This function initialises the provided SSL server context with
/// all supported algorithms and cipher suites that rely on a RSA
/// key pair.
///
/// \param cc          server context to initialise.
/// \param chain       server certificate chain.
/// \param chain_len   certificate chain length (number of certificate).
/// \param sk          RSA private key. 
 
 pub fn br_ssl_server_init_full_rsa ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_rsa_private_key , ) ; 
} extern "C" {
 
 /// \brief SSL server profile: full_ec.
///
/// This function initialises the provided SSL server context with
/// all supported algorithms and cipher suites that rely on an EC
/// key pair.
///
/// The key type of the CA that issued the server's certificate must
/// be provided, since it matters for ECDH cipher suites (ECDH_RSA
/// suites require a RSA-powered CA). The key type is either
/// `BR_KEYTYPE_RSA` or `BR_KEYTYPE_EC`.
///
/// \param cc                     server context to initialise.
/// \param chain                  server certificate chain.
/// \param chain_len              chain length (number of certificates).
/// \param cert_issuer_key_type   certificate issuer's key type.
/// \param sk                     EC private key. 
 
 pub fn br_ssl_server_init_full_ec ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , cert_issuer_key_type : :: std :: os :: raw :: c_uint , sk : * const br_ec_private_key , ) ; 
} extern "C" {
 
 /// \brief SSL server profile: minr2g.
///
/// This profile uses only TLS_RSA_WITH_AES_128_GCM_SHA256. Server key is
/// RSA, and RSA key exchange is used (not forward secure, but uses little
/// CPU in the client).
///
/// \param cc          server context to initialise.
/// \param chain       server certificate chain.
/// \param chain_len   certificate chain length (number of certificate).
/// \param sk          RSA private key. 
 
 pub fn br_ssl_server_init_minr2g ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_rsa_private_key , ) ; 
} extern "C" {
 
 /// \brief SSL server profile: mine2g.
///
/// This profile uses only TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256. Server key
/// is RSA, and ECDHE key exchange is used. This suite provides forward
/// security, with a higher CPU expense on the client, and a somewhat
/// larger code footprint (compared to "minr2g").
///
/// \param cc          server context to initialise.
/// \param chain       server certificate chain.
/// \param chain_len   certificate chain length (number of certificate).
/// \param sk          RSA private key. 
 
 pub fn br_ssl_server_init_mine2g ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_rsa_private_key , ) ; 
} extern "C" {
 
 /// \brief SSL server profile: minf2g.
///
/// This profile uses only TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256.
/// Server key is EC, and ECDHE key exchange is used. This suite provides
/// forward security, with a higher CPU expense on the client and server
/// (by a factor of about 3 to 4), and a somewhat larger code footprint
/// (compared to "minu2g" and "minv2g").
///
/// \param cc          server context to initialise.
/// \param chain       server certificate chain.
/// \param chain_len   certificate chain length (number of certificate).
/// \param sk          EC private key. 
 
 pub fn br_ssl_server_init_minf2g ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_ec_private_key , ) ; 
} extern "C" {
 
 /// \brief SSL server profile: minu2g.
///
/// This profile uses only TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256.
/// Server key is EC, and ECDH key exchange is used; the issuing CA used
/// a RSA key.
///
/// The "minu2g" and "minv2g" profiles do not provide forward secrecy,
/// but are the lightest on the server (for CPU usage), and are rather
/// inexpensive on the client as well.
///
/// \param cc          server context to initialise.
/// \param chain       server certificate chain.
/// \param chain_len   certificate chain length (number of certificate).
/// \param sk          EC private key. 
 
 pub fn br_ssl_server_init_minu2g ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_ec_private_key , ) ; 
} extern "C" {
 
 /// \brief SSL server profile: minv2g.
///
/// This profile uses only TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256.
/// Server key is EC, and ECDH key exchange is used; the issuing CA used
/// an EC key.
///
/// The "minu2g" and "minv2g" profiles do not provide forward secrecy,
/// but are the lightest on the server (for CPU usage), and are rather
/// inexpensive on the client as well.
///
/// \param cc          server context to initialise.
/// \param chain       server certificate chain.
/// \param chain_len   certificate chain length (number of certificate).
/// \param sk          EC private key. 
 
 pub fn br_ssl_server_init_minv2g ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_ec_private_key , ) ; 
} extern "C" {
 
 /// \brief SSL server profile: mine2c.
///
/// This profile uses only TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256.
/// Server key is RSA, and ECDHE key exchange is used. This suite
/// provides forward security.
///
/// \param cc          server context to initialise.
/// \param chain       server certificate chain.
/// \param chain_len   certificate chain length (number of certificate).
/// \param sk          RSA private key. 
 
 pub fn br_ssl_server_init_mine2c ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_rsa_private_key , ) ; 
} extern "C" {
 
 /// \brief SSL server profile: minf2c.
///
/// This profile uses only TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256.
/// Server key is EC, and ECDHE key exchange is used. This suite provides
/// forward security.
///
/// \param cc          server context to initialise.
/// \param chain       server certificate chain.
/// \param chain_len   certificate chain length (number of certificate).
/// \param sk          EC private key. 
 
 pub fn br_ssl_server_init_minf2c ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_ec_private_key , ) ; 
} extern "C" {
 
 /// \brief Clear the complete contents of a SSL server context.
///
/// Everything is cleared, including the reference to the configured buffer,
/// implementations, cipher suites and state. This is a preparatory step
/// to assembling a custom profile.
///
/// \param cc   server context to clear. 
 
 pub fn br_ssl_server_zero ( cc : * mut br_ssl_server_context , ) ; 
} extern "C" {
 
 /// \brief Set the server certificate chain and key (single RSA case).
///
/// This function uses a policy context included in the server context.
/// It configures use of a single server certificate chain with a RSA
/// private key. The `allowed_usages` is a combination of usages, namely
/// `BR_KEYTYPE_KEYX` and/or `BR_KEYTYPE_SIGN`; this enables or disables
/// the corresponding cipher suites (i.e. `TLS_RSA_*` use the RSA key for
/// key exchange, while `TLS_ECDHE_RSA_*` use the RSA key for signatures).
///
/// \param cc               server context.
/// \param chain            server certificate chain to send to the client.
/// \param chain_len        chain length (number of certificates).
/// \param sk               server private key (RSA).
/// \param allowed_usages   allowed private key usages.
/// \param irsacore         RSA core implementation.
/// \param irsasign         RSA signature implementation (PKCS#1 v1.5). 
 
 pub fn br_ssl_server_set_single_rsa ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_rsa_private_key , allowed_usages : :: std :: os :: raw :: c_uint , irsacore : br_rsa_private , irsasign : br_rsa_pkcs1_sign , ) ; 
} extern "C" {
 
 /// \brief Set the server certificate chain and key (single EC case).
///
/// This function uses a policy context included in the server context.
/// It configures use of a single server certificate chain with an EC
/// private key. The `allowed_usages` is a combination of usages, namely
/// `BR_KEYTYPE_KEYX` and/or `BR_KEYTYPE_SIGN`; this enables or disables
/// the corresponding cipher suites (i.e. `TLS_ECDH_*` use the EC key for
/// key exchange, while `TLS_ECDHE_ECDSA_*` use the EC key for signatures).
///
/// In order to support `TLS_ECDH_*` cipher suites (non-ephemeral ECDH),
/// the algorithm type of the key used by the issuing CA to sign the
/// server's certificate must be provided, as `cert_issuer_key_type`
/// parameter (this value is either `BR_KEYTYPE_RSA` or `BR_KEYTYPE_EC`).
///
/// \param cc                     server context.
/// \param chain                  server certificate chain to send.
/// \param chain_len              chain length (number of certificates).
/// \param sk                     server private key (EC).
/// \param allowed_usages         allowed private key usages.
/// \param cert_issuer_key_type   issuing CA's key type.
/// \param iec                    EC core implementation.
/// \param iecdsa                 ECDSA signature implementation ("asn1" format). 
 
 pub fn br_ssl_server_set_single_ec ( cc : * mut br_ssl_server_context , chain : * const br_x509_certificate , chain_len : usize , sk : * const br_ec_private_key , allowed_usages : :: std :: os :: raw :: c_uint , cert_issuer_key_type : :: std :: os :: raw :: c_uint , iec : * const br_ec_impl , iecdsa : br_ecdsa_sign , ) ; 
} extern "C" {
 
 /// \brief Prepare or reset a server context for handling an incoming client.
///
/// \param cc   server context.
/// \return  1 on success, 0 on error. 
 
 pub fn br_ssl_server_reset ( cc : * mut br_ssl_server_context , ) -> :: std :: os :: raw :: c_int ; 
} 
 /// \brief Context structure for the simplified SSL I/O wrapper.
///
/// This structure is initialised with `br_sslio_init()`. Its contents
/// are opaque and shall not be accessed directly. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_sslio_context { pub engine : * mut br_ssl_engine_context , pub low_read : :: std :: option :: Option < unsafe extern "C" fn ( read_context : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_uchar , len : usize ) -> :: std :: os :: raw :: c_int > , pub read_context : * mut :: std :: os :: raw :: c_void , pub low_write : :: std :: option :: Option < unsafe extern "C" fn ( write_context : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_uchar , len : usize ) -> :: std :: os :: raw :: c_int > , pub write_context : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_br_sslio_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_sslio_context > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( br_sslio_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_sslio_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_sslio_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslio_context > ( ) ) ) . engine as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_sslio_context ) , "::" , stringify ! ( engine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslio_context > ( ) ) ) . low_read as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_sslio_context ) , "::" , stringify ! ( low_read ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslio_context > ( ) ) ) . read_context as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_sslio_context ) , "::" , stringify ! ( read_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslio_context > ( ) ) ) . low_write as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_sslio_context ) , "::" , stringify ! ( low_write ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_sslio_context > ( ) ) ) . write_context as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( br_sslio_context ) , "::" , stringify ! ( write_context ) ) ) ; } extern "C" {
 
 /// \brief Initialise a simplified I/O wrapper context.
///
/// The simplified I/O wrapper offers a simpler read/write API for a SSL
/// engine (client or server), using the provided callback functions for
/// reading data from, or writing data to, the transport medium.
///
/// The callback functions have the following semantics:
///
/// - Each callback receives an opaque context value (of type `void *`)
/// that the callback may use arbitrarily (or possibly ignore).
///
/// - `low_read()` reads at least one byte, at most `len` bytes, from
/// the transport medium. Read bytes shall be written in `data`.
///
/// - `low_write()` writes at least one byte, at most `len` bytes, unto
/// the transport medium. The bytes to write are read from `data`.
///
/// - The `len` parameter is never zero, and is always lower than 20000.
///
/// - The number of processed bytes (read or written) is returned. Since
/// that number is less than 20000, it always fits on an `int`.
///
/// - On error, the callbacks return -1. Reaching end-of-stream is an
/// error. Errors are permanent: the SSL connection is terminated.
///
/// - Callbacks SHOULD NOT return 0. This is tolerated, as long as
/// callbacks endeavour to block for some non-negligible amount of
/// time until at least one byte can be sent or received (if a
/// callback returns 0, then the wrapper invokes it again
/// immediately).
///
/// - Callbacks MAY return as soon as at least one byte is processed;
/// they MAY also insist on reading or writing _all_ requested bytes.
/// Since SSL is a self-terminated protocol (each record has a length
/// header), this does not change semantics.
///
/// - Callbacks need not apply any buffering (for performance) since SSL
/// itself uses buffers.
///
/// \param ctx             wrapper context to initialise.
/// \param engine          SSL engine to wrap.
/// \param low_read        callback for reading data from the transport.
/// \param read_context    context pointer for `low_read()`.
/// \param low_write       callback for writing data on the transport.
/// \param write_context   context pointer for `low_write()`. 
 
 pub fn br_sslio_init ( ctx : * mut br_sslio_context , engine : * mut br_ssl_engine_context , low_read : :: std :: option :: Option < unsafe extern "C" fn ( read_context : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_uchar , len : usize ) -> :: std :: os :: raw :: c_int > , read_context : * mut :: std :: os :: raw :: c_void , low_write : :: std :: option :: Option < unsafe extern "C" fn ( write_context : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_uchar , len : usize ) -> :: std :: os :: raw :: c_int > , write_context : * mut :: std :: os :: raw :: c_void , ) ; 
} extern "C" {
 
 /// \brief Read some application data from a SSL connection.
///
/// If `len` is zero, then this function returns 0 immediately. In
/// all other cases, it never returns 0.
///
/// This call returns only when at least one byte has been obtained.
/// Returned value is the number of bytes read, or -1 on error. The
/// number of bytes always fits on an 'int' (data from a single SSL/TLS
/// record is returned).
///
/// On error or SSL closure, this function returns -1. The caller should
/// inspect the error status on the SSL engine to distinguish between
/// normal closure and error.
///
/// \param cc    SSL wrapper context.
/// \param dst   destination buffer for application data.
/// \param len   maximum number of bytes to obtain.
/// \return  number of bytes obtained, or -1 on error. 
 
 pub fn br_sslio_read ( cc : * mut br_sslio_context , dst : * mut :: std :: os :: raw :: c_void , len : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Read application data from a SSL connection.
///
/// This calls returns only when _all_ requested `len` bytes are read,
/// or an error is reached. Returned value is 0 on success, -1 on error.
/// A normal (verified) SSL closure before that many bytes are obtained
/// is reported as an error by this function.
///
/// \param cc    SSL wrapper context.
/// \param dst   destination buffer for application data.
/// \param len   number of bytes to obtain.
/// \return  0 on success, or -1 on error. 
 
 pub fn br_sslio_read_all ( cc : * mut br_sslio_context , dst : * mut :: std :: os :: raw :: c_void , len : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Write some application data unto a SSL connection.
///
/// If `len` is zero, then this function returns 0 immediately. In
/// all other cases, it never returns 0.
///
/// This call returns only when at least one byte has been written.
/// Returned value is the number of bytes written, or -1 on error. The
/// number of bytes always fits on an 'int' (less than 20000).
///
/// On error or SSL closure, this function returns -1. The caller should
/// inspect the error status on the SSL engine to distinguish between
/// normal closure and error.
///
/// **Important:** SSL is buffered; a "written" byte is a byte that was
/// injected into the wrapped SSL engine, but this does not necessarily mean
/// that it has been scheduled for sending. Use `br_sslio_flush()` to
/// ensure that all pending data has been sent to the transport medium.
///
/// \param cc    SSL wrapper context.
/// \param src   source buffer for application data.
/// \param len   maximum number of bytes to write.
/// \return  number of bytes written, or -1 on error. 
 
 pub fn br_sslio_write ( cc : * mut br_sslio_context , src : * const :: std :: os :: raw :: c_void , len : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Write application data unto a SSL connection.
///
/// This calls returns only when _all_ requested `len` bytes have been
/// written, or an error is reached. Returned value is 0 on success, -1
/// on error. A normal (verified) SSL closure before that many bytes are
/// written is reported as an error by this function.
///
/// **Important:** SSL is buffered; a "written" byte is a byte that was
/// injected into the wrapped SSL engine, but this does not necessarily mean
/// that it has been scheduled for sending. Use `br_sslio_flush()` to
/// ensure that all pending data has been sent to the transport medium.
///
/// \param cc    SSL wrapper context.
/// \param src   source buffer for application data.
/// \param len   number of bytes to write.
/// \return  0 on success, or -1 on error. 
 
 pub fn br_sslio_write_all ( cc : * mut br_sslio_context , src : * const :: std :: os :: raw :: c_void , len : usize , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Flush pending data.
///
/// This call makes sure that any buffered application data in the
/// provided context (including the wrapped SSL engine) has been sent
/// to the transport medium (i.e. accepted by the `low_write()` callback
/// method). If there is no such pending data, then this function does
/// nothing (and returns a success, i.e. 0).
///
/// If the underlying transport medium has its own buffers, then it is
/// up to the caller to ensure the corresponding flushing.
///
/// Returned value is 0 on success, -1 on error.
///
/// \param cc    SSL wrapper context.
/// \return  0 on success, or -1 on error. 
 
 pub fn br_sslio_flush ( cc : * mut br_sslio_context , ) -> :: std :: os :: raw :: c_int ; 
} extern "C" {
 
 /// \brief Close the SSL connection.
///
/// This call runs the SSL closure protocol (sending a `close_notify`,
/// receiving the response `close_notify`). When it returns, the SSL
/// connection is finished. It is still up to the caller to manage the
/// possible transport-level termination, if applicable (alternatively,
/// the underlying transport stream may be reused for non-SSL messages).
///
/// Returned value is 0 on success, -1 on error. A failure by the peer
/// to process the complete closure protocol (i.e. sending back the
/// `close_notify`) is an error.
///
/// \param cc    SSL wrapper context.
/// \return  0 on success, or -1 on error. 
 
 pub fn br_sslio_close ( cc : * mut br_sslio_context , ) -> :: std :: os :: raw :: c_int ; 
} 
 /// \brief PEM decoder context.
///
/// Contents are opaque (they should not be accessed directly). 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct br_pem_decoder_context { pub cpu : br_pem_decoder_context__bindgen_ty_1 , pub dp_stack : [ u32 ; 32usize ] , pub rp_stack : [ u32 ; 32usize ] , pub err : :: std :: os :: raw :: c_int , pub hbuf : * const :: std :: os :: raw :: c_uchar , pub hlen : usize , pub dest : :: std :: option :: Option < unsafe extern "C" fn ( dest_ctx : * mut :: std :: os :: raw :: c_void , src : * const :: std :: os :: raw :: c_void , len : usize ) > , pub dest_ctx : * mut :: std :: os :: raw :: c_void , pub event : :: std :: os :: raw :: c_uchar , pub name : [ :: std :: os :: raw :: c_char ; 128usize ] , pub buf : [ :: std :: os :: raw :: c_uchar ; 255usize ] , pub ptr : usize , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_pem_decoder_context__bindgen_ty_1 { pub dp : * mut u32 , pub rp : * mut u32 , pub ip : * const :: std :: os :: raw :: c_uchar , } # [ test ] fn bindgen_test_layout_br_pem_decoder_context__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_pem_decoder_context__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( br_pem_decoder_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_pem_decoder_context__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_pem_decoder_context__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context__bindgen_ty_1 > ( ) ) ) . dp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context__bindgen_ty_1 ) , "::" , stringify ! ( dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context__bindgen_ty_1 > ( ) ) ) . rp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context__bindgen_ty_1 ) , "::" , stringify ! ( rp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context__bindgen_ty_1 > ( ) ) ) . ip as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context__bindgen_ty_1 ) , "::" , stringify ! ( ip ) ) ) ; } # [ test ] fn bindgen_test_layout_br_pem_decoder_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_pem_decoder_context > ( ) , 712usize , concat ! ( "Size of: " , stringify ! ( br_pem_decoder_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_pem_decoder_context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_pem_decoder_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . cpu as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( cpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . dp_stack as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( dp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . rp_stack as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( rp_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . err as * const _ as usize } , 280usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . hbuf as * const _ as usize } , 288usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( hbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . hlen as * const _ as usize } , 296usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( hlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . dest as * const _ as usize } , 304usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( dest ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . dest_ctx as * const _ as usize } , 312usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( dest_ctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . event as * const _ as usize } , 320usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( event ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . name as * const _ as usize } , 321usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . buf as * const _ as usize } , 449usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_pem_decoder_context > ( ) ) ) . ptr as * const _ as usize } , 704usize , concat ! ( "Offset of field: " , stringify ! ( br_pem_decoder_context ) , "::" , stringify ! ( ptr ) ) ) ; } extern "C" {
 
 /// \brief Initialise a PEM decoder structure.
///
/// \param ctx   decoder context to initialise. 
 
 pub fn br_pem_decoder_init ( ctx : * mut br_pem_decoder_context , ) ; 
} extern "C" {
 
 /// \brief Push some bytes into the decoder.
///
/// Returned value is the number of bytes actually consumed; this may be
/// less than the number of provided bytes if an event is raised. When an
/// event is raised, it must be read (with `br_pem_decoder_event()`);
/// until the event is read, this function will return 0.
///
/// \param ctx    decoder context.
/// \param data   new data bytes.
/// \param len    number of new data bytes.
/// \return  the number of bytes actually received (may be less than `len`). 
 
 pub fn br_pem_decoder_push ( ctx : * mut br_pem_decoder_context , data : * const :: std :: os :: raw :: c_void , len : usize , ) -> usize ; 
} extern "C" {
 
 /// \brief Get the last event.
///
/// If an event was raised, then this function returns the event value, and
/// also clears it, thereby allowing the decoder to proceed. If no event
/// was raised since the last call to `br_pem_decoder_event()`, then this
/// function returns 0.
///
/// \param ctx   decoder context.
/// \return  the raised event, or 0. 
 
 pub fn br_pem_decoder_event ( ctx : * mut br_pem_decoder_context , ) -> :: std :: os :: raw :: c_int ; 
} 
 /// \brief Type for a configuration option.
///
/// A "configuration option" is a value that is selected when the BearSSL
/// library itself is compiled. Most options are boolean; their value is
/// then either 1 (option is enabled) or 0 (option is disabled). Some
/// values have other integer values. Option names correspond to macro
/// names. Some of the options can be explicitly set in the internal
/// `"config.h"` file. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct br_config_option { 
 /// \brief Configurable option name. 
 pub name : * const :: std :: os :: raw :: c_char , 
 /// \brief Configurable option value. 
 pub value : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_br_config_option ( ) { assert_eq ! ( :: std :: mem :: size_of :: < br_config_option > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( br_config_option ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < br_config_option > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( br_config_option ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_config_option > ( ) ) ) . name as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( br_config_option ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < br_config_option > ( ) ) ) . value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( br_config_option ) , "::" , stringify ! ( value ) ) ) ; } extern "C" {
 
 /// \brief Get configuration report.
///
/// This function returns compiled configuration options, each as a
/// 'long' value. Names match internal macro names, in particular those
/// that can be set in the `"config.h"` inner file. For boolean options,
/// the numerical value is 1 if enabled, 0 if disabled. For maximum
/// key sizes, values are expressed in bits.
///
/// The returned array is terminated by an entry whose `name` is `NULL`.
///
/// \return  the configuration report. 
 
 pub fn br_get_config ( ) -> * const br_config_option ; 
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , }